// [PrintTSCodeOne]
// [PrintTSComments]
/*
 * ENetUC_Auth.ts
 * "UC-Server-Access-Protocol-Auth" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
/**
 * Authentication interface.
 * ## Module description
 * This module defines structures and functions for negotiation and authentication on the UCServer.
 *
 * Clients connecting to the UCServer Webservices don't need to negotiate and login by themselfes, they should use \"createsession\" instead.
 * See the \"Web Service Overview\" section of this documentation for more details.
 */
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
import * as ENetUC_Common_Auth from "./ENetUC_Common_Auth";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Auth";
export const MODULE_LASTCHANGE = "2024-08-21T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240821;
export const MODULE_VERSION = "8.0.20240821";

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnClientAppID {
	/** Unbekannt */
	eCLIENTAPPIDUNKNOWN = 0,
	/** Der Windows Client */
	eCLIENTAPPIDPROCALL = 1,
	/** Das Arbeitsplatzsetup */
	eCLIENTAPPIDCLNINST = 2,
	/** ENetSN aus der SDK */
	eCLIENTAPPIDENETSN = 3,
	/** ENetTSC aus der SDK */
	eCLIENTAPPIDENETTSC = 4,
	/** IVR DLL */
	eCLIENTAPPIDIVRDLL = 5,
	/** Kommandozeile (aus der SDK) */
	eCLIENTAPPIDECTISRVCMD = 6,
	/** Mobile Phones */
	eCLIENTAPPIDMOBILE = 7,
	/** Mobile iPad */
	eCLIENTAPPIDMOBILEPAD = 8,
	/** Ein anderer Dienst Ã¼ber den WebService */
	eCLIENTAPPIDWEBSERVICESDK = 9,
	/** MAC-Client */
	eCLIENTAPPIDMAC = 10,
	/** Web Clients - FIVE-1411 */
	eCLIENTAPPIDPROCALLWEB = 15,
	/** SIP-Clients */
	eCLIENTAPPIDPROCALLSIP = 16,
	/** XMPP-Clients */
	eCLIENTAPPIDPROCALLXMPP = 17,
	/** Der ProCall One Client */
	eCLIENTAPPIDPROCALLONE = 18,
	/** der PushServiceManager im Server selbst */
	eCLIENTAPPIDPUSHSERVICE = 19,
	/** ProCall Analytics */
	eCLIENTAPPIDPROCALLANALYTICS = 20,
	/** LiveChat WebClient (=Agentenarbeitsplatz LC-288) */
	eCLIENTAPPIDWEBLIVECHAT = 21,
	/** Der EWS Calendar Replication Service (vormals enumClientAppID::MOBILE_SDK bzw. enumClientAppID::WEBSERVICE_SDK) */
	eCLIENTAPPIDEXCHANGECALENDARREPLICATOR = 22,
	/** Der PAC Client (gleiches Executable wie eCLIENTAPPIDPROCALL) */
	eCLIENTAPPIDPROCALLPAC = 23,
	/** Der PAC Client (gleiches Executable wie eCLIENTAPPIDPROCALL) */
	eCLIENTAPPIDPROCALLPCB = 24,
	/** ProCall Meetings Client */
	eCLIENTAPPIDWEBCONFERENCING = 25,
	/** Standalone-WebApp */
	eCLIENTAPPIDPROCALLWEBAPP = 26,
	/** Client-Connection via WebView2 */
	eCLIENTAPPIDWEBVIEW2CLIENT = 27,
	/** MS Teams App */
	eCLIENTAPPIDMSTEAMSAPP = 28
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnNegotiateServerConnectionClientCapabilities {
	/** 0x0000 client is not offering any special capabilities */
	eNONE = 0,
	/** 0x0001 client is a softphone client and implements the functionalities of ENetUC_AV.asn1 */
	eSOFTPHONE = 1,
	/** 0x0002 client wants to provide an AV line for ProCall to ProCall Audio Video Chats (ENetUC_AV.asn1) */
	eAVLINE = 2,
	/** 0x0004 client is able to handle the new V2 events the asn1 interface is providing with the 08.2024 refactoring */
	eASN1V2EVENTS = 4
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnNegotiateServerConnectionServerTypeV2 {
	/** A standard UCServer */
	ePROCALLENTERPRISE = 0,
	/** A TAPI Server UCServer (Accepts no regular ProCall Clients, only TAPI drivers) */
	eTAPISERVER = 1,
	/** A Infinity Server (former DataCenter) */
	ePROCALLINFINITY = 2,
	/** A NEX Server (former UC as a service) */
	ePROCALLNEX = 3
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnNegotiateServerConnectionAuthenticationMethod {
	/** integrated password authentication */
	ePASSWORD = 0,
	/** domain authentication */
	eDOMAIN = 1,
	/** oauth authentication */
	eOAUTH = 2
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnLogonErrorEnum {
	/** An internal Server error occured. */
	eNETLOGININTERNALSERVERERROR = 100,
	/** User name not found or password wrong (since V6.3). Description text in error message tells now, that the user cannot be authenticated. */
	eNETLOGININVALUSERNAME = 101,
	/** No license free for user. */
	eNETLOGINNOMOREUSERS = 103,
	/** UCServer and UCClient version are not compatible. */
	eNETLOGININVALIDVERSION = 104,
	/** This is not really an error, but the server requests the next step in authentication from the client with this \"error\". */
	eNETLOGINNEGOTIATIONREQUIRED = 105,
	/** The requested authntication method is not supported by the usermanager. */
	eNETLOGININVALIDAUTHENTICATIONMETHOD = 106,
	/** The user is not enabled on this ucserver. */
	eNETLOGINUSERNOTENABLED = 107,
	/** Computer login only: the computer name is not found. */
	eNETLOGININVALIDCOMPUTERNAME = 108,
	/** Domain authentication failed. */
	eNETLOGINDOMAINAUTHFAILED = 109,
	/** The user has not enough access rights to login on the server. At the moment this occures only with a mobile client without the access right for mobiles. */
	eNETLOGINMISSINGRIGHTS = 110,
	/** Reserved. */
	eNETLOGINMISSINGRIGHTSTS = 111,
	/** The requested application type (given by negotiate) is not compatible with this server. */
	eNETLOGINSERVERNOTCOMPATIBLE = 112,
	/** User is already logged in. */
	eNETLOGINALREADYAUTHENTICATED = 113,
	/** The has to use a TLS connection to this server. */
	eNETLOGINTLSREQUIRED = 114,
	/** User account has been locked due to too many failed login attempts. */
	eNETLOGINACCOUNTPASSWORDLOCKED = 129,
	/** The given token has been expired. */
	eNETLOGINTOKENEXIRED = 130,
	/** Too many failed login attempts, the user has to wait some time to try again. */
	eNETLOGINTOOMANYATTEMPTS = 131,
	/** Reserved. */
	eNETLOGINWRONGPACMODE = 133
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnUserTokenType {
	/** Token for authenticating to an external Server - does not allow to login to UCServer */
	eUserTokenExternal = 0,
	/** Token that allows Login To UCServer */
	eUserTokenLogin = 1
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnAdminLoginChoice {
	public constructor(that?: AsnAdminLoginChoice) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAdminLoginChoice {
		return new AsnAdminLoginChoice();
	}

	public static type = "AsnAdminLoginChoice";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnAdminLoginChoice",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sAdminPassword", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sAdminPasswordCrypted", idBlock: { optionalID: 1 } })
			]
		});
	}

	public u8sAdminPassword?: string;
	public u8sAdminPasswordCrypted?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * In case an anonymous client wants to connect it needs to provides these details in the AsnNegotiateServerConnectionV2Argument
 */
export class AsnNegotiateServerConnectionAnonymousDataArgument {
	public constructor(that: AsnNegotiateServerConnectionAnonymousDataArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionAnonymousDataArgument {
		return new AsnNegotiateServerConnectionAnonymousDataArgument({
			u8sHintData: "",
			u8sToken: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sHintData",
			"u8sToken"
		];
		return p;
	}

	public static type = "AsnNegotiateServerConnectionAnonymousDataArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNegotiateServerConnectionAnonymousDataArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sHintData" }),
				new asn1ts.Utf8String({ name: "u8sToken" }),
				new asn1ts.Extension()
			]
		});
	}

	/** This is a fingerprint to reidentify the same client */
	public u8sHintData!: string;
	/** This is like a password for the client to authenticate the client */
	public u8sToken!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * When an anonymous client connects the server provides a username and a token
 */
export class AsnNegotiateServerConnectionAnonymousDataResult {
	public constructor(that: AsnNegotiateServerConnectionAnonymousDataResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionAnonymousDataResult {
		return new AsnNegotiateServerConnectionAnonymousDataResult({
			u8sUsername: "",
			u8sToken: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sUsername",
			"u8sToken"
		];
		return p;
	}

	public static type = "AsnNegotiateServerConnectionAnonymousDataResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNegotiateServerConnectionAnonymousDataResult",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sUsername" }),
				new asn1ts.Utf8String({ name: "u8sToken" }),
				new asn1ts.Extension()
			]
		});
	}

	/** The username of the anonymous user */
	public u8sUsername!: string;
	/** This is like a password for the client to authenticate the client */
	public u8sToken!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Server is busy result of the asnNegotiateServerConnectionV2 operation
 */
export class AsnNegotiateServerConnectionV2ServerBusy {
	public constructor(that: AsnNegotiateServerConnectionV2ServerBusy) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionV2ServerBusy {
		return new AsnNegotiateServerConnectionV2ServerBusy({
			iServerBusyTimeout: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iServerBusyTimeout"
		];
		return p;
	}

	public static type = "AsnNegotiateServerConnectionV2ServerBusy";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNegotiateServerConnectionV2ServerBusy",
			...params,
			value: [
				new asn1ts.Integer({ name: "iServerBusyTimeout" }),
				new asn1ts.Extension()
			]
		});
	}

	/** In case the server is busy we tell the client when to retry again */
	public iServerBusyTimeout!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Interface not compatible result of the asnNegotiateServerConnectionV2 operation
 */
export class AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion {
	public constructor(that: AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion {
		return new AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion({
			u8sServerInterfaceVersion: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sServerInterfaceVersion"
		];
		return p;
	}

	public static type = "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sServerInterfaceVersion" }),
				new asn1ts.Extension()
			]
		});
	}

	/** The asn1 interface version of the server */
	public u8sServerInterfaceVersion!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnLogoffArgument {
	public constructor(that?: AsnLogoffArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLogoffArgument {
		return new AsnLogoffArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnLogoffArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLogoffArgument",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Result of asnGetUserTokenV2.
 */
export class AsnGetUserTokenV2Result {
	public constructor(that: AsnGetUserTokenV2Result) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetUserTokenV2Result {
		return new AsnGetUserTokenV2Result({
			sToken: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"sToken"
		];
		return p;
	}

	public static type = "AsnGetUserTokenV2Result";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetUserTokenV2Result",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "sToken" }),
				new asn1ts.Extension()
			]
		});
	}

	/** JWT Token */
	public sToken!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Profile values added as public claim as [Service_type]\/[Profile elementname] : [Profile elementvalue] used by asnGetUserToken.
 */
export class AsnProfileAttribute {
	public constructor(that: AsnProfileAttribute) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnProfileAttribute {
		return new AsnProfileAttribute({
			u8sServiceType: "",
			u8seName: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sServiceType",
			"u8seName"
		];
		if (bIncludeOptionals)
			p.push("u8sValue");
		return p;
	}

	public static type = "AsnProfileAttribute";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnProfileAttribute",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sServiceType" }),
				new asn1ts.Utf8String({ name: "u8seName" }),
				new asn1ts.Utf8String({ name: "u8sValue", idBlock: { optionalID: 0 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** Service Type used as a namespace for a specific profile attribute */
	public u8sServiceType!: string;
	public u8seName!: string;
	/** Can be used as placeholder is the profile attribute does not exits */
	public u8sValue?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argument for asnGetLoggedInContact.
 * This opertaion does not need any parameter since the logged in contact is alread well known on the server.
 */
export class AsnGetLoggedInContactArgument {
	public constructor(that?: AsnGetLoggedInContactArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetLoggedInContactArgument {
		return new AsnGetLoggedInContactArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnGetLoggedInContactArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetLoggedInContactArgument",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Result of AsnGetLoggedInContactV2.
 *
 * @added 21.08.2024
 */
export class AsnGetLoggedInContactV2Result {
	public constructor(that: AsnGetLoggedInContactV2Result) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetLoggedInContactV2Result {
		return new AsnGetLoggedInContactV2Result({
			u8sLoggedInUser: "",
			ownContact: ENetUC_Common_AsnContact.AsnContactV2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sLoggedInUser",
			"ownContact"
		];
		return p;
	}

	public static type = "AsnGetLoggedInContactV2Result";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetLoggedInContactV2Result",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sLoggedInUser" }),
				ENetUC_Common_AsnContact.AsnContactV2.getASN1Schema({ name: "ownContact" }),
				new asn1ts.Extension()
			]
		});
	}

	/** The Login User Name */
	public u8sLoggedInUser!: string;
	/** Own Contact Data */
	public ownContact!: ENetUC_Common_AsnContact.AsnContactV2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argument for the asnNegotiateServerConnectionV2 operation
 */
export class AsnNegotiateServerConnectionV2Argument {
	public constructor(that: AsnNegotiateServerConnectionV2Argument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionV2Argument {
		return new AsnNegotiateServerConnectionV2Argument({
			u8sMinSupportedInterfaceVersion: "",
			u8sMaxSupportedInterfaceVersion: "",
			u8sClientDeviceId: "",
			u8sClientVersion: "",
			eClientAppID: AsnClientAppID.eCLIENTAPPIDUNKNOWN,
			u8sClientDeviceName: "",
			iClientCapabilities: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sMinSupportedInterfaceVersion",
			"u8sMaxSupportedInterfaceVersion",
			"u8sClientDeviceId",
			"u8sClientVersion",
			"eClientAppID",
			"u8sClientDeviceName",
			"iClientCapabilities"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sConnectionGUID",
				"eAnonymousLogin"
			);
		}
		return p;
	}

	public static type = "AsnNegotiateServerConnectionV2Argument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNegotiateServerConnectionV2Argument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sMinSupportedInterfaceVersion" }),
				new asn1ts.Utf8String({ name: "u8sMaxSupportedInterfaceVersion" }),
				new asn1ts.Utf8String({ name: "u8sClientDeviceId" }),
				new asn1ts.Utf8String({ name: "u8sClientVersion" }),
				new asn1ts.Enumerated({ name: "eClientAppID" }),
				new asn1ts.Utf8String({ name: "u8sClientDeviceName" }),
				new asn1ts.Integer({ name: "iClientCapabilities" }),
				new asn1ts.Utf8String({ name: "u8sConnectionGUID", idBlock: { optionalID: 0 } }),
				AsnNegotiateServerConnectionAnonymousDataArgument.getASN1Schema({ name: "eAnonymousLogin", idBlock: { optionalID: 1 } }),
				new asn1ts.Extension()
			]
		});
	}

	/**
	 * the minimum supported protocol version of the client
	 * this is the oldest semver asn1 interface version the client is able to support
	 */
	public u8sMinSupportedInterfaceVersion!: string;
	/**
	 * the maximum supported protocol version of the client
	 * this is the newest semver asn1 interface version the client is able to support
	 */
	public u8sMaxSupportedInterfaceVersion!: string;
	/** A device id the client provides on his side */
	public u8sClientDeviceId!: string;
	/** The version of the client */
	public u8sClientVersion!: string;
	/** The application id of the client */
	public eClientAppID!: AsnClientAppID;
	/** A client name to show in the administrative view for this connection */
	public u8sClientDeviceName!: string;
	/** The different capabilites the client is able to handle */
	/** (see AsnNegotiateServerConnectionClientCapabilities) */
	public iClientCapabilities!: number;
	/** In case the client is reusing a connection this is the identifier of the former connection to the server */
	public u8sConnectionGUID?: string;
	/** The client wants an anonymous login */
	public eAnonymousLogin?: AsnNegotiateServerConnectionAnonymousDataArgument;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Result of the asnNegotiateServerConnectionV2 operation
 */
export class AsnNegotiateServerConnectionV2Result {
	public constructor(that: AsnNegotiateServerConnectionV2Result) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionV2Result {
		return new AsnNegotiateServerConnectionV2Result({
			eServerType: AsnNegotiateServerConnectionServerTypeV2.ePROCALLENTERPRISE,
			u8sServerInterfaceVersion: "",
			eAuthenticationMethod: AsnNegotiateServerConnectionAuthenticationMethod.ePASSWORD,
			sServerAuthentication: new Uint8Array(0),
			stServerTime: new Date(),
			u8sServerVersion: "",
			u8sConnectionGUID: "",
			u8sPresenceDomains: new ENetUC_Common.UTF8StringList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"eServerType",
			"u8sServerInterfaceVersion",
			"eAuthenticationMethod",
			"sServerAuthentication",
			"stServerTime",
			"u8sServerVersion",
			"u8sConnectionGUID",
			"u8sPresenceDomains"
		];
		if (bIncludeOptionals) {
			p.push(
				"iOEM",
				"u8sProductVersion",
				"bPresenceServicesDisabled",
				"bUserUserRightsDisabled",
				"eAnonymousDetails"
			);
		}
		return p;
	}

	public static type = "AsnNegotiateServerConnectionV2Result";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNegotiateServerConnectionV2Result",
			...params,
			value: [
				new asn1ts.Enumerated({ name: "eServerType" }),
				new asn1ts.Utf8String({ name: "u8sServerInterfaceVersion" }),
				new asn1ts.Enumerated({ name: "eAuthenticationMethod" }),
				new asn1ts.OctetString({ name: "sServerAuthentication" }),
				new asn1ts.Real({ name: "stServerTime" }),
				new asn1ts.Utf8String({ name: "u8sServerVersion" }),
				new asn1ts.Utf8String({ name: "u8sConnectionGUID" }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sPresenceDomains" }),
				new asn1ts.Integer({ name: "iOEM", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sProductVersion", idBlock: { optionalID: 1 } }),
				new asn1ts.Boolean({ name: "bPresenceServicesDisabled", idBlock: { optionalID: 2 } }),
				new asn1ts.Boolean({ name: "bUserUserRightsDisabled", idBlock: { optionalID: 3 } }),
				AsnNegotiateServerConnectionAnonymousDataResult.getASN1Schema({ name: "eAnonymousDetails", idBlock: { optionalID: 4 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** The type of server we are connecting to */
	public eServerType!: AsnNegotiateServerConnectionServerTypeV2;
	/** The asn1 interface version of the server */
	public u8sServerInterfaceVersion!: string;
	/** VerfÃ¼gbare Login Option */
	public eAuthenticationMethod!: AsnNegotiateServerConnectionAuthenticationMethod;
	/** A realm the server wants the client to encrypt data with */
	public sServerAuthentication!: Uint8Array;
	/** The server time so that the client is able to properly display times the server is providing */
	public stServerTime!: Date;
	/** Technical version of the server */
	public u8sServerVersion!: string;
	/** The server side connection id for this connection */
	public u8sConnectionGUID!: string;
	/** The list of presence domains the server is handling */
	public u8sPresenceDomains!: ENetUC_Common.UTF8StringList;
	/** The oem of the server (only set if not estos) */
	public iOEM?: number;
	/** An alternative product version (user shown product version), available if it does not match the technical server version */
	public u8sProductVersion?: string;
	/** presence services are disable on the server (only set if false) */
	public bPresenceServicesDisabled?: boolean;
	/** user user rights are disable on the server (only set if false) */
	public bUserUserRightsDisabled?: boolean;
	/** In case the user logged in anonymous this provides details for the anonymous user */
	public eAnonymousDetails?: AsnNegotiateServerConnectionAnonymousDataResult;
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnNegotiateServerConnectionV2ResultChoice {
	public constructor(that?: AsnNegotiateServerConnectionV2ResultChoice) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNegotiateServerConnectionV2ResultChoice {
		return new AsnNegotiateServerConnectionV2ResultChoice();
	}

	public static type = "AsnNegotiateServerConnectionV2ResultChoice";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnNegotiateServerConnectionV2ResultChoice",
			...params,
			value: [
				AsnNegotiateServerConnectionV2Result.getASN1Schema({ name: "result", idBlock: { optionalID: 0 } }),
				AsnNegotiateServerConnectionV2ServerBusy.getASN1Schema({ name: "busy", idBlock: { optionalID: 1 } }),
				AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion.getASN1Schema({ name: "incompatible", idBlock: { optionalID: 2 } })
			]
		});
	}

	public result?: AsnNegotiateServerConnectionV2Result;
	public busy?: AsnNegotiateServerConnectionV2ServerBusy;
	public incompatible?: AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * UCServer administrator login credentials used as optional by AsnGetUserTokenArgument
 */
export class AsnAdminLogin {
	public constructor(that: AsnAdminLogin) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAdminLogin {
		return new AsnAdminLogin({
			u8sAdminUsername: "",
			adminPassword: AsnAdminLoginChoice["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sAdminUsername",
			"adminPassword"
		];
		return p;
	}

	public static type = "AsnAdminLogin";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAdminLogin",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sAdminUsername" }),
				AsnAdminLoginChoice.getASN1Schema({ name: "adminPassword" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Adminstrator user name */
	public u8sAdminUsername!: string;
	/** Administrator password */
	public adminPassword!: AsnAdminLoginChoice;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnProfileAttributeList extends Array<AsnProfileAttribute> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnProfileAttribute.getASN1Schema()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argument for asnGetUserToken.
 */
export class AsnGetUserTokenArgument {
	public constructor(that?: AsnGetUserTokenArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetUserTokenArgument {
		return new AsnGetUserTokenArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"iType",
				"iTTL",
				"lstServiceType",
				"lstProfileAttributes",
				"adminLogin"
			);
		}
		return p;
	}

	public static type = "AsnGetUserTokenArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetUserTokenArgument",
			...params,
			value: [
				new asn1ts.Integer({ name: "iType", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iTTL", idBlock: { optionalID: 1 } }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "lstServiceType", idBlock: { optionalID: 2 } }),
				AsnProfileAttributeList.getASN1Schema({ name: "lstProfileAttributes", idBlock: { optionalID: 3 } }),
				AsnAdminLogin.getASN1Schema({ name: "adminLogin", idBlock: { optionalID: 4 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** Type of token (default eUserTokenExternal) */
	/** (see AsnUserTokenType) */
	public iType?: number;
	/** Desired Time to live in seconds (default 24 hours) */
	public iTTL?: number;
	/** List of Service Types e.g. FAQ, RANKING */
	public lstServiceType?: ENetUC_Common.UTF8StringList;
	/** List from profile values added as public claim as [Service_type]\/[Profile elementname] : [Profile elementvalue] */
	public lstProfileAttributes?: AsnProfileAttributeList;
	/** Admin login credentials to create token with admin rights */
	public adminLogin?: AsnAdminLogin;
}
