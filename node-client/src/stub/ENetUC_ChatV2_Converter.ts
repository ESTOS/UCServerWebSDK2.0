// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_ChatV2_Converter.ts
 * "UC-Server-Access-Protocol-ChatV2" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_ChatV2 from "./ENetUC_ChatV2";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Journal from "./ENetUC_Journal";
import * as ENetUC_BinaryTransfer from "./ENetUC_BinaryTransfer";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Journal_Converter from "./ENetUC_Journal_Converter";
import * as ENetUC_BinaryTransfer_Converter from "./ENetUC_BinaryTransfer_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_ChatV2_Converter";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSEncoderDecoderCode]
export class AsnChatParty_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatParty, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatParty & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatParty");

		const t = {} as ENetUC_ChatV2.AsnChatParty & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatParty";
		TSConverter.fillJSONParam(s, t, "u8sContactURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDisplayName", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iContactRights", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLastReadSequenceID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bReadNotifySupported", "boolean", errors, newContext, true);
		if (s.contactInformation) {
			const _contactInformation = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toJSON(s.contactInformation, errors, newContext, "contactInformation");
			if (_contactInformation)
				t.contactInformation = _contactInformation;
		}

		if (errors.validateResult(newContext, "AsnChatParty"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatParty | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatParty");

		let t: ENetUC_ChatV2.AsnChatParty | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatParty>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatParty["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDisplayName", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iContactRights", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLastReadSequenceID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bReadNotifySupported", "boolean", errors, newContext, true);
			const _contactinformation = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromJSON(s.contactInformation, errors, newContext, "contactInformation", true);
			if (_contactinformation)
				t.contactInformation = _contactinformation;
		}

		if (errors.validateResult(newContext, "AsnChatParty"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatParty | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatParty";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatParty");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDisplayName", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iContactRights", "number", errors, newContext);
		TSConverter.validateParam(s, "iLastReadSequenceID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "bReadNotifySupported", "boolean", errors, newContext, true);
		const _contactInformation = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toBER(s.contactInformation, errors, newContext, "contactInformation", 2);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactURI, name: "u8sContactURI" }));
			if (s.u8sDisplayName !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sDisplayName, name: "u8sDisplayName" }));
			t.push(new asn1ts.Integer({ value: s.iContactRights, name: "iContactRights" }));
			if (s.iLastReadSequenceID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iLastReadSequenceID, name: "iLastReadSequenceID", idBlock: { optionalID: 0 } }));
			if (s.bReadNotifySupported !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bReadNotifySupported, name: "bReadNotifySupported", idBlock: { optionalID: 1 } }));
			if (_contactInformation)
				t.push(_contactInformation);
		}

		if (errors.validateResult(newContext, "AsnChatParty"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatParty | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatParty");

		let t: ENetUC_ChatV2.AsnChatParty | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatParty.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatParty["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDisplayName", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iContactRights", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLastReadSequenceID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bReadNotifySupported", "Boolean", errors, newContext, true);
			t.contactInformation = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "contactInformation"), errors, newContext, "contactInformation", true);
		}

		if (errors.validateResult(newContext, "AsnChatParty"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSubscribeEventsArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSubscribeEventsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSubscribeEventsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSubscribeEventsArgument");

		const t = {} as ENetUC_ChatV2.AsnChatSubscribeEventsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSubscribeEventsArgument";
		TSConverter.fillJSONParam(s, t, "bReceiveChatEvents", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}
		TSConverter.fillJSONParam(s, t, "bSupportReactions", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSubscribeEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSubscribeEventsArgument");

		let t: ENetUC_ChatV2.AsnChatSubscribeEventsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSubscribeEventsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSubscribeEventsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bReceiveChatEvents", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
			TSConverter.fillJSONParam(s, t, "bSupportReactions", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSubscribeEventsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSubscribeEventsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSubscribeEventsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bReceiveChatEvents", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iMaxEvents", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", 3);
		TSConverter.validateParam(s, "bSupportReactions", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bReceiveChatEvents, name: "bReceiveChatEvents" }));
			if (s.iLastKnownGlobTransactionID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iLastKnownGlobTransactionID, name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 0 } }));
			if (s.iMaxEvents !== undefined)
				t.push(new asn1ts.Integer({ value: s.iMaxEvents, name: "iMaxEvents", idBlock: { optionalID: 1 } }));
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }));
			if (_optionalParams)
				t.push(_optionalParams);
			if (s.bSupportReactions !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bSupportReactions, name: "bSupportReactions", idBlock: { optionalID: 4 } }));
		}

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSubscribeEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSubscribeEventsArgument");

		let t: ENetUC_ChatV2.AsnChatSubscribeEventsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSubscribeEventsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSubscribeEventsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bReceiveChatEvents", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLastKnownGlobTransactionID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iMaxEvents", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
			TSConverter.fillASN1Param(s, t, "bSupportReactions", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSubscribeEventsResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSubscribeEventsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSubscribeEventsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSubscribeEventsResult");

		const t = {} as ENetUC_ChatV2.AsnChatSubscribeEventsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSubscribeEventsResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSubscribeEventsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSubscribeEventsResult");

		let t: ENetUC_ChatV2.AsnChatSubscribeEventsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSubscribeEventsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSubscribeEventsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSubscribeEventsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSubscribeEventsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSubscribeEventsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSubscribeEventsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSubscribeEventsResult");

		let t: ENetUC_ChatV2.AsnChatSubscribeEventsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSubscribeEventsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSubscribeEventsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSubscribeEventsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetDatabaseIDArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetDatabaseIDArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetDatabaseIDArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDatabaseIDArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetDatabaseIDArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetDatabaseIDArgument";

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDatabaseIDArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDatabaseIDArgument");

		let t: ENetUC_ChatV2.AsnChatGetDatabaseIDArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetDatabaseIDArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetDatabaseIDArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetDatabaseIDArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetDatabaseIDArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDatabaseIDArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDatabaseIDArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDatabaseIDArgument");

		let t: ENetUC_ChatV2.AsnChatGetDatabaseIDArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetDatabaseIDArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetDatabaseIDArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetDatabaseIDResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetDatabaseIDResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetDatabaseIDResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDatabaseIDResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetDatabaseIDResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetDatabaseIDResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDatabaseID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDatabaseIDResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDatabaseIDResult");

		let t: ENetUC_ChatV2.AsnChatGetDatabaseIDResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetDatabaseIDResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetDatabaseIDResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDatabaseID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetDatabaseIDResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetDatabaseIDResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDatabaseIDResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sDatabaseID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDatabaseID, name: "u8sDatabaseID" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDatabaseIDResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDatabaseIDResult");

		let t: ENetUC_ChatV2.AsnChatGetDatabaseIDResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetDatabaseIDResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetDatabaseIDResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDatabaseID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetDatabaseIDResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetDiffUpdateArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetDiffUpdateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetDiffUpdateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDiffUpdateArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetDiffUpdateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetDiffUpdateArgument";
		TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iMaxSequenceID", "number", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDiffUpdateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDiffUpdateArgument");

		let t: ENetUC_ChatV2.AsnChatGetDiffUpdateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetDiffUpdateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetDiffUpdateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iMaxSequenceID", "number", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetDiffUpdateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetDiffUpdateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDiffUpdateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iMaxEvents", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iMaxSequenceID", "number", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (s.iLastKnownGlobTransactionID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iLastKnownGlobTransactionID, name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 0 } }));
			if (s.iMaxEvents !== undefined)
				t.push(new asn1ts.Integer({ value: s.iMaxEvents, name: "iMaxEvents", idBlock: { optionalID: 1 } }));
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }));
			if (s.u8sConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID", idBlock: { optionalID: 3 } }));
			if (s.iMaxSequenceID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iMaxSequenceID, name: "iMaxSequenceID", idBlock: { optionalID: 4 } }));
		}

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDiffUpdateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDiffUpdateArgument");

		let t: ENetUC_ChatV2.AsnChatGetDiffUpdateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetDiffUpdateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetDiffUpdateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iLastKnownGlobTransactionID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iMaxEvents", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iMaxSequenceID", "Integer", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetDiffUpdateResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetDiffUpdateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetDiffUpdateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDiffUpdateResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetDiffUpdateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetDiffUpdateResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDiffUpdateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDiffUpdateResult");

		let t: ENetUC_ChatV2.AsnChatGetDiffUpdateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetDiffUpdateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetDiffUpdateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetDiffUpdateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetDiffUpdateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetDiffUpdateResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetDiffUpdateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetDiffUpdateResult");

		let t: ENetUC_ChatV2.AsnChatGetDiffUpdateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetDiffUpdateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetDiffUpdateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetDiffUpdateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationOverviewArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationOverviewArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationOverviewArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationOverviewArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationOverviewArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationOverviewArgument";
		TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iMaxConversations", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iNumLastMessages", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bAddUnread", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationOverviewArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationOverviewArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationOverviewArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationOverviewArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationOverviewArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iMaxConversations", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iNumLastMessages", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bAddUnread", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationOverviewArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationOverviewArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationOverviewArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iMaxConversations", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iNumLastMessages", "number", errors, newContext, true);
		TSConverter.validateParam(s, "bAddUnread", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (s.iLastKnownGlobTransactionID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iLastKnownGlobTransactionID, name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 0 } }));
			if (s.iMaxConversations !== undefined)
				t.push(new asn1ts.Integer({ value: s.iMaxConversations, name: "iMaxConversations", idBlock: { optionalID: 1 } }));
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }));
			if (s.iNumLastMessages !== undefined)
				t.push(new asn1ts.Integer({ value: s.iNumLastMessages, name: "iNumLastMessages", idBlock: { optionalID: 3 } }));
			if (s.bAddUnread !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bAddUnread, name: "bAddUnread", idBlock: { optionalID: 4 } }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationOverviewArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationOverviewArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationOverviewArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationOverviewArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationOverviewArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iLastKnownGlobTransactionID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iMaxConversations", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iNumLastMessages", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bAddUnread", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationOverviewResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationOverviewResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationOverviewResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationOverviewResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationOverviewResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationOverviewResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationOverviewResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationOverviewResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationOverviewResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationOverviewResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationOverviewResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationOverviewResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationOverviewResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationOverviewResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationOverviewResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationOverviewResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationOverviewResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationOverviewResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationOverviewResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationOverviewResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatTextMessageArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatTextMessageArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatTextMessageArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatTextMessageArgument");

		const t = {} as ENetUC_ChatV2.AsnChatTextMessageArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatTextMessageArgument";
		const _u8sRecipientURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sRecipientURIs, errors, newContext, "u8sRecipientURIs");
		if (_u8sRecipientURIs)
			t.u8sRecipientURIs = _u8sRecipientURIs;
		TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iReplyToSequenceID", "number", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatTextMessageArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatTextMessageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatTextMessageArgument");

		let t: ENetUC_ChatV2.AsnChatTextMessageArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatTextMessageArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatTextMessageArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8srecipienturis = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sRecipientURIs, errors, newContext, "u8sRecipientURIs", false);
			if (_u8srecipienturis)
				t.u8sRecipientURIs = _u8srecipienturis;
			TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iReplyToSequenceID", "number", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatTextMessageArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatTextMessageArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatTextMessageArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatTextMessageArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8sRecipientURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sRecipientURIs, errors, newContext, "u8sRecipientURIs");
		TSConverter.validateParam(s, "u8sMessage", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sConversationName", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iConversationType", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iReplyToSequenceID", "number", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_u8sRecipientURIs)
				t.push(_u8sRecipientURIs);
			t.push(new asn1ts.Utf8String({ value: s.u8sMessage, name: "u8sMessage" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			if (s.u8sConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID", idBlock: { optionalID: 0 } }));
			if (s.u8sConversationName !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationName, name: "u8sConversationName", idBlock: { optionalID: 1 } }));
			if (s.iConversationType !== undefined)
				t.push(new asn1ts.Integer({ value: s.iConversationType, name: "iConversationType", idBlock: { optionalID: 2 } }));
			if (s.iReplyToSequenceID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iReplyToSequenceID, name: "iReplyToSequenceID", idBlock: { optionalID: 3 } }));
		}

		if (errors.validateResult(newContext, "AsnChatTextMessageArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatTextMessageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatTextMessageArgument");

		let t: ENetUC_ChatV2.AsnChatTextMessageArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatTextMessageArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatTextMessageArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8srecipienturis = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sRecipientURIs"), errors, newContext, "u8sRecipientURIs");
			if (_u8srecipienturis)
				t.u8sRecipientURIs = _u8srecipienturis;
			TSConverter.fillASN1Param(s, t, "u8sMessage", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sConversationName", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iConversationType", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iReplyToSequenceID", "Integer", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatTextMessageArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatTextMessageResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatTextMessageResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatTextMessageResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatTextMessageResult");

		const t = {} as ENetUC_ChatV2.AsnChatTextMessageResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatTextMessageResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatTextMessageResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatTextMessageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatTextMessageResult");

		let t: ENetUC_ChatV2.AsnChatTextMessageResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatTextMessageResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatTextMessageResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatTextMessageResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatTextMessageResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatTextMessageResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatTextMessageResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
		}

		if (errors.validateResult(newContext, "AsnChatTextMessageResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatTextMessageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatTextMessageResult");

		let t: ENetUC_ChatV2.AsnChatTextMessageResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatTextMessageResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatTextMessageResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatTextMessageResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatBinaryMessageArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatBinaryMessageArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatBinaryMessageArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatBinaryMessageArgument");

		const t = {} as ENetUC_ChatV2.AsnChatBinaryMessageArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatBinaryMessageArgument";
		const _u8sRecipientURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sRecipientURIs, errors, newContext, "u8sRecipientURIs");
		if (_u8sRecipientURIs)
			t.u8sRecipientURIs = _u8sRecipientURIs;
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iReplyToSequenceID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatBinaryMessageArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatBinaryMessageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatBinaryMessageArgument");

		let t: ENetUC_ChatV2.AsnChatBinaryMessageArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatBinaryMessageArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatBinaryMessageArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8srecipienturis = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sRecipientURIs, errors, newContext, "u8sRecipientURIs", false);
			if (_u8srecipienturis)
				t.u8sRecipientURIs = _u8srecipienturis;
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iReplyToSequenceID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatBinaryMessageArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatBinaryMessageArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatBinaryMessageArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatBinaryMessageArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8sRecipientURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sRecipientURIs, errors, newContext, "u8sRecipientURIs");
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sMessage", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iConversationType", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iReplyToSequenceID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sConversationName", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_u8sRecipientURIs)
				t.push(_u8sRecipientURIs);
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			if (s.u8sConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID", idBlock: { optionalID: 0 } }));
			if (s.u8sMessage !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sMessage, name: "u8sMessage", idBlock: { optionalID: 1 } }));
			if (s.iConversationType !== undefined)
				t.push(new asn1ts.Integer({ value: s.iConversationType, name: "iConversationType", idBlock: { optionalID: 2 } }));
			if (s.iReplyToSequenceID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iReplyToSequenceID, name: "iReplyToSequenceID", idBlock: { optionalID: 3 } }));
			if (s.u8sConversationName !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationName, name: "u8sConversationName", idBlock: { optionalID: 5 } }));
		}

		if (errors.validateResult(newContext, "AsnChatBinaryMessageArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatBinaryMessageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatBinaryMessageArgument");

		let t: ENetUC_ChatV2.AsnChatBinaryMessageArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatBinaryMessageArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatBinaryMessageArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8srecipienturis = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sRecipientURIs"), errors, newContext, "u8sRecipientURIs");
			if (_u8srecipienturis)
				t.u8sRecipientURIs = _u8srecipienturis;
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sMessage", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iConversationType", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iReplyToSequenceID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sConversationName", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatBinaryMessageArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatBinaryMessageResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatBinaryMessageResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatBinaryMessageResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatBinaryMessageResult");

		const t = {} as ENetUC_ChatV2.AsnChatBinaryMessageResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatBinaryMessageResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatBinaryMessageResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatBinaryMessageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatBinaryMessageResult");

		let t: ENetUC_ChatV2.AsnChatBinaryMessageResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatBinaryMessageResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatBinaryMessageResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatBinaryMessageResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatBinaryMessageResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatBinaryMessageResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatBinaryMessageResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
		}

		if (errors.validateResult(newContext, "AsnChatBinaryMessageResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatBinaryMessageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatBinaryMessageResult");

		let t: ENetUC_ChatV2.AsnChatBinaryMessageResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatBinaryMessageResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatBinaryMessageResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatBinaryMessageResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnConversationIDChoice_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnConversationIDChoice, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnConversationIDChoice & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnConversationIDChoice");

		const t = {} as ENetUC_ChatV2.AsnConversationIDChoice & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnConversationIDChoice";
		if (s.u8sConversationID != null)
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		else if (s.u8sPartnerURI != null)
			TSConverter.fillJSONParam(s, t, "u8sPartnerURI", "string", errors, newContext);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnConversationIDChoice"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnConversationIDChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnConversationIDChoice");

		let t: ENetUC_ChatV2.AsnConversationIDChoice | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnConversationIDChoice>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnConversationIDChoice["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.u8sConversationID !== undefined) {
				if (TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext))
					t.u8sConversationID = s.u8sConversationID;
			} else if (s.u8sPartnerURI !== undefined) {
				if (TSConverter.validateParam(s, "u8sPartnerURI", "string", errors, newContext))
					t.u8sPartnerURI = s.u8sPartnerURI;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnConversationIDChoice"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnConversationIDChoice | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnConversationIDChoice";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnConversationIDChoice");

		// [Print_BER_EncoderChoiceDefCode]
		if (TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true))
			t = new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID", idBlock: { optionalID: 0 } });
		else if (TSConverter.validateParam(s, "u8sPartnerURI", "string", errors, newContext, true))
			t = new asn1ts.Utf8String({ value: s.u8sPartnerURI, name: "u8sPartnerURI", idBlock: { optionalID: 1 } });
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnConversationIDChoice"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnConversationIDChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnConversationIDChoice");

		let t: ENetUC_ChatV2.AsnConversationIDChoice | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnConversationIDChoice.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnConversationIDChoice["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "u8sConversationID" && asn1ts.Utf8String.typeGuard(s)) {
				const _u8sConversationID = s.getValue();
				if (TSConverter.validateParamType(_u8sConversationID, "u8sConversationID", "string", errors, newContext, false))
					t.u8sConversationID = _u8sConversationID;
			} else if (s.choiceName === "u8sPartnerURI" && asn1ts.Utf8String.typeGuard(s)) {
				const _u8sPartnerURI = s.getValue();
				if (TSConverter.validateParamType(_u8sPartnerURI, "u8sPartnerURI", "string", errors, newContext, false))
					t.u8sPartnerURI = _u8sPartnerURI;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnConversationIDChoice"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatForwardMessageResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatForwardMessageResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatForwardMessageResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardMessageResult");

		const t = {} as ENetUC_ChatV2.AsnChatForwardMessageResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatForwardMessageResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatForwardMessageResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardMessageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardMessageResult");

		let t: ENetUC_ChatV2.AsnChatForwardMessageResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatForwardMessageResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatForwardMessageResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatForwardMessageResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatForwardMessageResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatForwardMessageResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardMessageResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatForwardMessageResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardMessageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardMessageResult");

		let t: ENetUC_ChatV2.AsnChatForwardMessageResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatForwardMessageResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatForwardMessageResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatForwardMessageResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatUserlistModifyArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatUserlistModifyArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatUserlistModifyArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUserlistModifyArgument");

		const t = {} as ENetUC_ChatV2.AsnChatUserlistModifyArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatUserlistModifyArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iChatUserlistModify", "number", errors, newContext);
		const _u8sUserURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sUserURIs, errors, newContext, "u8sUserURIs");
		if (_u8sUserURIs)
			t.u8sUserURIs = _u8sUserURIs;
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatUserlistModifyArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUserlistModifyArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUserlistModifyArgument");

		let t: ENetUC_ChatV2.AsnChatUserlistModifyArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatUserlistModifyArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatUserlistModifyArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iChatUserlistModify", "number", errors, newContext, false);
			const _u8suseruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sUserURIs, errors, newContext, "u8sUserURIs", false);
			if (_u8suseruris)
				t.u8sUserURIs = _u8suseruris;
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatUserlistModifyArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatUserlistModifyArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatUserlistModifyArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUserlistModifyArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iChatUserlistModify", "number", errors, newContext);
		const _u8sUserURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sUserURIs, errors, newContext, "u8sUserURIs");
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Integer({ value: s.iChatUserlistModify, name: "iChatUserlistModify" }));
			if (_u8sUserURIs)
				t.push(_u8sUserURIs);
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnChatUserlistModifyArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUserlistModifyArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUserlistModifyArgument");

		let t: ENetUC_ChatV2.AsnChatUserlistModifyArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatUserlistModifyArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatUserlistModifyArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iChatUserlistModify", "Integer", errors, newContext);
			const _u8suseruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sUserURIs"), errors, newContext, "u8sUserURIs");
			if (_u8suseruris)
				t.u8sUserURIs = _u8suseruris;
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatUserlistModifyArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatUserlistModifyResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatUserlistModifyResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatUserlistModifyResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUserlistModifyResult");

		const t = {} as ENetUC_ChatV2.AsnChatUserlistModifyResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatUserlistModifyResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatUserlistModifyResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUserlistModifyResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUserlistModifyResult");

		let t: ENetUC_ChatV2.AsnChatUserlistModifyResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatUserlistModifyResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatUserlistModifyResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatUserlistModifyResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatUserlistModifyResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatUserlistModifyResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUserlistModifyResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			if (s.u8sConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
		}

		if (errors.validateResult(newContext, "AsnChatUserlistModifyResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUserlistModifyResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUserlistModifyResult");

		let t: ENetUC_ChatV2.AsnChatUserlistModifyResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatUserlistModifyResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatUserlistModifyResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatUserlistModifyResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatFindEventsArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatFindEventsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatFindEventsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatFindEventsArgument");

		const t = {} as ENetUC_ChatV2.AsnChatFindEventsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatFindEventsArgument";
		TSConverter.fillJSONParam(s, t, "u8sSearchString", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOffset", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatFindEventsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatFindEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatFindEventsArgument");

		let t: ENetUC_ChatV2.AsnChatFindEventsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatFindEventsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatFindEventsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sSearchString", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOffset", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatFindEventsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatFindEventsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatFindEventsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatFindEventsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sSearchString", "string", errors, newContext);
		TSConverter.validateParam(s, "iMaxEvents", "number", errors, newContext);
		TSConverter.validateParam(s, "iOffset", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sSearchString, name: "u8sSearchString" }));
			t.push(new asn1ts.Integer({ value: s.iMaxEvents, name: "iMaxEvents" }));
			if (s.iOffset !== undefined)
				t.push(new asn1ts.Integer({ value: s.iOffset, name: "iOffset" }));
			if (s.u8sConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
		}

		if (errors.validateResult(newContext, "AsnChatFindEventsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatFindEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatFindEventsArgument");

		let t: ENetUC_ChatV2.AsnChatFindEventsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatFindEventsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatFindEventsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sSearchString", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxEvents", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOffset", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatFindEventsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetEventsRangeResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetEventsRangeResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetEventsRangeResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetEventsRangeResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetEventsRangeResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetEventsRangeResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetEventsRangeResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetEventsRangeResult");

		let t: ENetUC_ChatV2.AsnChatGetEventsRangeResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetEventsRangeResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetEventsRangeResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetEventsRangeResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetEventsRangeResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetEventsRangeResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetEventsRangeResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetEventsRangeResult");

		let t: ENetUC_ChatV2.AsnChatGetEventsRangeResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetEventsRangeResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetEventsRangeResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetBinaryMessageEventsResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetBinaryMessageEventsResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetBinaryMessageEventsResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetBinaryMessageEventsResult");

		let t: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetBinaryMessageEventsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetBinaryMessageEventsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetBinaryMessageEventsResult");

		let t: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetBinaryMessageEventsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSequenceIDSet_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSequenceIDSet, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSequenceIDSet & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSequenceIDSet");

		const t = {} as ENetUC_ChatV2.AsnChatSequenceIDSet & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSequenceIDSet";
		if (s.asnSequenceIDs != null) {
			const _asnSequenceIDs = ENetUC_Common_Converter.SEQInteger_Converter.toJSON(s.asnSequenceIDs, errors, newContext, "asnSequenceIDs");
			if (_asnSequenceIDs)
				t.asnSequenceIDs = _asnSequenceIDs;
		} else if (s.iLastSequenceID != null)
			TSConverter.fillJSONParam(s, t, "iLastSequenceID", "number", errors, newContext);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnChatSequenceIDSet"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSequenceIDSet | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSequenceIDSet");

		let t: ENetUC_ChatV2.AsnChatSequenceIDSet | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSequenceIDSet>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSequenceIDSet["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.asnSequenceIDs !== undefined) {
				if (TSConverter.validateParam(s, "asnSequenceIDs", "number", errors, newContext))
					t.asnSequenceIDs = s.asnSequenceIDs;
			} else if (s.iLastSequenceID !== undefined) {
				if (TSConverter.validateParam(s, "iLastSequenceID", "number", errors, newContext))
					t.iLastSequenceID = s.iLastSequenceID;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnChatSequenceIDSet"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSequenceIDSet | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnChatSequenceIDSet";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSequenceIDSet");

		// [Print_BER_EncoderChoiceDefCode]
		if (s.asnSequenceIDs)
			t = ENetUC_Common_Converter.SEQInteger_Converter.toBER(s.asnSequenceIDs, errors, newContext, "asnSequenceIDs");
		else if (TSConverter.validateParam(s, "iLastSequenceID", "number", errors, newContext, true))
			t = new asn1ts.Integer({ value: s.iLastSequenceID, name: "iLastSequenceID" });
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnChatSequenceIDSet"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSequenceIDSet | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSequenceIDSet");

		let t: ENetUC_ChatV2.AsnChatSequenceIDSet | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSequenceIDSet.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSequenceIDSet["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "asnSequenceIDs" && asn1ts.Sequence.typeGuard(s))
				t.asnSequenceIDs = ENetUC_Common_Converter.SEQInteger_Converter.fromBER(s, undefined, newContext, "asnsequenceids", false);
			else if (s.choiceName === "iLastSequenceID" && asn1ts.Integer.typeGuard(s)) {
				const _iLastSequenceID = s.getValue();
				if (TSConverter.validateParamType(_iLastSequenceID, "iLastSequenceID", "number", errors, newContext, false))
					t.iLastSequenceID = _iLastSequenceID;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnChatSequenceIDSet"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetMessagesStatusResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetMessagesStatusResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetMessagesStatusResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetMessagesStatusResult");

		const t = {} as ENetUC_ChatV2.AsnChatSetMessagesStatusResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetMessagesStatusResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetMessagesStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetMessagesStatusResult");

		let t: ENetUC_ChatV2.AsnChatSetMessagesStatusResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetMessagesStatusResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetMessagesStatusResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetMessagesStatusResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetMessagesStatusResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetMessagesStatusResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetMessagesStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetMessagesStatusResult");

		let t: ENetUC_ChatV2.AsnChatSetMessagesStatusResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetMessagesStatusResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetMessagesStatusResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationsArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationsArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationsArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sContactURI", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bStaticConversations", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetConversationsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationsArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sContactURI", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bStaticConversations", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sContactURI", "string", errors, newContext, true);
		TSConverter.validateParam(s, "bStaticConversations", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (s.u8sConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID", idBlock: { optionalID: 0 } }));
			if (s.u8sContactURI !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sContactURI, name: "u8sContactURI", idBlock: { optionalID: 1 } }));
			if (s.bStaticConversations !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bStaticConversations, name: "bStaticConversations", idBlock: { optionalID: 2 } }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationsArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sContactURI", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bStaticConversations", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationIDArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationIDArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationIDArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationIDArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationIDArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationIDArgument";
		TSConverter.fillJSONParam(s, t, "u8sContactURI", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetConversationIDArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationIDArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationIDArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationIDArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationIDArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationIDArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactURI", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationIDArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationIDArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationIDArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationIDArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactURI", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactURI, name: "u8sContactURI" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationIDArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationIDArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationIDArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationIDArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationIDArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationIDArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactURI", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationIDArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationIDResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationIDResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationIDResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationIDResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationIDResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationIDResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatGetConversationIDResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationIDResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationIDResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationIDResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationIDResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationIDResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationIDResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationIDResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationIDResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationIDResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationIDResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationIDResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationIDResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationIDResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationIDResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationIDResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationIDResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatForwardArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatForwardArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatForwardArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardArgument");

		const t = {} as ENetUC_ChatV2.AsnChatForwardArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatForwardArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sForwardURI", "string", errors, newContext);
		const _u8sForwardToURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sForwardToURIs, errors, newContext, "u8sForwardToURIs");
		if (_u8sForwardToURIs)
			t.u8sForwardToURIs = _u8sForwardToURIs;
		TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatForwardArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardArgument");

		let t: ENetUC_ChatV2.AsnChatForwardArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatForwardArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatForwardArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sForwardURI", "string", errors, newContext, false);
			const _u8sforwardtouris = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sForwardToURIs, errors, newContext, "u8sForwardToURIs", false);
			if (_u8sforwardtouris)
				t.u8sForwardToURIs = _u8sforwardtouris;
			TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatForwardArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatForwardArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatForwardArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sForwardURI", "string", errors, newContext);
		const _u8sForwardToURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sForwardToURIs, errors, newContext, "u8sForwardToURIs");
		TSConverter.validateParam(s, "u8sMessage", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sForwardURI, name: "u8sForwardURI" }));
			if (_u8sForwardToURIs)
				t.push(_u8sForwardToURIs);
			t.push(new asn1ts.Utf8String({ value: s.u8sMessage, name: "u8sMessage" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnChatForwardArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardArgument");

		let t: ENetUC_ChatV2.AsnChatForwardArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatForwardArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatForwardArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sForwardURI", "Utf8String", errors, newContext);
			const _u8sforwardtouris = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sForwardToURIs"), errors, newContext, "u8sForwardToURIs");
			if (_u8sforwardtouris)
				t.u8sForwardToURIs = _u8sforwardtouris;
			TSConverter.fillASN1Param(s, t, "u8sMessage", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatForwardArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatForwardResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatForwardResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatForwardResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardResult");

		const t = {} as ENetUC_ChatV2.AsnChatForwardResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatForwardResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatForwardResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardResult");

		let t: ENetUC_ChatV2.AsnChatForwardResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatForwardResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatForwardResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatForwardResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatForwardResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatForwardResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
		}

		if (errors.validateResult(newContext, "AsnChatForwardResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardResult");

		let t: ENetUC_ChatV2.AsnChatForwardResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatForwardResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatForwardResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatForwardResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatIsGlobalDisabledArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatIsGlobalDisabledArgument");

		const t = {} as ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatIsGlobalDisabledArgument";

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatIsGlobalDisabledArgument");

		let t: ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatIsGlobalDisabledArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatIsGlobalDisabledArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatIsGlobalDisabledArgument");

		let t: ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatIsGlobalDisabledArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatIsGlobalDisabledResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatIsGlobalDisabledResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatIsGlobalDisabledResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatIsGlobalDisabledResult");

		const t = {} as ENetUC_ChatV2.AsnChatIsGlobalDisabledResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatIsGlobalDisabledResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDisabled", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatIsGlobalDisabledResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatIsGlobalDisabledResult");

		let t: ENetUC_ChatV2.AsnChatIsGlobalDisabledResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatIsGlobalDisabledResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatIsGlobalDisabledResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDisabled", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatIsGlobalDisabledResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatIsGlobalDisabledResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatIsGlobalDisabledResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "bDisabled", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Boolean({ value: s.bDisabled, name: "bDisabled" }));
		}

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatIsGlobalDisabledResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatIsGlobalDisabledResult");

		let t: ENetUC_ChatV2.AsnChatIsGlobalDisabledResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatIsGlobalDisabledResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatIsGlobalDisabledResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDisabled", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatIsGlobalDisabledResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatWatchConversationArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatWatchConversationArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatWatchConversationArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatWatchConversationArgument");

		const t = {} as ENetUC_ChatV2.AsnChatWatchConversationArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatWatchConversationArgument";
		TSConverter.fillJSONParam(s, t, "iWatchMode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatWatchConversationArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatWatchConversationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatWatchConversationArgument");

		let t: ENetUC_ChatV2.AsnChatWatchConversationArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatWatchConversationArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatWatchConversationArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iWatchMode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iMaxEvents", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatWatchConversationArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatWatchConversationArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatWatchConversationArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatWatchConversationArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iWatchMode", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iMaxEvents", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iWatchMode, name: "iWatchMode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			if (s.iConvSequenceID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID", idBlock: { optionalID: 0 } }));
			if (s.iMaxEvents !== undefined)
				t.push(new asn1ts.Integer({ value: s.iMaxEvents, name: "iMaxEvents", idBlock: { optionalID: 1 } }));
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }));
		}

		if (errors.validateResult(newContext, "AsnChatWatchConversationArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatWatchConversationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatWatchConversationArgument");

		let t: ENetUC_ChatV2.AsnChatWatchConversationArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatWatchConversationArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatWatchConversationArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iWatchMode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iMaxEvents", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatWatchConversationArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatWatchConversationResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatWatchConversationResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatWatchConversationResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatWatchConversationResult");

		const t = {} as ENetUC_ChatV2.AsnChatWatchConversationResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatWatchConversationResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatWatchConversationResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatWatchConversationResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatWatchConversationResult");

		let t: ENetUC_ChatV2.AsnChatWatchConversationResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatWatchConversationResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatWatchConversationResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatWatchConversationResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatWatchConversationResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatWatchConversationResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatWatchConversationResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatWatchConversationResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatWatchConversationResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatWatchConversationResult");

		let t: ENetUC_ChatV2.AsnChatWatchConversationResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatWatchConversationResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatWatchConversationResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatWatchConversationResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetUserlistArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetUserlistArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetUserlistArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetUserlistArgument");

		const t = {} as ENetUC_ChatV2.AsnChatSetUserlistArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetUserlistArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		const _u8sUserURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sUserURIs, errors, newContext, "u8sUserURIs");
		if (_u8sUserURIs)
			t.u8sUserURIs = _u8sUserURIs;
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSetUserlistArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetUserlistArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetUserlistArgument");

		let t: ENetUC_ChatV2.AsnChatSetUserlistArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetUserlistArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetUserlistArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			const _u8suseruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sUserURIs, errors, newContext, "u8sUserURIs", false);
			if (_u8suseruris)
				t.u8sUserURIs = _u8suseruris;
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSetUserlistArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetUserlistArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetUserlistArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetUserlistArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		const _u8sUserURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sUserURIs, errors, newContext, "u8sUserURIs");
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			if (_u8sUserURIs)
				t.push(_u8sUserURIs);
			t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnChatSetUserlistArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetUserlistArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetUserlistArgument");

		let t: ENetUC_ChatV2.AsnChatSetUserlistArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetUserlistArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetUserlistArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			const _u8suseruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sUserURIs"), errors, newContext, "u8sUserURIs");
			if (_u8suseruris)
				t.u8sUserURIs = _u8suseruris;
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSetUserlistArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetUserlistResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetUserlistResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetUserlistResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetUserlistResult");

		const t = {} as ENetUC_ChatV2.AsnChatSetUserlistResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetUserlistResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSetUserlistResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetUserlistResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetUserlistResult");

		let t: ENetUC_ChatV2.AsnChatSetUserlistResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetUserlistResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetUserlistResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSetUserlistResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetUserlistResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetUserlistResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetUserlistResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
		}

		if (errors.validateResult(newContext, "AsnChatSetUserlistResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetUserlistResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetUserlistResult");

		let t: ENetUC_ChatV2.AsnChatSetUserlistResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetUserlistResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetUserlistResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSetUserlistResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatUserStatusArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatUserStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatUserStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUserStatusArgument");

		const t = {} as ENetUC_ChatV2.AsnChatUserStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatUserStatusArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUserTyping", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatUserStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUserStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUserStatusArgument");

		let t: ENetUC_ChatV2.AsnChatUserStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatUserStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatUserStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUserTyping", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatUserStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatUserStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatUserStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUserStatusArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSenderURI", "string", errors, newContext);
		TSConverter.validateParam(s, "bUserTyping", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSenderURI, name: "u8sSenderURI" }));
			if (s.bUserTyping !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bUserTyping, name: "bUserTyping", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnChatUserStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUserStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUserStatusArgument");

		let t: ENetUC_ChatV2.AsnChatUserStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatUserStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatUserStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSenderURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUserTyping", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatUserStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatDatabaseIDChangedArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatDatabaseIDChangedArgument");

		const t = {} as ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatDatabaseIDChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sDatabaseID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatDatabaseIDChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatDatabaseIDChangedArgument");

		let t: ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sDatabaseID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatDatabaseIDChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatDatabaseIDChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatDatabaseIDChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sDatabaseID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sDatabaseID, name: "u8sDatabaseID" }));
		}

		if (errors.validateResult(newContext, "AsnChatDatabaseIDChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatDatabaseIDChangedArgument");

		let t: ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatDatabaseIDChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sDatabaseID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatDatabaseIDChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatDatabaseMaintenanceArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatDatabaseMaintenanceArgument");

		const t = {} as ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatDatabaseMaintenanceArgument";
		TSConverter.fillJSONParam(s, t, "iDeletedToSequenceID", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatDatabaseMaintenanceArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatDatabaseMaintenanceArgument");

		let t: ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iDeletedToSequenceID", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatDatabaseMaintenanceArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatDatabaseMaintenanceArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatDatabaseMaintenanceArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iDeletedToSequenceID", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iDeletedToSequenceID, name: "iDeletedToSequenceID" }));
		}

		if (errors.validateResult(newContext, "AsnChatDatabaseMaintenanceArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatDatabaseMaintenanceArgument");

		let t: ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatDatabaseMaintenanceArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iDeletedToSequenceID", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatDatabaseMaintenanceArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatMuteConversationArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatMuteConversationArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatMuteConversationArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatMuteConversationArgument");

		const t = {} as ENetUC_ChatV2.AsnChatMuteConversationArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatMuteConversationArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "asnMutedUntilTime", "Date", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatMuteConversationArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatMuteConversationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatMuteConversationArgument");

		let t: ENetUC_ChatV2.AsnChatMuteConversationArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatMuteConversationArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatMuteConversationArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "asnMutedUntilTime", "string", errors, newContext, true) && s.asnMutedUntilTime)
				t.asnMutedUntilTime = new Date(s.asnMutedUntilTime);
		}

		if (errors.validateResult(newContext, "AsnChatMuteConversationArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatMuteConversationArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatMuteConversationArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatMuteConversationArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "asnMutedUntilTime", "Date", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			if (s.asnMutedUntilTime !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.asnMutedUntilTime), name: "asnMutedUntilTime", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnChatMuteConversationArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatMuteConversationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatMuteConversationArgument");

		let t: ENetUC_ChatV2.AsnChatMuteConversationArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatMuteConversationArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatMuteConversationArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "asnMutedUntilTime", "AsnSystemTime", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatMuteConversationArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatMuteConversationResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatMuteConversationResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatMuteConversationResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatMuteConversationResult");

		const t = {} as ENetUC_ChatV2.AsnChatMuteConversationResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatMuteConversationResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatMuteConversationResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatMuteConversationResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatMuteConversationResult");

		let t: ENetUC_ChatV2.AsnChatMuteConversationResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatMuteConversationResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatMuteConversationResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatMuteConversationResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatMuteConversationResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatMuteConversationResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatMuteConversationResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatMuteConversationResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatMuteConversationResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatMuteConversationResult");

		let t: ENetUC_ChatV2.AsnChatMuteConversationResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatMuteConversationResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatMuteConversationResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatMuteConversationResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatUnmuteConversationArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatUnmuteConversationArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatUnmuteConversationArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUnmuteConversationArgument");

		const t = {} as ENetUC_ChatV2.AsnChatUnmuteConversationArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatUnmuteConversationArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUnmuteConversationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUnmuteConversationArgument");

		let t: ENetUC_ChatV2.AsnChatUnmuteConversationArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatUnmuteConversationArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatUnmuteConversationArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatUnmuteConversationArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatUnmuteConversationArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUnmuteConversationArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUnmuteConversationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUnmuteConversationArgument");

		let t: ENetUC_ChatV2.AsnChatUnmuteConversationArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatUnmuteConversationArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatUnmuteConversationArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatUnmuteConversationResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatUnmuteConversationResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatUnmuteConversationResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUnmuteConversationResult");

		const t = {} as ENetUC_ChatV2.AsnChatUnmuteConversationResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatUnmuteConversationResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUnmuteConversationResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUnmuteConversationResult");

		let t: ENetUC_ChatV2.AsnChatUnmuteConversationResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatUnmuteConversationResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatUnmuteConversationResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatUnmuteConversationResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatUnmuteConversationResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatUnmuteConversationResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatUnmuteConversationResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatUnmuteConversationResult");

		let t: ENetUC_ChatV2.AsnChatUnmuteConversationResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatUnmuteConversationResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatUnmuteConversationResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatUnmuteConversationResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatMuteStatusChangedArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatMuteStatusChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatMuteStatusChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatMuteStatusChangedArgument");

		const t = {} as ENetUC_ChatV2.AsnChatMuteStatusChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatMuteStatusChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMuted", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "asnMutedUntilTime", "Date", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatMuteStatusChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatMuteStatusChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatMuteStatusChangedArgument");

		let t: ENetUC_ChatV2.AsnChatMuteStatusChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatMuteStatusChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatMuteStatusChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMuted", "boolean", errors, newContext, false);
			if (TSConverter.validateParam(s, "asnMutedUntilTime", "string", errors, newContext, true) && s.asnMutedUntilTime)
				t.asnMutedUntilTime = new Date(s.asnMutedUntilTime);
		}

		if (errors.validateResult(newContext, "AsnChatMuteStatusChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatMuteStatusChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatMuteStatusChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatMuteStatusChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSenderURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "bMuted", "boolean", errors, newContext);
		TSConverter.validateParam(s, "asnMutedUntilTime", "Date", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSenderURI, name: "u8sSenderURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			t.push(new asn1ts.Boolean({ value: s.bMuted, name: "bMuted" }));
			if (s.asnMutedUntilTime !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.asnMutedUntilTime), name: "asnMutedUntilTime" }));
		}

		if (errors.validateResult(newContext, "AsnChatMuteStatusChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatMuteStatusChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatMuteStatusChangedArgument");

		let t: ENetUC_ChatV2.AsnChatMuteStatusChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatMuteStatusChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatMuteStatusChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSenderURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMuted", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "asnMutedUntilTime", "AsnSystemTime", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatMuteStatusChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetConversationAvatarArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetConversationAvatarArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetConversationAvatarArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetConversationAvatarArgument");

		const t = {} as ENetUC_ChatV2.AsnChatSetConversationAvatarArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetConversationAvatarArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sImageData", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetConversationAvatarArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetConversationAvatarArgument");

		let t: ENetUC_ChatV2.AsnChatSetConversationAvatarArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetConversationAvatarArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetConversationAvatarArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sImageData", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetConversationAvatarArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetConversationAvatarArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetConversationAvatarArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sImageData", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sImageData, name: "u8sImageData" }));
		}

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetConversationAvatarArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetConversationAvatarArgument");

		let t: ENetUC_ChatV2.AsnChatSetConversationAvatarArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetConversationAvatarArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetConversationAvatarArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sImageData", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetConversationAvatarResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetConversationAvatarResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetConversationAvatarResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetConversationAvatarResult");

		const t = {} as ENetUC_ChatV2.AsnChatSetConversationAvatarResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetConversationAvatarResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetConversationAvatarResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetConversationAvatarResult");

		let t: ENetUC_ChatV2.AsnChatSetConversationAvatarResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetConversationAvatarResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetConversationAvatarResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetConversationAvatarResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetConversationAvatarResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetConversationAvatarResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetConversationAvatarResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetConversationAvatarResult");

		let t: ENetUC_ChatV2.AsnChatSetConversationAvatarResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetConversationAvatarResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetConversationAvatarResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSetConversationAvatarResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationAvatarArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationAvatarArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationAvatarArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationAvatarArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationAvatarArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationAvatarArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sKnownHash", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationAvatarArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationAvatarArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationAvatarArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationAvatarArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationAvatarArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sKnownHash", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationAvatarArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationAvatarArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationAvatarArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sKnownHash", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			if (s.u8sKnownHash !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sKnownHash, name: "u8sKnownHash" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationAvatarArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationAvatarArgument");

		let t: ENetUC_ChatV2.AsnChatGetConversationAvatarArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationAvatarArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationAvatarArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sKnownHash", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationAvatarResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationAvatarResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationAvatarResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationAvatarResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationAvatarResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationAvatarResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iImageResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sImageHash", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sImageData", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationAvatarResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationAvatarResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationAvatarResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationAvatarResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationAvatarResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iImageResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sImageHash", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sImageData", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationAvatarResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationAvatarResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationAvatarResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iImageResult", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sImageHash", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sImageData", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iImageResult, name: "iImageResult" }));
			if (s.u8sImageHash !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sImageHash, name: "u8sImageHash", idBlock: { optionalID: 0 } }));
			if (s.u8sImageData !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sImageData, name: "u8sImageData", idBlock: { optionalID: 1 } }));
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationAvatarResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationAvatarResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationAvatarResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationAvatarResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationAvatarResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iImageResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sImageHash", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sImageData", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationAvatarResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatConversationAvatarChangedArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatConversationAvatarChangedArgument");

		const t = {} as ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatConversationAvatarChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sImageHash", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatConversationAvatarChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatConversationAvatarChangedArgument");

		let t: ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sImageHash", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatConversationAvatarChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatConversationAvatarChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatConversationAvatarChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSenderURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sImageHash", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSenderURI, name: "u8sSenderURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sImageHash, name: "u8sImageHash" }));
		}

		if (errors.validateResult(newContext, "AsnChatConversationAvatarChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatConversationAvatarChangedArgument");

		let t: ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatConversationAvatarChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSenderURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sImageHash", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatConversationAvatarChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatReactionsEmoji_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatReactionsEmoji, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatReactionsEmoji & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsEmoji");

		const t = {} as ENetUC_ChatV2.AsnChatReactionsEmoji & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatReactionsEmoji";
		TSConverter.fillJSONParam(s, t, "u8sEmoji", "string", errors, newContext);
		const _u8sUsers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sUsers, errors, newContext, "u8sUsers");
		if (_u8sUsers)
			t.u8sUsers = _u8sUsers;

		if (errors.validateResult(newContext, "AsnChatReactionsEmoji"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsEmoji | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsEmoji");

		let t: ENetUC_ChatV2.AsnChatReactionsEmoji | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatReactionsEmoji>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatReactionsEmoji["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sEmoji", "string", errors, newContext, false);
			const _u8susers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sUsers, errors, newContext, "u8sUsers", false);
			if (_u8susers)
				t.u8sUsers = _u8susers;
		}

		if (errors.validateResult(newContext, "AsnChatReactionsEmoji"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatReactionsEmoji | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatReactionsEmoji";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsEmoji");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sEmoji", "string", errors, newContext);
		const _u8sUsers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sUsers, errors, newContext, "u8sUsers");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sEmoji, name: "u8sEmoji" }));
			if (_u8sUsers)
				t.push(_u8sUsers);
		}

		if (errors.validateResult(newContext, "AsnChatReactionsEmoji"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsEmoji | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsEmoji");

		let t: ENetUC_ChatV2.AsnChatReactionsEmoji | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatReactionsEmoji.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatReactionsEmoji["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sEmoji", "Utf8String", errors, newContext);
			const _u8susers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sUsers"), errors, newContext, "u8sUsers");
			if (_u8susers)
				t.u8sUsers = _u8susers;
		}

		if (errors.validateResult(newContext, "AsnChatReactionsEmoji"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetReactionArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetReactionArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetReactionArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetReactionArgument");

		const t = {} as ENetUC_ChatV2.AsnChatSetReactionArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetReactionArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEmoji", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatSetReactionArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetReactionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetReactionArgument");

		let t: ENetUC_ChatV2.AsnChatSetReactionArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetReactionArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetReactionArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEmoji", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatSetReactionArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetReactionArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetReactionArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetReactionArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sEmoji", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEmoji, name: "u8sEmoji" }));
		}

		if (errors.validateResult(newContext, "AsnChatSetReactionArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetReactionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetReactionArgument");

		let t: ENetUC_ChatV2.AsnChatSetReactionArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetReactionArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetReactionArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEmoji", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatSetReactionArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetReactionResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetReactionResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetReactionResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetReactionResult");

		const t = {} as ENetUC_ChatV2.AsnChatSetReactionResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetReactionResult";

		if (errors.validateResult(newContext, "AsnChatSetReactionResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetReactionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetReactionResult");

		let t: ENetUC_ChatV2.AsnChatSetReactionResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetReactionResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetReactionResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnChatSetReactionResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetReactionResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetReactionResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetReactionResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnChatSetReactionResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetReactionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetReactionResult");

		let t: ENetUC_ChatV2.AsnChatSetReactionResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetReactionResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetReactionResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnChatSetReactionResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatParties_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatParties, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatParties | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatParties");

		const t = [] as ENetUC_ChatV2.AsnChatParties;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnChatParty_Converter.toJSON(se, errors, newContext, "AsnChatParty");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnChatParties"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatParties | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatParties");

		let t: ENetUC_ChatV2.AsnChatParties | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatParties>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_ChatV2.AsnChatParties();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnChatParty_Converter.fromJSON(se, errors, newContext, "AsnChatParty", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnChatParties"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatParties | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatParties";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatParties");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnChatParty_Converter.toBER(s[id], errors, newContext, "AsnChatParty");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnChatParties"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatParties | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatParties");

		let t: ENetUC_ChatV2.AsnChatParties | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatParties.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_ChatV2.AsnChatParties();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnChatParty_Converter.fromBER(se, errors, newContext, "AsnChatParty", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnChatParties"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatForwardMessageArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatForwardMessageArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatForwardMessageArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardMessageArgument");

		const t = {} as ENetUC_ChatV2.AsnChatForwardMessageArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatForwardMessageArgument";
		TSConverter.fillJSONParam(s, t, "u8sSourceConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSourceSequenceID", "number", errors, newContext);
		const _asnForwardDestinationIDChoice = AsnConversationIDChoice_Converter.toJSON(s.asnForwardDestinationIDChoice, errors, newContext, "asnForwardDestinationIDChoice");
		if (_asnForwardDestinationIDChoice)
			t.asnForwardDestinationIDChoice = _asnForwardDestinationIDChoice;
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatForwardMessageArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardMessageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardMessageArgument");

		let t: ENetUC_ChatV2.AsnChatForwardMessageArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatForwardMessageArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatForwardMessageArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sSourceConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSourceSequenceID", "number", errors, newContext, false);
			const _asnforwarddestinationidchoice = AsnConversationIDChoice_Converter.fromJSON(s.asnForwardDestinationIDChoice, errors, newContext, "asnForwardDestinationIDChoice", false);
			if (_asnforwarddestinationidchoice)
				t.asnForwardDestinationIDChoice = _asnforwarddestinationidchoice;
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatForwardMessageArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatForwardMessageArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatForwardMessageArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatForwardMessageArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sSourceConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iSourceSequenceID", "number", errors, newContext);
		const _asnForwardDestinationIDChoice = AsnConversationIDChoice_Converter.toBER(s.asnForwardDestinationIDChoice, errors, newContext, "asnForwardDestinationIDChoice");
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sSourceConversationID, name: "u8sSourceConversationID" }));
			t.push(new asn1ts.Integer({ value: s.iSourceSequenceID, name: "iSourceSequenceID" }));
			if (_asnForwardDestinationIDChoice)
				t.push(_asnForwardDestinationIDChoice);
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnChatForwardMessageArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatForwardMessageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatForwardMessageArgument");

		let t: ENetUC_ChatV2.AsnChatForwardMessageArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatForwardMessageArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatForwardMessageArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sSourceConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSourceSequenceID", "Integer", errors, newContext);
			const _asnforwarddestinationidchoice = AsnConversationIDChoice_Converter.fromBER(s.getValueByName("asnForwardDestinationIDChoice"), errors, newContext, "asnForwardDestinationIDChoice");
			if (_asnforwarddestinationidchoice)
				t.asnForwardDestinationIDChoice = _asnforwarddestinationidchoice;
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatForwardMessageArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetEventsRangeArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetEventsRangeArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetEventsRangeArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetEventsRangeArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetEventsRangeArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetEventsRangeArgument";
		const _asnConversationIDChoice = AsnConversationIDChoice_Converter.toJSON(s.asnConversationIDChoice, errors, newContext, "asnConversationIDChoice");
		if (_asnConversationIDChoice)
			t.asnConversationIDChoice = _asnConversationIDChoice;
		TSConverter.fillJSONParam(s, t, "iSequenceID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iNumLessThanSeqID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iNumGreaterThanOrEqualSeqID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetEventsRangeArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetEventsRangeArgument");

		let t: ENetUC_ChatV2.AsnChatGetEventsRangeArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetEventsRangeArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetEventsRangeArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnconversationidchoice = AsnConversationIDChoice_Converter.fromJSON(s.asnConversationIDChoice, errors, newContext, "asnConversationIDChoice", false);
			if (_asnconversationidchoice)
				t.asnConversationIDChoice = _asnconversationidchoice;
			TSConverter.fillJSONParam(s, t, "iSequenceID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iNumLessThanSeqID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iNumGreaterThanOrEqualSeqID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetEventsRangeArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetEventsRangeArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetEventsRangeArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _asnConversationIDChoice = AsnConversationIDChoice_Converter.toBER(s.asnConversationIDChoice, errors, newContext, "asnConversationIDChoice");
		TSConverter.validateParam(s, "iSequenceID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iNumLessThanSeqID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iNumGreaterThanOrEqualSeqID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_asnConversationIDChoice)
				t.push(_asnConversationIDChoice);
			if (s.iSequenceID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iSequenceID, name: "iSequenceID", idBlock: { optionalID: 0 } }));
			if (s.iNumLessThanSeqID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iNumLessThanSeqID, name: "iNumLessThanSeqID", idBlock: { optionalID: 1 } }));
			if (s.iNumGreaterThanOrEqualSeqID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iNumGreaterThanOrEqualSeqID, name: "iNumGreaterThanOrEqualSeqID", idBlock: { optionalID: 2 } }));
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetEventsRangeArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetEventsRangeArgument");

		let t: ENetUC_ChatV2.AsnChatGetEventsRangeArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetEventsRangeArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetEventsRangeArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnconversationidchoice = AsnConversationIDChoice_Converter.fromBER(s.getValueByName("asnConversationIDChoice"), errors, newContext, "asnConversationIDChoice");
			if (_asnconversationidchoice)
				t.asnConversationIDChoice = _asnconversationidchoice;
			TSConverter.fillASN1Param(s, t, "iSequenceID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iNumLessThanSeqID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iNumGreaterThanOrEqualSeqID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetEventsRangeArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetBinaryMessageEventsArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetBinaryMessageEventsArgument");

		const t = {} as ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetBinaryMessageEventsArgument";
		const _asnConversationIDChoice = AsnConversationIDChoice_Converter.toJSON(s.asnConversationIDChoice, errors, newContext, "asnConversationIDChoice");
		if (_asnConversationIDChoice)
			t.asnConversationIDChoice = _asnConversationIDChoice;
		TSConverter.fillJSONParam(s, t, "iPageSize", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPageOffset", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetBinaryMessageEventsArgument");

		let t: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnconversationidchoice = AsnConversationIDChoice_Converter.fromJSON(s.asnConversationIDChoice, errors, newContext, "asnConversationIDChoice", false);
			if (_asnconversationidchoice)
				t.asnConversationIDChoice = _asnconversationidchoice;
			TSConverter.fillJSONParam(s, t, "iPageSize", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPageOffset", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetBinaryMessageEventsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetBinaryMessageEventsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _asnConversationIDChoice = AsnConversationIDChoice_Converter.toBER(s.asnConversationIDChoice, errors, newContext, "asnConversationIDChoice");
		TSConverter.validateParam(s, "iPageSize", "number", errors, newContext);
		TSConverter.validateParam(s, "iPageOffset", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iLastKnownGlobTransactionID", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_asnConversationIDChoice)
				t.push(_asnConversationIDChoice);
			t.push(new asn1ts.Integer({ value: s.iPageSize, name: "iPageSize" }));
			if (s.iPageOffset !== undefined)
				t.push(new asn1ts.Integer({ value: s.iPageOffset, name: "iPageOffset", idBlock: { optionalID: 0 } }));
			if (s.iLastKnownGlobTransactionID !== undefined)
				t.push(new asn1ts.Integer({ value: s.iLastKnownGlobTransactionID, name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 1 } }));
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }));
		}

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetBinaryMessageEventsArgument");

		let t: ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetBinaryMessageEventsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnconversationidchoice = AsnConversationIDChoice_Converter.fromBER(s.getValueByName("asnConversationIDChoice"), errors, newContext, "asnConversationIDChoice");
			if (_asnconversationidchoice)
				t.asnConversationIDChoice = _asnconversationidchoice;
			TSConverter.fillASN1Param(s, t, "iPageSize", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPageOffset", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iLastKnownGlobTransactionID", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnChatGetBinaryMessageEventsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatSetMessagesStatusArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatSetMessagesStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatSetMessagesStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetMessagesStatusArgument");

		const t = {} as ENetUC_ChatV2.AsnChatSetMessagesStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatSetMessagesStatusArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		const _asnSequenceIDSet = AsnChatSequenceIDSet_Converter.toJSON(s.asnSequenceIDSet, errors, newContext, "asnSequenceIDSet");
		if (_asnSequenceIDSet)
			t.asnSequenceIDSet = _asnSequenceIDSet;

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetMessagesStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetMessagesStatusArgument");

		let t: ENetUC_ChatV2.AsnChatSetMessagesStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatSetMessagesStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatSetMessagesStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			const _asnsequenceidset = AsnChatSequenceIDSet_Converter.fromJSON(s.asnSequenceIDSet, errors, newContext, "asnSequenceIDSet", false);
			if (_asnsequenceidset)
				t.asnSequenceIDSet = _asnsequenceidset;
		}

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatSetMessagesStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatSetMessagesStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatSetMessagesStatusArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		const _asnSequenceIDSet = AsnChatSequenceIDSet_Converter.toBER(s.asnSequenceIDSet, errors, newContext, "asnSequenceIDSet");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Integer({ value: s.iStatus, name: "iStatus" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			if (_asnSequenceIDSet)
				t.push(_asnSequenceIDSet);
		}

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatSetMessagesStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatSetMessagesStatusArgument");

		let t: ENetUC_ChatV2.AsnChatSetMessagesStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatSetMessagesStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatSetMessagesStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			const _asnsequenceidset = AsnChatSequenceIDSet_Converter.fromBER(s.getValueByName("asnSequenceIDSet"), errors, newContext, "asnSequenceIDSet");
			if (_asnsequenceidset)
				t.asnSequenceIDSet = _asnsequenceidset;
		}

		if (errors.validateResult(newContext, "AsnChatSetMessagesStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatReactionsEmojiList_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatReactionsEmojiList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatReactionsEmojiList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsEmojiList");

		const t = [] as ENetUC_ChatV2.AsnChatReactionsEmojiList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnChatReactionsEmoji_Converter.toJSON(se, errors, newContext, "AsnChatReactionsEmoji");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnChatReactionsEmojiList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsEmojiList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsEmojiList");

		let t: ENetUC_ChatV2.AsnChatReactionsEmojiList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatReactionsEmojiList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_ChatV2.AsnChatReactionsEmojiList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnChatReactionsEmoji_Converter.fromJSON(se, errors, newContext, "AsnChatReactionsEmoji", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnChatReactionsEmojiList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatReactionsEmojiList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatReactionsEmojiList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsEmojiList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnChatReactionsEmoji_Converter.toBER(s[id], errors, newContext, "AsnChatReactionsEmoji");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnChatReactionsEmojiList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsEmojiList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsEmojiList");

		let t: ENetUC_ChatV2.AsnChatReactionsEmojiList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatReactionsEmojiList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_ChatV2.AsnChatReactionsEmojiList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnChatReactionsEmoji_Converter.fromBER(se, errors, newContext, "AsnChatReactionsEmoji", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnChatReactionsEmojiList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatReactionsResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatReactionsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatReactionsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsResult");

		const t = {} as ENetUC_ChatV2.AsnChatReactionsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatReactionsResult";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTransactionID", "number", errors, newContext);
		const _asnEmojiList = AsnChatReactionsEmojiList_Converter.toJSON(s.asnEmojiList, errors, newContext, "asnEmojiList");
		if (_asnEmojiList)
			t.asnEmojiList = _asnEmojiList;

		if (errors.validateResult(newContext, "AsnChatReactionsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsResult");

		let t: ENetUC_ChatV2.AsnChatReactionsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatReactionsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatReactionsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTransactionID", "number", errors, newContext, false);
			const _asnemojilist = AsnChatReactionsEmojiList_Converter.fromJSON(s.asnEmojiList, errors, newContext, "asnEmojiList", false);
			if (_asnemojilist)
				t.asnEmojiList = _asnemojilist;
		}

		if (errors.validateResult(newContext, "AsnChatReactionsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatReactionsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatReactionsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "iTransactionID", "number", errors, newContext);
		const _asnEmojiList = AsnChatReactionsEmojiList_Converter.toBER(s.asnEmojiList, errors, newContext, "asnEmojiList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			t.push(new asn1ts.Integer({ value: s.iTransactionID, name: "iTransactionID" }));
			if (_asnEmojiList)
				t.push(_asnEmojiList);
		}

		if (errors.validateResult(newContext, "AsnChatReactionsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsResult");

		let t: ENetUC_ChatV2.AsnChatReactionsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatReactionsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatReactionsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTransactionID", "Integer", errors, newContext);
			const _asnemojilist = AsnChatReactionsEmojiList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnEmojiList"), errors, newContext, "asnEmojiList");
			if (_asnemojilist)
				t.asnEmojiList = _asnemojilist;
		}

		if (errors.validateResult(newContext, "AsnChatReactionsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatEventConversation_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatEventConversation, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatEventConversation & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventConversation");

		const t = {} as ENetUC_ChatV2.AsnChatEventConversation & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatEventConversation";
		TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, true);
		if (s.asnChatParties) {
			const _asnChatParties = AsnChatParties_Converter.toJSON(s.asnChatParties, errors, newContext, "asnChatParties");
			if (_asnChatParties)
				t.asnChatParties = _asnChatParties;
		}
		TSConverter.fillJSONParam(s, t, "iChatUserlistModify", "number", errors, newContext, true);
		if (s.u8sUsersModified) {
			const _u8sUsersModified = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sUsersModified, errors, newContext, "u8sUsersModified");
			if (_u8sUsersModified)
				t.u8sUsersModified = _u8sUsersModified;
		}
		TSConverter.fillJSONParam(s, t, "u8sForwardedFromURI", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sForwardedURI", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sLinkedConversationID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bDeleted", "boolean", errors, newContext, true);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnChatEventConversation"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventConversation | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventConversation");

		let t: ENetUC_ChatV2.AsnChatEventConversation | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatEventConversation>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatEventConversation["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, true);
			const _asnchatparties = AsnChatParties_Converter.fromJSON(s.asnChatParties, errors, newContext, "asnChatParties", true);
			if (_asnchatparties)
				t.asnChatParties = _asnchatparties;
			TSConverter.fillJSONParam(s, t, "iChatUserlistModify", "number", errors, newContext, true);
			const _u8susersmodified = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sUsersModified, errors, newContext, "u8sUsersModified", true);
			if (_u8susersmodified)
				t.u8sUsersModified = _u8susersmodified;
			TSConverter.fillJSONParam(s, t, "u8sForwardedFromURI", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sForwardedURI", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sLinkedConversationID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bDeleted", "boolean", errors, newContext, true);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnChatEventConversation"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatEventConversation | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatEventConversation";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventConversation");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationName", "string", errors, newContext, true);
		const _asnChatParties = AsnChatParties_Converter.toBER(s.asnChatParties, errors, newContext, "asnChatParties", 1);
		TSConverter.validateParam(s, "iChatUserlistModify", "number", errors, newContext, true);
		const _u8sUsersModified = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sUsersModified, errors, newContext, "u8sUsersModified", 3);
		TSConverter.validateParam(s, "u8sForwardedFromURI", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sForwardedURI", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sLinkedConversationID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iConversationType", "number", errors, newContext, true);
		TSConverter.validateParam(s, "bDeleted", "boolean", errors, newContext, true);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", 9);
		if (!errors.hasNewErrors()) {
			if (s.u8sConversationName !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConversationName, name: "u8sConversationName", idBlock: { optionalID: 0 } }));
			if (_asnChatParties)
				t.push(_asnChatParties);
			if (s.iChatUserlistModify !== undefined)
				t.push(new asn1ts.Integer({ value: s.iChatUserlistModify, name: "iChatUserlistModify", idBlock: { optionalID: 2 } }));
			if (_u8sUsersModified)
				t.push(_u8sUsersModified);
			if (s.u8sForwardedFromURI !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sForwardedFromURI, name: "u8sForwardedFromURI", idBlock: { optionalID: 4 } }));
			if (s.u8sForwardedURI !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sForwardedURI, name: "u8sForwardedURI", idBlock: { optionalID: 5 } }));
			if (s.u8sLinkedConversationID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sLinkedConversationID, name: "u8sLinkedConversationID", idBlock: { optionalID: 6 } }));
			if (s.iConversationType !== undefined)
				t.push(new asn1ts.Integer({ value: s.iConversationType, name: "iConversationType", idBlock: { optionalID: 7 } }));
			if (s.bDeleted !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bDeleted, name: "bDeleted", idBlock: { optionalID: 8 } }));
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnChatEventConversation"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventConversation | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventConversation");

		let t: ENetUC_ChatV2.AsnChatEventConversation | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatEventConversation.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatEventConversation["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationName", "Utf8String", errors, newContext, true);
			t.asnChatParties = AsnChatParties_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnChatParties"), errors, newContext, "asnChatParties", true);
			TSConverter.fillASN1Param(s, t, "iChatUserlistModify", "Integer", errors, newContext, true);
			t.u8sUsersModified = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sUsersModified"), errors, newContext, "u8sUsersModified", true);
			TSConverter.fillASN1Param(s, t, "u8sForwardedFromURI", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sForwardedURI", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sLinkedConversationID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iConversationType", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bDeleted", "Boolean", errors, newContext, true);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnChatEventConversation"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatConversation_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatConversation, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatConversation & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatConversation");

		const t = {} as ENetUC_ChatV2.AsnChatConversation & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatConversation";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iGlobTransactionID", "number", errors, newContext);
		const _asnChatParties = AsnChatParties_Converter.toJSON(s.asnChatParties, errors, newContext, "asnChatParties");
		if (_asnChatParties)
			t.asnChatParties = _asnChatParties;

		if (errors.validateResult(newContext, "AsnChatConversation"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatConversation | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatConversation");

		let t: ENetUC_ChatV2.AsnChatConversation | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatConversation>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatConversation["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConversationType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iGlobTransactionID", "number", errors, newContext, false);
			const _asnchatparties = AsnChatParties_Converter.fromJSON(s.asnChatParties, errors, newContext, "asnChatParties", false);
			if (_asnchatparties)
				t.asnChatParties = _asnchatparties;
		}

		if (errors.validateResult(newContext, "AsnChatConversation"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatConversation | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatConversation";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatConversation");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationName", "string", errors, newContext);
		TSConverter.validateParam(s, "iConversationType", "number", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "iGlobTransactionID", "number", errors, newContext);
		const _asnChatParties = AsnChatParties_Converter.toBER(s.asnChatParties, errors, newContext, "asnChatParties");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationName, name: "u8sConversationName" }));
			t.push(new asn1ts.Integer({ value: s.iConversationType, name: "iConversationType" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			t.push(new asn1ts.Integer({ value: s.iGlobTransactionID, name: "iGlobTransactionID" }));
			if (_asnChatParties)
				t.push(_asnChatParties);
		}

		if (errors.validateResult(newContext, "AsnChatConversation"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatConversation | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatConversation");

		let t: ENetUC_ChatV2.AsnChatConversation | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatConversation.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatConversation["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConversationType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iGlobTransactionID", "Integer", errors, newContext);
			const _asnchatparties = AsnChatParties_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnChatParties"), errors, newContext, "asnChatParties");
			if (_asnchatparties)
				t.asnChatParties = _asnchatparties;
		}

		if (errors.validateResult(newContext, "AsnChatConversation"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatConversationList_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatConversationList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatConversationList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatConversationList");

		const t = [] as ENetUC_ChatV2.AsnChatConversationList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnChatConversation_Converter.toJSON(se, errors, newContext, "AsnChatConversation");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnChatConversationList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatConversationList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatConversationList");

		let t: ENetUC_ChatV2.AsnChatConversationList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatConversationList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_ChatV2.AsnChatConversationList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnChatConversation_Converter.fromJSON(se, errors, newContext, "AsnChatConversation", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnChatConversationList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatConversationList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatConversationList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatConversationList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnChatConversation_Converter.toBER(s[id], errors, newContext, "AsnChatConversation");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnChatConversationList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatConversationList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatConversationList");

		let t: ENetUC_ChatV2.AsnChatConversationList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatConversationList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_ChatV2.AsnChatConversationList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnChatConversation_Converter.fromBER(se, errors, newContext, "AsnChatConversation", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnChatConversationList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatGetConversationsResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatGetConversationsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatGetConversationsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationsResult");

		const t = {} as ENetUC_ChatV2.AsnChatGetConversationsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatGetConversationsResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		const _asnConversationList = AsnChatConversationList_Converter.toJSON(s.asnConversationList, errors, newContext, "asnConversationList");
		if (_asnConversationList)
			t.asnConversationList = _asnConversationList;

		if (errors.validateResult(newContext, "AsnChatGetConversationsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationsResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatGetConversationsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatGetConversationsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			const _asnconversationlist = AsnChatConversationList_Converter.fromJSON(s.asnConversationList, errors, newContext, "asnConversationList", false);
			if (_asnconversationlist)
				t.asnConversationList = _asnconversationlist;
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatGetConversationsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatGetConversationsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatGetConversationsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		const _asnConversationList = AsnChatConversationList_Converter.toBER(s.asnConversationList, errors, newContext, "asnConversationList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			if (_asnConversationList)
				t.push(_asnConversationList);
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatGetConversationsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatGetConversationsResult");

		let t: ENetUC_ChatV2.AsnChatGetConversationsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatGetConversationsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatGetConversationsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			const _asnconversationlist = AsnChatConversationList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnConversationList"), errors, newContext, "asnConversationList");
			if (_asnconversationlist)
				t.asnConversationList = _asnconversationlist;
		}

		if (errors.validateResult(newContext, "AsnChatGetConversationsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatEvent_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatEvent, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatEvent & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEvent");

		const t = {} as ENetUC_ChatV2.AsnChatEvent & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatEvent";
		TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iGlobTransactionID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUpdate", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "asnCreateTime", "Date", errors, newContext, true);
		if (s.asnChatMessage) {
			const _asnChatMessage = AsnChatEventMessage_Converter.toJSON(s.asnChatMessage, errors, newContext, "asnChatMessage");
			if (_asnChatMessage)
				t.asnChatMessage = _asnChatMessage;
		}
		if (s.asnChatConversation) {
			const _asnChatConversation = AsnChatEventConversation_Converter.toJSON(s.asnChatConversation, errors, newContext, "asnChatConversation");
			if (_asnChatConversation)
				t.asnChatConversation = _asnChatConversation;
		}
		TSConverter.fillJSONParam(s, t, "iError", "number", errors, newContext, true);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnChatEvent"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEvent | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEvent");

		let t: ENetUC_ChatV2.AsnChatEvent | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatEvent>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatEvent["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sEventCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConvSequenceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iGlobTransactionID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUpdate", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSenderURI", "string", errors, newContext, true);
			if (TSConverter.validateParam(s, "asnCreateTime", "string", errors, newContext, true) && s.asnCreateTime)
				t.asnCreateTime = new Date(s.asnCreateTime);
			const _asnchatmessage = AsnChatEventMessage_Converter.fromJSON(s.asnChatMessage, errors, newContext, "asnChatMessage", true);
			if (_asnchatmessage)
				t.asnChatMessage = _asnchatmessage;
			const _asnchatconversation = AsnChatEventConversation_Converter.fromJSON(s.asnChatConversation, errors, newContext, "asnChatConversation", true);
			if (_asnchatconversation)
				t.asnChatConversation = _asnchatconversation;
			TSConverter.fillJSONParam(s, t, "iError", "number", errors, newContext, true);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnChatEvent"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatEvent | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatEvent";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEvent");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sEventCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iConvSequenceID", "number", errors, newContext);
		TSConverter.validateParam(s, "iGlobTransactionID", "number", errors, newContext);
		TSConverter.validateParam(s, "bUpdate", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sSenderURI", "string", errors, newContext, true);
		TSConverter.validateParam(s, "asnCreateTime", "Date", errors, newContext, true);
		const _asnChatMessage = AsnChatEventMessage_Converter.toBER(s.asnChatMessage, errors, newContext, "asnChatMessage", 2);
		const _asnChatConversation = AsnChatEventConversation_Converter.toBER(s.asnChatConversation, errors, newContext, "asnChatConversation", 3);
		TSConverter.validateParam(s, "iError", "number", errors, newContext, true);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", 5);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sEventCrossRefID, name: "u8sEventCrossRefID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
			t.push(new asn1ts.Integer({ value: s.iConvSequenceID, name: "iConvSequenceID" }));
			t.push(new asn1ts.Integer({ value: s.iGlobTransactionID, name: "iGlobTransactionID" }));
			t.push(new asn1ts.Boolean({ value: s.bUpdate, name: "bUpdate" }));
			if (s.u8sSenderURI !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sSenderURI, name: "u8sSenderURI", idBlock: { optionalID: 0 } }));
			if (s.asnCreateTime !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.asnCreateTime), name: "asnCreateTime", idBlock: { optionalID: 1 } }));
			if (_asnChatMessage)
				t.push(_asnChatMessage);
			if (_asnChatConversation)
				t.push(_asnChatConversation);
			if (s.iError !== undefined)
				t.push(new asn1ts.Integer({ value: s.iError, name: "iError", idBlock: { optionalID: 4 } }));
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnChatEvent"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEvent | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEvent");

		let t: ENetUC_ChatV2.AsnChatEvent | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatEvent.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatEvent["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sEventCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConvSequenceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iGlobTransactionID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUpdate", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSenderURI", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "asnCreateTime", "AsnSystemTime", errors, newContext, true);
			t.asnChatMessage = AsnChatEventMessage_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnChatMessage"), errors, newContext, "asnChatMessage", true);
			t.asnChatConversation = AsnChatEventConversation_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnChatConversation"), errors, newContext, "asnChatConversation", true);
			TSConverter.fillASN1Param(s, t, "iError", "Integer", errors, newContext, true);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnChatEvent"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatEventMessage_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatEventMessage, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatEventMessage & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventMessage");

		const t = {} as ENetUC_ChatV2.AsnChatEventMessage & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatEventMessage";
		TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, true);
		if (s.asnBinaryDescription) {
			const _asnBinaryDescription = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferMetaData_Converter.toJSON(s.asnBinaryDescription, errors, newContext, "asnBinaryDescription");
			if (_asnBinaryDescription)
				t.asnBinaryDescription = _asnBinaryDescription;
		}
		if (s.journalEntry) {
			const _journalEntry = ENetUC_Journal_Converter.AsnNetDatabaseJournal_Converter.toJSON(s.journalEntry, errors, newContext, "journalEntry");
			if (_journalEntry)
				t.journalEntry = _journalEntry;
		}
		TSConverter.fillJSONParam(s, t, "asnDeliverTime", "Date", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "asnReadTime", "Date", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bRead", "boolean", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bDeleted", "boolean", errors, newContext, true);
		if (s.asnReplyToEvent) {
			const _asnReplyToEvent = AsnChatEvent_Converter.toJSON(s.asnReplyToEvent, errors, newContext, "asnReplyToEvent");
			if (_asnReplyToEvent)
				t.asnReplyToEvent = _asnReplyToEvent;
		}
		TSConverter.fillJSONParam(s, t, "u8sForwardOrigin", "string", errors, newContext, true);
		if (s.asnReactions) {
			const _asnReactions = AsnChatReactionsEmojiList_Converter.toJSON(s.asnReactions, errors, newContext, "asnReactions");
			if (_asnReactions)
				t.asnReactions = _asnReactions;
		}

		if (errors.validateResult(newContext, "AsnChatEventMessage"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventMessage | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventMessage");

		let t: ENetUC_ChatV2.AsnChatEventMessage | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatEventMessage>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatEventMessage["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, true);
			const _asnbinarydescription = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferMetaData_Converter.fromJSON(s.asnBinaryDescription, errors, newContext, "asnBinaryDescription", true);
			if (_asnbinarydescription)
				t.asnBinaryDescription = _asnbinarydescription;
			const _journalentry = ENetUC_Journal_Converter.AsnNetDatabaseJournal_Converter.fromJSON(s.journalEntry, errors, newContext, "journalEntry", true);
			if (_journalentry)
				t.journalEntry = _journalentry;
			if (TSConverter.validateParam(s, "asnDeliverTime", "string", errors, newContext, true) && s.asnDeliverTime)
				t.asnDeliverTime = new Date(s.asnDeliverTime);
			if (TSConverter.validateParam(s, "asnReadTime", "string", errors, newContext, true) && s.asnReadTime)
				t.asnReadTime = new Date(s.asnReadTime);
			TSConverter.fillJSONParam(s, t, "bRead", "boolean", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bDeleted", "boolean", errors, newContext, true);
			const _asnreplytoevent = AsnChatEvent_Converter.fromJSON(s.asnReplyToEvent, errors, newContext, "asnReplyToEvent", true);
			if (_asnreplytoevent)
				t.asnReplyToEvent = _asnreplytoevent;
			TSConverter.fillJSONParam(s, t, "u8sForwardOrigin", "string", errors, newContext, true);
			const _asnreactions = AsnChatReactionsEmojiList_Converter.fromJSON(s.asnReactions, errors, newContext, "asnReactions", true);
			if (_asnreactions)
				t.asnReactions = _asnreactions;
		}

		if (errors.validateResult(newContext, "AsnChatEventMessage"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatEventMessage | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatEventMessage";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventMessage");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMessage", "string", errors, newContext, true);
		const _asnBinaryDescription = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferMetaData_Converter.toBER(s.asnBinaryDescription, errors, newContext, "asnBinaryDescription", 1);
		const _journalEntry = ENetUC_Journal_Converter.AsnNetDatabaseJournal_Converter.toBER(s.journalEntry, errors, newContext, "journalEntry", 2);
		TSConverter.validateParam(s, "asnDeliverTime", "Date", errors, newContext, true);
		TSConverter.validateParam(s, "asnReadTime", "Date", errors, newContext, true);
		TSConverter.validateParam(s, "bRead", "boolean", errors, newContext, true);
		TSConverter.validateParam(s, "bDeleted", "boolean", errors, newContext, true);
		const _asnReplyToEvent = AsnChatEvent_Converter.toBER(s.asnReplyToEvent, errors, newContext, "asnReplyToEvent", 7);
		TSConverter.validateParam(s, "u8sForwardOrigin", "string", errors, newContext, true);
		const _asnReactions = AsnChatReactionsEmojiList_Converter.toBER(s.asnReactions, errors, newContext, "asnReactions", 9);
		if (!errors.hasNewErrors()) {
			if (s.u8sMessage !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sMessage, name: "u8sMessage", idBlock: { optionalID: 0 } }));
			if (_asnBinaryDescription)
				t.push(_asnBinaryDescription);
			if (_journalEntry)
				t.push(_journalEntry);
			if (s.asnDeliverTime !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.asnDeliverTime), name: "asnDeliverTime", idBlock: { optionalID: 3 } }));
			if (s.asnReadTime !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.asnReadTime), name: "asnReadTime", idBlock: { optionalID: 4 } }));
			if (s.bRead !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bRead, name: "bRead", idBlock: { optionalID: 5 } }));
			if (s.bDeleted !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bDeleted, name: "bDeleted", idBlock: { optionalID: 6 } }));
			if (_asnReplyToEvent)
				t.push(_asnReplyToEvent);
			if (s.u8sForwardOrigin !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sForwardOrigin, name: "u8sForwardOrigin", idBlock: { optionalID: 8 } }));
			if (_asnReactions)
				t.push(_asnReactions);
		}

		if (errors.validateResult(newContext, "AsnChatEventMessage"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventMessage | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventMessage");

		let t: ENetUC_ChatV2.AsnChatEventMessage | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatEventMessage.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatEventMessage["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMessage", "Utf8String", errors, newContext, true);
			t.asnBinaryDescription = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferMetaData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnBinaryDescription"), errors, newContext, "asnBinaryDescription", true);
			t.journalEntry = ENetUC_Journal_Converter.AsnNetDatabaseJournal_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "journalEntry"), errors, newContext, "journalEntry", true);
			TSConverter.fillASN1Param(s, t, "asnDeliverTime", "AsnSystemTime", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "asnReadTime", "AsnSystemTime", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bRead", "Boolean", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bDeleted", "Boolean", errors, newContext, true);
			t.asnReplyToEvent = AsnChatEvent_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnReplyToEvent"), errors, newContext, "asnReplyToEvent", true);
			TSConverter.fillASN1Param(s, t, "u8sForwardOrigin", "Utf8String", errors, newContext, true);
			t.asnReactions = AsnChatReactionsEmojiList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnReactions"), errors, newContext, "asnReactions", true);
		}

		if (errors.validateResult(newContext, "AsnChatEventMessage"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatEventList_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatEventList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatEventList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventList");

		const t = [] as ENetUC_ChatV2.AsnChatEventList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnChatEvent_Converter.toJSON(se, errors, newContext, "AsnChatEvent");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnChatEventList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventList");

		let t: ENetUC_ChatV2.AsnChatEventList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatEventList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_ChatV2.AsnChatEventList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnChatEvent_Converter.fromJSON(se, errors, newContext, "AsnChatEvent", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnChatEventList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatEventList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatEventList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnChatEvent_Converter.toBER(s[id], errors, newContext, "AsnChatEvent");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnChatEventList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventList");

		let t: ENetUC_ChatV2.AsnChatEventList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatEventList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_ChatV2.AsnChatEventList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnChatEvent_Converter.fromBER(se, errors, newContext, "AsnChatEvent", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnChatEventList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatFindEventsResult_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatFindEventsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatFindEventsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatFindEventsResult");

		const t = {} as ENetUC_ChatV2.AsnChatFindEventsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatFindEventsResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNumTotalResults", "number", errors, newContext);
		const _asnChatEventList = AsnChatEventList_Converter.toJSON(s.asnChatEventList, errors, newContext, "asnChatEventList");
		if (_asnChatEventList)
			t.asnChatEventList = _asnChatEventList;

		if (errors.validateResult(newContext, "AsnChatFindEventsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatFindEventsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatFindEventsResult");

		let t: ENetUC_ChatV2.AsnChatFindEventsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatFindEventsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatFindEventsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNumTotalResults", "number", errors, newContext, false);
			const _asnchateventlist = AsnChatEventList_Converter.fromJSON(s.asnChatEventList, errors, newContext, "asnChatEventList", false);
			if (_asnchateventlist)
				t.asnChatEventList = _asnchateventlist;
		}

		if (errors.validateResult(newContext, "AsnChatFindEventsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatFindEventsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatFindEventsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatFindEventsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "iNumTotalResults", "number", errors, newContext);
		const _asnChatEventList = AsnChatEventList_Converter.toBER(s.asnChatEventList, errors, newContext, "asnChatEventList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Integer({ value: s.iNumTotalResults, name: "iNumTotalResults" }));
			if (_asnChatEventList)
				t.push(_asnChatEventList);
		}

		if (errors.validateResult(newContext, "AsnChatFindEventsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatFindEventsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatFindEventsResult");

		let t: ENetUC_ChatV2.AsnChatFindEventsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatFindEventsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatFindEventsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNumTotalResults", "Integer", errors, newContext);
			const _asnchateventlist = AsnChatEventList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnChatEventList"), errors, newContext, "asnChatEventList");
			if (_asnchateventlist)
				t.asnChatEventList = _asnchateventlist;
		}

		if (errors.validateResult(newContext, "AsnChatFindEventsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatEventArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventArgument");

		const t = {} as ENetUC_ChatV2.AsnChatEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatEventArgument";
		const _asnChatEventList = AsnChatEventList_Converter.toJSON(s.asnChatEventList, errors, newContext, "asnChatEventList");
		if (_asnChatEventList)
			t.asnChatEventList = _asnChatEventList;
		TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bLastSegment", "boolean", errors, newContext, true);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnChatEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventArgument");

		let t: ENetUC_ChatV2.AsnChatEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnchateventlist = AsnChatEventList_Converter.fromJSON(s.asnChatEventList, errors, newContext, "asnChatEventList", false);
			if (_asnchateventlist)
				t.asnChatEventList = _asnchateventlist;
			TSConverter.fillJSONParam(s, t, "u8sEventListCrossRefID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bLastSegment", "boolean", errors, newContext, true);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnChatEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _asnChatEventList = AsnChatEventList_Converter.toBER(s.asnChatEventList, errors, newContext, "asnChatEventList");
		TSConverter.validateParam(s, "u8sEventListCrossRefID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "bLastSegment", "boolean", errors, newContext, true);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", true);
		if (!errors.hasNewErrors()) {
			if (_asnChatEventList)
				t.push(_asnChatEventList);
			if (s.u8sEventListCrossRefID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEventListCrossRefID, name: "u8sEventListCrossRefID" }));
			if (s.bLastSegment !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bLastSegment, name: "bLastSegment" }));
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnChatEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatEventArgument");

		let t: ENetUC_ChatV2.AsnChatEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnchateventlist = AsnChatEventList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnChatEventList"), errors, newContext, "asnChatEventList");
			if (_asnchateventlist)
				t.asnChatEventList = _asnchateventlist;
			TSConverter.fillASN1Param(s, t, "u8sEventListCrossRefID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bLastSegment", "Boolean", errors, newContext, true);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnChatEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatAppActionNavigateArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatAppActionNavigateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatAppActionNavigateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatAppActionNavigateArgument");

		const t = {} as ENetUC_ChatV2.AsnChatAppActionNavigateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatAppActionNavigateArgument";
		TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnChatAppActionNavigateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatAppActionNavigateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatAppActionNavigateArgument");

		let t: ENetUC_ChatV2.AsnChatAppActionNavigateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatAppActionNavigateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatAppActionNavigateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sConversationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnChatAppActionNavigateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatAppActionNavigateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatAppActionNavigateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatAppActionNavigateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sConversationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationID, name: "u8sConversationID" }));
		}

		if (errors.validateResult(newContext, "AsnChatAppActionNavigateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatAppActionNavigateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatAppActionNavigateArgument");

		let t: ENetUC_ChatV2.AsnChatAppActionNavigateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatAppActionNavigateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatAppActionNavigateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sConversationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnChatAppActionNavigateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatAppActionCreateRoomArgument_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatAppActionCreateRoomArgument");

		const t = {} as ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnChatAppActionCreateRoomArgument";
		const _u8sUsers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sUsers, errors, newContext, "u8sUsers");
		if (_u8sUsers)
			t.u8sUsers = _u8sUsers;

		if (errors.validateResult(newContext, "AsnChatAppActionCreateRoomArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatAppActionCreateRoomArgument");

		let t: ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8susers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sUsers, errors, newContext, "u8sUsers", false);
			if (_u8susers)
				t.u8sUsers = _u8susers;
		}

		if (errors.validateResult(newContext, "AsnChatAppActionCreateRoomArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatAppActionCreateRoomArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatAppActionCreateRoomArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8sUsers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sUsers, errors, newContext, "u8sUsers");
		if (!errors.hasNewErrors()) {
			if (_u8sUsers)
				t.push(_u8sUsers);
		}

		if (errors.validateResult(newContext, "AsnChatAppActionCreateRoomArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatAppActionCreateRoomArgument");

		let t: ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_ChatV2.AsnChatAppActionCreateRoomArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8susers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sUsers"), errors, newContext, "u8sUsers");
			if (_u8susers)
				t.u8sUsers = _u8susers;
		}

		if (errors.validateResult(newContext, "AsnChatAppActionCreateRoomArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnChatReactionsResultList_Converter {
	public static toJSON(s: ENetUC_ChatV2.AsnChatReactionsResultList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_ChatV2.AsnChatReactionsResultList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsResultList");

		const t = [] as ENetUC_ChatV2.AsnChatReactionsResultList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnChatReactionsResult_Converter.toJSON(se, errors, newContext, "AsnChatReactionsResult");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnChatReactionsResultList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsResultList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsResultList");

		let t: ENetUC_ChatV2.AsnChatReactionsResultList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_ChatV2.AsnChatReactionsResultList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_ChatV2.AsnChatReactionsResultList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnChatReactionsResult_Converter.fromJSON(se, errors, newContext, "AsnChatReactionsResult", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnChatReactionsResultList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_ChatV2.AsnChatReactionsResultList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnChatReactionsResultList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnChatReactionsResultList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnChatReactionsResult_Converter.toBER(s[id], errors, newContext, "AsnChatReactionsResult");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnChatReactionsResultList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_ChatV2.AsnChatReactionsResultList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnChatReactionsResultList");

		let t: ENetUC_ChatV2.AsnChatReactionsResultList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_ChatV2.AsnChatReactionsResultList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_ChatV2.AsnChatReactionsResultList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnChatReactionsResult_Converter.fromBER(se, errors, newContext, "AsnChatReactionsResult", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnChatReactionsResultList"))
			return t;

		return undefined;
	}
}
