// [PrintTSROSEHeader]
/**
 * ENetUC_AgentROSE
 * "UC-Server-Access-Protocol-Agent" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
// [PrintTSROSEImports]
// Global imports
import { IENetUC_AgentROSE, IENetUC_AgentROSE_Handler } from "./ENetUC_AgentROSE_Interface";
import { ROSEError, ROSEInvoke, ROSEReject, ROSEResult } from "./SNACCROSE";
import { AsnInvokeProblem, AsnInvokeProblemEnum, createInvokeReject, IASN1Transport, IASN1LogData, IReceiveInvokeContext, IInvokeHandler, ELogSeverity, ROSEBase } from "./TSROSEBase";
import { ISendInvokeContextParams } from "./TSInvokeContext";
// Local imports
import * as ENetUC_Agent from "./ENetUC_Agent";
import * as Converter from "./ENetUC_Agent_Converter";
// [PrintTSImports]
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_ServicesAgents from "./ENetUC_ServicesAgents";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_ServicesAgents_Converter from "./ENetUC_ServicesAgents_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_AgentROSE";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSROSEOperationDefines]
export enum OperationIDs {
	OPID_asnAgentMonitorStart = 1902,
	OPID_asnAgentMonitorStop = 1903,
	OPID_asnAgentLogin = 1904,
	OPID_asnAgentLogoff = 1905,
	OPID_asnAgentSetState = 1906,
	OPID_asnAgentNotifyGroupsChanged = 1950,
	OPID_asnAgentNotifyStateChanged = 1951,
	OPID_asnAgentNotifyBlockedRTCChanged = 1961
}

// [PrintTSROSEModuleComment]
/**
 * Agent\/AgentGroup\/ACD interface.
 * ## Module description
 * This module describes the functions for agents for ACD and contact portal functionalities.
 *
 * A client represents a user who can be an member in any number of agent groups.&lt;br \/&gt;
 * An agent is described by the ContactURI of the user (SIP address incl. \"sip:\" before) or a LineURI (Cti line, format \"tel:xyz\@pbx text\").
 * To login to a group, for example, you usually need the AgencyURI and the GroupURI. This allows the UCServer to identify exactly which agent should be used in which group.&lt;br \/&gt;
 * The client receives the necessary values when it gets them back as a result of asnAgentMonitorStart.
 *
 * ### Requirements for using the interface
 * A user gets access to the agent interface:
 * - If the user has activated the service \"Business card for anonymous users\" via his own or global profile in the UCServer administration.
 * - If he is a member of one or more groups that have been activated in the UCServer administration as an \"agent group\".
 * - If (identified by line ID) he has a line known to be part of an ACD group at the corresponding ECSTA.
 *
 * ### Functions
 * A user can set the following status on the interface:
 * - \"login\"\/\"logout\"
 * - \"Working after call\"
 * - \"ready\"\/\"not ready\" (still a \"work in progress\")
 *
 * ProCall 5.1 supports ACD functionality only for Panasonic telephone systems.&lt;br \/&gt;
 * As of ProCall 6, the agent interface is used for the contact portal and business card. Further PBX's are in development.
 *
 * ## Simple procedure if the agent groups are to be used ##
 * 1. The user must only call asnAgentMonitorStart; this registers the agent's events and supplies the list of groups in which the user is agent.
 * 2. From this point on, the UCServer sends events if the status of the user in these groups changes.
 * 3. Change the state of the agent:
 * 3.1. asnAgentLogin - Sets the status of the user to \"login\". Note: replaces asnAgentSetState(not ready).
 * More parameters may be required for the login. These can be found in the AgentGroupInfos
 * 3.2. asnAgentLogoff - Sets the status of the user to \"logoff\". Note: replaces asAgentSetState(noagent).
 * 3.3. asnAgentSetState - With this you can set the status to \"ready\", \"not ready\" and \"working after call\". Which states can be set is provided by the server in the result of asnAgentMonitorStart. See also AsnAgentGroupInfo.
 * 4. Log off events with asnAgentMonitorStop.
 *
 * With these five functions it is possible to operate the ACD\/presence groups on the UCServer.
 *
 * ## AsnAgentGroupInfo
 * AsnAgentGroupInfo structures are usually exchanged in the analysis and results. This structure contains the description of an agent\/ACD group.&lt;br \/&gt;
 * AsnAgentGroupInfo contains the data about an agent group. The following are important:
 * - iGroupCapabilities: This shows which status changes are supported. See also AsnAgentGroupCapabilitiesEnum. If the highest bit is set (0x80000000), this group is a PBX\/ACD group. If the bit is not set, the group is managed by the UCServer.
 * - iAgentState: The current status of the agent, i.e. the user in this group.
 * - optionalParams,key \"AgentLoginRequiredParameters\": In the case of a PBX\/ACD group, this integer contains information about which parameters are required for logging on to the ACD group. The values (bit field) are described in AsnAgentLoginRequiredParametersEnum.
 *
 *
 * ## Events
 * For any changes to the agent groups and agent status, two events are sent by the UCServer to the registered clients:
 * - asnAgentNotifyGroupsChanged - There have been some changes in the user's available groups
 * - asnAgentNotifyStateChanged - The user's status in a group has changed.
 *
 * ## Comment
 * The API is user centered. This means if the server is asked for the AgentGroupInfos,
 * the server displays the information concerning its group membership in a simple list.
 * The most simple for the normal user.
 *
 * ## Supervisor Interface
 * Not implemented yet.
 *
 * ## Anonymous users
 * Anonymous users can query which groups are available, including users, and then display the corresponding presence and login\/logoff status based on the use case.
 */

// [PrintTSROSEClass]
export class ENetUC_AgentROSE extends ROSEBase implements IInvokeHandler, IENetUC_AgentROSE {
	/**
	 * Contains the attributes that have to be filtered from logging
	 * Use logfilter property;property inside the asn1 root comments to specify this list
	 */
	public readonly logFilter: string[];

	/**
	 * The Loggers getLogData callback (used in all the log methods called in this class, add the classname to every log entry)
	 *
	 * @returns - an ILogData log data object provided additional data for all the logger calls in this class
	 */
	public getLogData(): IASN1LogData {
		return {
			className: MODULE_NAME
		};
	}

	/**
	 * Returns the operationName for an operationID
	 *
	 * @param id - the id we want to have the name for
	 * @returns - the name or undefined if not found
	 */
	public getNameForOperationID(id: OperationIDs): string | undefined {
		switch (id) {
			case OperationIDs.OPID_asnAgentMonitorStart:
				return "asnAgentMonitorStart";
			case OperationIDs.OPID_asnAgentMonitorStop:
				return "asnAgentMonitorStop";
			case OperationIDs.OPID_asnAgentLogin:
				return "asnAgentLogin";
			case OperationIDs.OPID_asnAgentLogoff:
				return "asnAgentLogoff";
			case OperationIDs.OPID_asnAgentSetState:
				return "asnAgentSetState";
			case OperationIDs.OPID_asnAgentNotifyGroupsChanged:
				return "asnAgentNotifyGroupsChanged";
			case OperationIDs.OPID_asnAgentNotifyStateChanged:
				return "asnAgentNotifyStateChanged";
			case OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged:
				return "asnAgentNotifyBlockedRTCChanged";
			default:
				return undefined;
		}
	}

	/**
	 * Returns the operationID for an operationName
	 *
	 * @param name - the name we want to have the id for
	 * @returns - the id or undefined if not found
	 */
	public getIDForOperationName(name: string): OperationIDs | undefined {
		switch (name) {
			case "asnAgentMonitorStart":
				return OperationIDs.OPID_asnAgentMonitorStart;
			case "asnAgentMonitorStop":
				return OperationIDs.OPID_asnAgentMonitorStop;
			case "asnAgentLogin":
				return OperationIDs.OPID_asnAgentLogin;
			case "asnAgentLogoff":
				return OperationIDs.OPID_asnAgentLogoff;
			case "asnAgentSetState":
				return OperationIDs.OPID_asnAgentSetState;
			case "asnAgentNotifyGroupsChanged":
				return OperationIDs.OPID_asnAgentNotifyGroupsChanged;
			case "asnAgentNotifyStateChanged":
				return OperationIDs.OPID_asnAgentNotifyStateChanged;
			case "asnAgentNotifyBlockedRTCChanged":
				return OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged;
			default:
				return undefined;
		}
	}

	// [PrintTSROSEConstructor]
	/**
	 * Constructs the invoke and oninvoke object targeting all the ROSE related parts.
	 *
	 * @param transport - The transport is the connection to the other side. It takes care of delivering the invoke
	 * to us as well as to send invokes and events to the other side. It also holds the logger.
	 * @param handleEvents - Set this to true if you want to receive events or false if the stub should cached them
	 * until you call dispatchEvents();
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public constructor(transport: IASN1Transport, handleEvents: boolean, handler?: Partial<IENetUC_AgentROSE_Handler>) {
		super(transport, handleEvents);

		this.logFilter = [];

		if (handler)
			this.setHandler(handler);
	}

	// [PrintTSROSESetHandler]
	/**
	 * Sets the handler and registers the operations with it
	 *
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public setHandler(handler: Partial<IENetUC_AgentROSE_Handler>): void {
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentMonitorStart, "asnAgentMonitorStart");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentMonitorStop, "asnAgentMonitorStop");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentLogin, "asnAgentLogin");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentLogoff, "asnAgentLogoff");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentSetState, "asnAgentSetState");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentNotifyGroupsChanged, "asnAgentNotifyGroupsChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentNotifyStateChanged, "asnAgentNotifyStateChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged, "asnAgentNotifyBlockedRTCChanged");
		this.transport.registerModuleVersion("ENetUC_Agent", 8, 0);
	}

	// [PrintTSROSEInvokeMethods]

	// [PrintTSROSEInvokeMethod]
	/**
	 * Agent Monitor Start
	 * This function starts monitoring for all groups of a client.
	 * The individual lines (for PBX ACD groups) and the individual user and group configurations are taken into account (for business card\/contact portal).
	 *
	 * @param argument - An AsnAgentMonitorStartArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnAgentMonitorStartResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnAgentMonitorStart(argument: ENetUC_Agent.AsnAgentMonitorStartArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_Agent.AsnAgentMonitorStartResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_Agent.AsnAgentMonitorStartResult, OperationIDs.OPID_asnAgentMonitorStart, "asnAgentMonitorStart", Converter.AsnAgentMonitorStartArgument_Converter, Converter.AsnAgentMonitorStartResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Agent Monitor Stop
	 * End monitoring for the specified CrossRefID
	 *
	 * @param argument - An AsnAgentMonitorStopArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnAgentMonitorStopResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnAgentMonitorStop(argument: ENetUC_Agent.AsnAgentMonitorStopArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_Agent.AsnAgentMonitorStopResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_Agent.AsnAgentMonitorStopResult, OperationIDs.OPID_asnAgentMonitorStop, "asnAgentMonitorStop", Converter.AsnAgentMonitorStopArgument_Converter, Converter.AsnAgentMonitorStopResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Login for the agent\/ACD functionality on a line or group.
	 * This function ensures that the user is logged in to the agent or ACD group.
	 *
	 * @param argument - An AsnAgentLoginArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnAgentLoginResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnAgentLogin(argument: ENetUC_Agent.AsnAgentLoginArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_Agent.AsnAgentLoginResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_Agent.AsnAgentLoginResult, OperationIDs.OPID_asnAgentLogin, "asnAgentLogin", Converter.AsnAgentLoginArgument_Converter, Converter.AsnAgentLoginResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Logoff agent for ACD(Automatic Call Distribution)
	 *
	 * @param argument - An AsnAgentLogoffArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnAgentLogoffResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnAgentLogoff(argument: ENetUC_Agent.AsnAgentLogoffArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_Agent.AsnAgentLogoffResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_Agent.AsnAgentLogoffResult, OperationIDs.OPID_asnAgentLogoff, "asnAgentLogoff", Converter.AsnAgentLogoffArgument_Converter, Converter.AsnAgentLogoffResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Agent for setting the ACD status (call distribution)
	 * ACD means Automatic Call Distribution and is a system for the automated control of incoming and outgoing customer interactions,
	 * such as calls, faxes and e-mails
	 *
	 * @param argument - An AsnAgentSetStateArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnAgentSetStateResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnAgentSetState(argument: ENetUC_Agent.AsnAgentSetStateArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_Agent.AsnAgentSetStateResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_Agent.AsnAgentSetStateResult, OperationIDs.OPID_asnAgentSetState, "asnAgentSetState", Converter.AsnAgentSetStateArgument_Converter, Converter.AsnAgentSetStateResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * The event for changes to the user's agent groups.
	 * The entire list of the user's agent groups is always transmitted.
	 * Groups may have been removed or added, or the properties of a group may have changed.
	 * This event is not used for AgentState changes
	 *
	 * @param argument - An AsnAgentNotifyGroupsChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnAgentNotifyGroupsChanged(argument: ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnAgentNotifyGroupsChanged, "asnAgentNotifyGroupsChanged", Converter.AsnAgentNotifyGroupsChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event when the state of the agent in a group has changed.
	 *
	 * @param argument - An AsnAgentNotifyStateChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnAgentNotifyStateChanged(argument: ENetUC_Agent.AsnAgentNotifyStateChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnAgentNotifyStateChanged, "asnAgentNotifyStateChanged", Converter.AsnAgentNotifyStateChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event dispatched if blocked state was changed for anonymous user
	 * The argument contains all anonymous user URIs which are currently blocked for the notified agent
	 *
	 * @param argument - An AsnAgentNotifyBlockedRTCChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnAgentNotifyBlockedRTCChanged(argument: ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged, "asnAgentNotifyBlockedRTCChanged", Converter.AsnAgentNotifyBlockedRTCChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEOnInvokeswitchCase]
	/**
	 * This is the central onInvoke method that is called whenever a method of this module is called.
	 * Based on the operationID we step into the decoding of the method argument and call the method in the handler.
	 * The result is then again encoded and send to the other side.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the metho in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled, ROSEResult for the invoke result, ROSEError for an error or undefined if an event was called
	 */
	public async onInvoke(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_AgentROSE_Handler): Promise<ROSEReject | ROSEResult | ROSEError | undefined> {
		switch (invoke.operationID) {
			case OperationIDs.OPID_asnAgentMonitorStart:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnAgentMonitorStart, ENetUC_Agent.AsnAgentMonitorStartArgument, Converter.AsnAgentMonitorStartArgument_Converter, Converter.AsnAgentMonitorStartResult_Converter, handler, handler.onInvoke_asnAgentMonitorStart, invokeContext);
			case OperationIDs.OPID_asnAgentMonitorStop:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnAgentMonitorStop, ENetUC_Agent.AsnAgentMonitorStopArgument, Converter.AsnAgentMonitorStopArgument_Converter, Converter.AsnAgentMonitorStopResult_Converter, handler, handler.onInvoke_asnAgentMonitorStop, invokeContext);
			case OperationIDs.OPID_asnAgentLogin:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnAgentLogin, ENetUC_Agent.AsnAgentLoginArgument, Converter.AsnAgentLoginArgument_Converter, Converter.AsnAgentLoginResult_Converter, handler, handler.onInvoke_asnAgentLogin, invokeContext);
			case OperationIDs.OPID_asnAgentLogoff:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnAgentLogoff, ENetUC_Agent.AsnAgentLogoffArgument, Converter.AsnAgentLogoffArgument_Converter, Converter.AsnAgentLogoffResult_Converter, handler, handler.onInvoke_asnAgentLogoff, invokeContext);
			case OperationIDs.OPID_asnAgentSetState:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnAgentSetState, ENetUC_Agent.AsnAgentSetStateArgument, Converter.AsnAgentSetStateArgument_Converter, Converter.AsnAgentSetStateResult_Converter, handler, handler.onInvoke_asnAgentSetState, invokeContext);
			case OperationIDs.OPID_asnAgentNotifyGroupsChanged:
			case OperationIDs.OPID_asnAgentNotifyStateChanged:
			case OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged:
				return this.onEvent(invoke, invokeContext, handler);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_AgentROSE`);
		}
	}

	// [PrintTSROSEOnEventSwitchCase]
	/**
	 * This is the onEvent method that is called whenever an event is called in this module.
	 * It is called from the onInvoke in case of an event is being called.
	 * Depending on the handleEvents flag the event is either handled or cached.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the method in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled or undefined
	 */
	private async onEvent(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_AgentROSE_Handler): Promise<ROSEReject | undefined> {
		// If the class says do not handle events and the override flag in the invokeContext has not been set, add the event to the que, otherwise we dispatch it
		if (!this.handleEvents && !invokeContext?.handleEvent) {
			this.transport.log(ELogSeverity.debug, "Adding event to queue", "onEvent", this, { operationName: invoke.operationName, operationID: invoke.operationID });
			this.cachedEvents.push({ invoke, invokeContext, handler });
			return;
		}

		switch (invoke.operationID) {
			case OperationIDs.OPID_asnAgentNotifyGroupsChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnAgentNotifyGroupsChanged, ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument, Converter.AsnAgentNotifyGroupsChangedArgument_Converter, handler, handler.onEvent_asnAgentNotifyGroupsChanged, invokeContext);
			case OperationIDs.OPID_asnAgentNotifyStateChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnAgentNotifyStateChanged, ENetUC_Agent.AsnAgentNotifyStateChangedArgument, Converter.AsnAgentNotifyStateChangedArgument_Converter, handler, handler.onEvent_asnAgentNotifyStateChanged, invokeContext);
			case OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnAgentNotifyBlockedRTCChanged, ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument, Converter.AsnAgentNotifyBlockedRTCChangedArgument_Converter, handler, handler.onEvent_asnAgentNotifyBlockedRTCChanged, invokeContext);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_AgentROSE`);
		}
	}
}
