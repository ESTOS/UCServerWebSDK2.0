// [PrintTSROSEHeader]
/**
 * ENetUC_PresenceV2ROSE
 * "UC-Server-Access-Protocol-PresenceV2" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
// [PrintTSROSEImports]
// Global imports
import { IENetUC_PresenceV2ROSE, IENetUC_PresenceV2ROSE_Handler } from "./ENetUC_PresenceV2ROSE_Interface";
import { ROSEError, ROSEInvoke, ROSEReject, ROSEResult } from "./SNACCROSE";
import { AsnInvokeProblem, AsnInvokeProblemEnum, createInvokeReject, IASN1Transport, IASN1LogData, IReceiveInvokeContext, IInvokeHandler, ELogSeverity, ROSEBase } from "./TSROSEBase";
import { ISendInvokeContextParams } from "./TSInvokeContext";
// Local imports
import * as ENetUC_PresenceV2 from "./ENetUC_PresenceV2";
import * as Converter from "./ENetUC_PresenceV2_Converter";
// [PrintTSImports]
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
import * as ENetUC_Common_Appointments from "./ENetUC_Common_Appointments";
import * as ENetUC_ClientCapabilities from "./ENetUC_ClientCapabilities";
import * as ENetROSEInterface from "./ENetROSEInterface";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_AsnContact_Converter from "./ENetUC_Common_AsnContact_Converter";
import * as ENetUC_Common_Appointments_Converter from "./ENetUC_Common_Appointments_Converter";
import * as ENetUC_ClientCapabilities_Converter from "./ENetUC_ClientCapabilities_Converter";
import * as ENetROSEInterface_Converter from "./ENetROSEInterface_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_PresenceV2ROSE";
export const MODULE_LASTCHANGE = "2024-09-16T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240916;
export const MODULE_VERSION = "8.0.20240916";

// [PrintTSROSEOperationDefines]
export enum OperationIDs {
	OPID_asnUpdatePresenceV2 = 4504,
	OPID_asnRemovePresence = 4501,
	OPID_asnGetAndSubscribePresenceV2 = 4505,
	OPID_asnUnsubscribePresence = 4503,
	OPID_asnSetDynamicRights = 4510,
	OPID_asnRemoveDynamicRights = 4511,
	OPID_asnRequestLargeProfileImage = 1601,
	OPID_asnRequestContactImage = 1602
}

// [PrintTSROSEModuleComment]
/**
 * Presence interface (Version 2)
 * ## Module description
 * This module defines structures and operations for the presence V2 interface.
 * A version 2 of the presence interface was necessary to improve the amount of contact and service data.
 * The presence shows at any time the current availability of the person you wish to communicate with. For a detailed description see the help of the UCClient.
 * The following presence states are available:
 * - Available (green)
 * - Busy (red)
 * - Absent (yellow)
 * - Inactive (green\/yellow)
 * - Don't disturb  (red with a white stripe)
 * - Offline (gray)
 *
 * Additionally the API delivers information in form of contact data, service states and much more.
 * With all these infromations, it is possible to create an application, which give user the ability to see a detailed picture of a contact enriched with live state changes.
 *
 * The live changes are results of the different services the UCServer combines the presence state of the user:
 * - Telephone (via CTI)
 * - Calendar
 * - Audio\/Video
 * - Softphone
 * - Bluetooth device (locally attached to a client of the user).
 * - Manual input of the user
 *
 * ## Prerequisite for using the interface
 * - The client needs a socket for secure data Transmission between client-server and vise versa.
 * - Installation of ProCall Software in advance
 * - Then create a user for testing purposes
 * - login in this user name and check the functionality of this interface practically
 *
 *
 * ## Functionalities
 * - The status for client will be driven from various sources like:
 * - Digital Telephone, Mobile, Calender(ms outlook), Audio\/Video Chat, Manually changing Status and Computer system(login\/logout).
 * - The user has the permission to manually change the status
 * - The user can set a user-defined status (ex: Coffee Break)
 * - The user can set a couple of notices (ex: listing the daily appointments)
 * - The user can change status and notice
 * - The user can remove status and notice
 *
 *
 * ## Events
 * The Events that the client receives from the server are:
 *
 * \\- **[asnUpdatePresence(V2)](PresenceV2.asnUpdatePresence.html)** :
 * - It delivers the responses from Server to Client as per Client request
 * - The Server receives the specific request like [asnCustomNote](Common.type.AsnCustomNote.html) from Client
 * - The Client reciprocally receives an [asnUpdatePresence(V2)](PresenceV2.asnUpdatePresence.html) from Server
 * - The Update-Event will also be sent to those clients who are in touch with this client in the same Server
 * - It receives the Event from server in two forms whether an Argument or an Error
 * - As Argument: It handles the **Presence** and **iChangedFlags** events
 * \\- [Presence](PresenceV2.type.AsnUpdatePresenceArgument.html) : it shows updated data of the present-contact.
 * \\- [iChangedFlags](PresenceV2.type.AsnUpdatePresenceArgument.html) : it indicates that which area triggers the event and it's included because later on the server fills the fields
 * \\** check the [AsnPresence](PresenceV2.type.AsnPresence.html)(Active details) for more details
 *
 * \\- **[asnRemovePresence](PresenceV2.asnRemovePresence.html)** :
 * - It needs a contact id to remove the presence state
 * - It has an optionalParams for further implementation
 *
 * ## How the API works
 * Here is a very simple diagram of how the presence API works
 * UML section is not exported to this file!
 */

// [PrintTSROSEClass]
export class ENetUC_PresenceV2ROSE extends ROSEBase implements IInvokeHandler, IENetUC_PresenceV2ROSE {
	/**
	 * Contains the attributes that have to be filtered from logging
	 * Use logfilter property;property inside the asn1 root comments to specify this list
	 */
	public readonly logFilter: string[];

	/**
	 * The Loggers getLogData callback (used in all the log methods called in this class, add the classname to every log entry)
	 *
	 * @returns - an ILogData log data object provided additional data for all the logger calls in this class
	 */
	public getLogData(): IASN1LogData {
		return {
			className: MODULE_NAME
		};
	}

	/**
	 * Returns the operationName for an operationID
	 *
	 * @param id - the id we want to have the name for
	 * @returns - the name or undefined if not found
	 */
	public getNameForOperationID(id: OperationIDs): string | undefined {
		switch (id) {
			case OperationIDs.OPID_asnUpdatePresenceV2:
				return "asnUpdatePresenceV2";
			case OperationIDs.OPID_asnRemovePresence:
				return "asnRemovePresence";
			case OperationIDs.OPID_asnGetAndSubscribePresenceV2:
				return "asnGetAndSubscribePresenceV2";
			case OperationIDs.OPID_asnUnsubscribePresence:
				return "asnUnsubscribePresence";
			case OperationIDs.OPID_asnSetDynamicRights:
				return "asnSetDynamicRights";
			case OperationIDs.OPID_asnRemoveDynamicRights:
				return "asnRemoveDynamicRights";
			case OperationIDs.OPID_asnRequestLargeProfileImage:
				return "asnRequestLargeProfileImage";
			case OperationIDs.OPID_asnRequestContactImage:
				return "asnRequestContactImage";
			default:
				return undefined;
		}
	}

	/**
	 * Returns the operationID for an operationName
	 *
	 * @param name - the name we want to have the id for
	 * @returns - the id or undefined if not found
	 */
	public getIDForOperationName(name: string): OperationIDs | undefined {
		switch (name) {
			case "asnUpdatePresenceV2":
				return OperationIDs.OPID_asnUpdatePresenceV2;
			case "asnRemovePresence":
				return OperationIDs.OPID_asnRemovePresence;
			case "asnGetAndSubscribePresenceV2":
				return OperationIDs.OPID_asnGetAndSubscribePresenceV2;
			case "asnUnsubscribePresence":
				return OperationIDs.OPID_asnUnsubscribePresence;
			case "asnSetDynamicRights":
				return OperationIDs.OPID_asnSetDynamicRights;
			case "asnRemoveDynamicRights":
				return OperationIDs.OPID_asnRemoveDynamicRights;
			case "asnRequestLargeProfileImage":
				return OperationIDs.OPID_asnRequestLargeProfileImage;
			case "asnRequestContactImage":
				return OperationIDs.OPID_asnRequestContactImage;
			default:
				return undefined;
		}
	}

	// [PrintTSROSEConstructor]
	/**
	 * Constructs the invoke and oninvoke object targeting all the ROSE related parts.
	 *
	 * @param transport - The transport is the connection to the other side. It takes care of delivering the invoke
	 * to us as well as to send invokes and events to the other side. It also holds the logger.
	 * @param handleEvents - Set this to true if you want to receive events or false if the stub should cached them
	 * until you call dispatchEvents();
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public constructor(transport: IASN1Transport, handleEvents: boolean, handler?: Partial<IENetUC_PresenceV2ROSE_Handler>) {
		super(transport, handleEvents);

		this.logFilter = [];

		if (handler)
			this.setHandler(handler);
	}

	// [PrintTSROSESetHandler]
	/**
	 * Sets the handler and registers the operations with it
	 *
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public setHandler(handler: Partial<IENetUC_PresenceV2ROSE_Handler>): void {
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnUpdatePresenceV2, "asnUpdatePresenceV2");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRemovePresence, "asnRemovePresence");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnGetAndSubscribePresenceV2, "asnGetAndSubscribePresenceV2");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnUnsubscribePresence, "asnUnsubscribePresence");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnSetDynamicRights, "asnSetDynamicRights");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRemoveDynamicRights, "asnRemoveDynamicRights");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRequestLargeProfileImage, "asnRequestLargeProfileImage");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRequestContactImage, "asnRequestContactImage");
		this.transport.registerModuleVersion("ENetUC_PresenceV2", 8, 1726444800);
	}

	// [PrintTSROSEInvokeMethods]

	// [PrintTSROSEInvokeMethod]
	/**
	 * Operation to retrieve contact data and to subscribe to events when these data will change.
	 * If a client is interested in monitoring the presence and data of its own and other contacts, this operation
	 * gives the possibility to get data about a contact, its used services (lines, appointments, chat etc.) and his calculated presence. See AsnGetAndSubscribePresenceArgument for more information.
	 *
	 * To unsubscribe from contacts, call asnUnsubscribePresence. This is highly recommended before closing the connection to the ucserver.
	 *
	 * If the operation fails it will return AsnRequestError.
	 *
	 * If the operation is successful at least on some given contacts, it will return AsnGetAndSubscribePresenceResult.
	 *
	 * @param argument - An AsnGetAndSubscribePresenceArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnGetAndSubscribePresenceV2Result, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnGetAndSubscribePresenceV2(argument: ENetUC_PresenceV2.AsnGetAndSubscribePresenceArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_PresenceV2.AsnGetAndSubscribePresenceV2Result | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_PresenceV2.AsnGetAndSubscribePresenceV2Result, OperationIDs.OPID_asnGetAndSubscribePresenceV2, "asnGetAndSubscribePresenceV2", Converter.AsnGetAndSubscribePresenceArgument_Converter, Converter.AsnGetAndSubscribePresenceV2Result_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Operation to end subscriptions on contacts on the ucserver.
	 * To stop getting events from contacts on the ucserver this operation is called with the list contact IDs of these contacts.
	 *
	 * If the operation is executes successful, it will return the result AsnUnsubscribePresenceResult.
	 *
	 * If an error occured, AsnRequestError will be returned.
	 *
	 * @param argument - An AsnUnsubscribePresenceArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnUnsubscribePresenceResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnUnsubscribePresence(argument: ENetUC_PresenceV2.AsnUnsubscribePresenceArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_PresenceV2.AsnUnsubscribePresenceResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_PresenceV2.AsnUnsubscribePresenceResult, OperationIDs.OPID_asnUnsubscribePresence, "asnUnsubscribePresence", Converter.AsnUnsubscribePresenceArgument_Converter, Converter.AsnUnsubscribePresenceResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Operation to set access rights for another contact on contact data and contcat service information.
	 * This operation is used to grant access rights (or changing them) to other users (contacts) on contact informations and service states of this contact.
	 *
	 * **Note**: The access rights in the ucserver are always a sum of the global, group and personal right lists and what they grant. So removing specific rights with this
	 * operation has no effect if the same rights are granted through global or group rights.
	 *
	 * If the operation was executed successfully the result AsnSetDynamicRightsResult is returned.
	 *
	 * If an error occured, AsnRequestError is returned.
	 *
	 * **The access rights list**&lt;br \/&gt;
	 * If a client wants to receive contact data, its logged in contact (= user) has to have access rights granted by the other user to him.
	 * Each user of the ucserver has a list of access rights she gives other users. If someone is in this list, he can see contact data
	 * and\/or service states of the user depending on the rights level granted.
	 *
	 * The list can be modified by asnSetDynamicRights and asnRemoveDynamicRights.
	 *
	 * **Contact rights challenge**&lt;br \/&gt;
	 * In conjunction with the access rights list is the mechanic of the \"contact rights challenge\".&lt;br \/&gt;
	 * To get on the access list of another user, the user must request such rights from him or will get them through administrative configuration.
	 * If there is no administrative configuration the other user will be \"challenged\" to grant or deny rights to the user.
	 * This process is started as soon as a user (challenger) requests the ucserver by calling asnGetAndSubscribePresence on another users ContactID (challengee).
	 * The ucserver checks if there are already given rights and if not, the challenged user gets a new entry in his challenge request list, which then will be
	 * dispatched to all of his clients. These clients should now prompt the user to accept or deny the request and the result will be saved in his access rights list.
	 * On the other side, the challenger will get data and service status after some time or not. There is no extra notification if the challenge was answered or not.
	 *
	 * @param argument - An AsnSetDynamicRightsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnSetDynamicRightsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnSetDynamicRights(argument: ENetUC_PresenceV2.AsnSetDynamicRightsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_PresenceV2.AsnSetDynamicRightsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_PresenceV2.AsnSetDynamicRightsResult, OperationIDs.OPID_asnSetDynamicRights, "asnSetDynamicRights", Converter.AsnSetDynamicRightsArgument_Converter, Converter.AsnSetDynamicRightsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * This operation is used for removing access rights to contact data and service states between contacts.
	 * If a client wants to remove access rights to contact data and service states between contacts, asnRemoveDynamicRights has to be called.
	 *
	 * Removing access rights will remove an entry in the access rights list of the contact who grants the rights. This means, that
	 * 'remote contact' (see. AsnRemoveDynamicRightsArgument) has the chance to request new rights again.
	 *
	 * In order to prevent the 'remote contact' to request new rights, the contact should be blocked
	 * (setting user right 'blocked'). See asnSetDynamicRights for more details.
	 *
	 * @param argument - An AsnRemoveDynamicRightsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnRemoveDynamicRightsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnRemoveDynamicRights(argument: ENetUC_PresenceV2.AsnRemoveDynamicRightsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_PresenceV2.AsnRemoveDynamicRightsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_PresenceV2.AsnRemoveDynamicRightsResult, OperationIDs.OPID_asnRemoveDynamicRights, "asnRemoveDynamicRights", Converter.AsnRemoveDynamicRightsArgument_Converter, Converter.AsnRemoveDynamicRightsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Request an large image of a contact.
	 * With the operation asnRequestLargeProfileImage can request a large image of a contact. The large
	 * image can be optionally configured by the administrator additionally to the 'normal' small image in order to provide a
	 * higher resolution image of the contact for special purposes (like LiveChat client).
	 * Like with asnRequestContactImage, this operation is used to get or check the image from the server and the server can
	 * determine the need to provide a new image to the client using the given hash value.
	 *
	 * @param argument - An AsnRequestLargeProfileImageArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnRequestLargeProfileImageResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnRequestLargeProfileImage(argument: ENetUC_PresenceV2.AsnRequestLargeProfileImageArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_PresenceV2.AsnRequestLargeProfileImageResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_PresenceV2.AsnRequestLargeProfileImageResult, OperationIDs.OPID_asnRequestLargeProfileImage, "asnRequestLargeProfileImage", Converter.AsnRequestLargeProfileImageArgument_Converter, Converter.AsnRequestLargeProfileImageResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Request an image of a contact
	 * This operation requests the normal (or 'small') Image of a contact. The caller sends
	 * a known hash of an already existing image to the server, so that the server can determine
	 * that the client get the stored image (the hash is not equal) or reponds to the client, that the image has not changed (hash is equal).
	 * If there is no image, no image is returned.
	 *
	 * @param argument - An AsnRequestContactImageArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnRequestContactImageResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnRequestContactImage(argument: ENetUC_PresenceV2.AsnRequestContactImageArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_PresenceV2.AsnRequestContactImageResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_PresenceV2.AsnRequestContactImageResult, OperationIDs.OPID_asnRequestContactImage, "asnRequestContactImage", Converter.AsnRequestContactImageArgument_Converter, Converter.AsnRequestContactImageResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server to the client about presence updates
	 * This event is fired from the server if the client has subscribed by asnGetAndSubscribePresence on a contact (=user).
	 * It contains the new presence state and other data which has changed.
	 *
	 * @param argument - An AsnUpdatePresenceV2Argument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnUpdatePresenceV2(argument: ENetUC_PresenceV2.AsnUpdatePresenceV2Argument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnUpdatePresenceV2, "asnUpdatePresenceV2", Converter.AsnUpdatePresenceV2Argument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server tzhat the contact has been removed from the presence system.
	 * This event will be sent to clients when a contact is removed from the presence system of the ucserver.
	 * Mostly by removing or deactivating the contact in the user management system.
	 *
	 * @param argument - An AsnRemovePresenceArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnRemovePresence(argument: ENetUC_PresenceV2.AsnRemovePresenceArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnRemovePresence, "asnRemovePresence", Converter.AsnRemovePresenceArgument_Converter, invokeContext);
	}

	// [PrintTSROSEOnInvokeswitchCase]
	/**
	 * This is the central onInvoke method that is called whenever a method of this module is called.
	 * Based on the operationID we step into the decoding of the method argument and call the method in the handler.
	 * The result is then again encoded and send to the other side.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the metho in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled, ROSEResult for the invoke result, ROSEError for an error or undefined if an event was called
	 */
	public async onInvoke(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_PresenceV2ROSE_Handler): Promise<ROSEReject | ROSEResult | ROSEError | undefined> {
		switch (invoke.operationID) {
			case OperationIDs.OPID_asnGetAndSubscribePresenceV2:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnGetAndSubscribePresenceV2, ENetUC_PresenceV2.AsnGetAndSubscribePresenceArgument, Converter.AsnGetAndSubscribePresenceArgument_Converter, Converter.AsnGetAndSubscribePresenceV2Result_Converter, handler, handler.onInvoke_asnGetAndSubscribePresenceV2, invokeContext);
			case OperationIDs.OPID_asnUnsubscribePresence:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnUnsubscribePresence, ENetUC_PresenceV2.AsnUnsubscribePresenceArgument, Converter.AsnUnsubscribePresenceArgument_Converter, Converter.AsnUnsubscribePresenceResult_Converter, handler, handler.onInvoke_asnUnsubscribePresence, invokeContext);
			case OperationIDs.OPID_asnSetDynamicRights:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnSetDynamicRights, ENetUC_PresenceV2.AsnSetDynamicRightsArgument, Converter.AsnSetDynamicRightsArgument_Converter, Converter.AsnSetDynamicRightsResult_Converter, handler, handler.onInvoke_asnSetDynamicRights, invokeContext);
			case OperationIDs.OPID_asnRemoveDynamicRights:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnRemoveDynamicRights, ENetUC_PresenceV2.AsnRemoveDynamicRightsArgument, Converter.AsnRemoveDynamicRightsArgument_Converter, Converter.AsnRemoveDynamicRightsResult_Converter, handler, handler.onInvoke_asnRemoveDynamicRights, invokeContext);
			case OperationIDs.OPID_asnRequestLargeProfileImage:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnRequestLargeProfileImage, ENetUC_PresenceV2.AsnRequestLargeProfileImageArgument, Converter.AsnRequestLargeProfileImageArgument_Converter, Converter.AsnRequestLargeProfileImageResult_Converter, handler, handler.onInvoke_asnRequestLargeProfileImage, invokeContext);
			case OperationIDs.OPID_asnRequestContactImage:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnRequestContactImage, ENetUC_PresenceV2.AsnRequestContactImageArgument, Converter.AsnRequestContactImageArgument_Converter, Converter.AsnRequestContactImageResult_Converter, handler, handler.onInvoke_asnRequestContactImage, invokeContext);
			case OperationIDs.OPID_asnUpdatePresenceV2:
			case OperationIDs.OPID_asnRemovePresence:
				return this.onEvent(invoke, invokeContext, handler);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_PresenceV2ROSE`);
		}
	}

	// [PrintTSROSEOnEventSwitchCase]
	/**
	 * This is the onEvent method that is called whenever an event is called in this module.
	 * It is called from the onInvoke in case of an event is being called.
	 * Depending on the handleEvents flag the event is either handled or cached.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the method in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled or undefined
	 */
	private async onEvent(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_PresenceV2ROSE_Handler): Promise<ROSEReject | undefined> {
		// If the class says do not handle events and the override flag in the invokeContext has not been set, add the event to the que, otherwise we dispatch it
		if (!this.handleEvents && !invokeContext?.handleEvent) {
			this.transport.log(ELogSeverity.debug, "Adding event to queue", "onEvent", this, { operationName: invoke.operationName, operationID: invoke.operationID });
			this.cachedEvents.push({ invoke, invokeContext, handler });
			return;
		}

		switch (invoke.operationID) {
			case OperationIDs.OPID_asnUpdatePresenceV2:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnUpdatePresenceV2, ENetUC_PresenceV2.AsnUpdatePresenceV2Argument, Converter.AsnUpdatePresenceV2Argument_Converter, handler, handler.onEvent_asnUpdatePresenceV2, invokeContext);
			case OperationIDs.OPID_asnRemovePresence:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnRemovePresence, ENetUC_PresenceV2.AsnRemovePresenceArgument, Converter.AsnRemovePresenceArgument_Converter, handler, handler.onEvent_asnRemovePresence, invokeContext);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_PresenceV2ROSE`);
		}
	}
}
