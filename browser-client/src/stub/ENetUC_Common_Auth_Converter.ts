// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Common_Auth_Converter.ts
 * "UC-Server-Access-Protocol-AuthCommon" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Common_Auth from "./ENetUC_Common_Auth";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Common_Auth_Converter";
export const MODULE_LASTCHANGE = "2024-09-12T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240912;
export const MODULE_VERSION = "8.0.20240912";

// [PrintTSEncoderDecoderCode]
export class AsnAuthBasicCredential_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnAuthBasicCredential, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnAuthBasicCredential & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthBasicCredential");

		const t = {} as ENetUC_Common_Auth.AsnAuthBasicCredential & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAuthBasicCredential";
		TSConverter.fillJSONParam(s, t, "credential", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAuthBasicCredential"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthBasicCredential | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthBasicCredential");

		let t: ENetUC_Common_Auth.AsnAuthBasicCredential | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnAuthBasicCredential>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnAuthBasicCredential["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "credential", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAuthBasicCredential"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnAuthBasicCredential | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAuthBasicCredential";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthBasicCredential");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "credential", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.credential, name: "credential" }));
		}

		if (errors.validateResult(newContext, "AsnAuthBasicCredential"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthBasicCredential | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthBasicCredential");

		let t: ENetUC_Common_Auth.AsnAuthBasicCredential | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnAuthBasicCredential.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnAuthBasicCredential["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "credential", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAuthBasicCredential"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAuthNTLMCredential_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnAuthNTLMCredential, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnAuthNTLMCredential & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthNTLMCredential");

		const t = {} as ENetUC_Common_Auth.AsnAuthNTLMCredential & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAuthNTLMCredential";
		TSConverter.fillJSONParam(s, t, "authdata", "Uint8Array", errors, newContext);

		if (errors.validateResult(newContext, "AsnAuthNTLMCredential"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthNTLMCredential | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthNTLMCredential");

		let t: ENetUC_Common_Auth.AsnAuthNTLMCredential | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnAuthNTLMCredential>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnAuthNTLMCredential["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "authdata", "string", errors, newContext, false))
				t.authdata = TSConverter.decode64(s.authdata as unknown as string);
		}

		if (errors.validateResult(newContext, "AsnAuthNTLMCredential"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnAuthNTLMCredential | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAuthNTLMCredential";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthNTLMCredential");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "authdata", "Uint8Array", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.authdata, name: "authdata" }));
		}

		if (errors.validateResult(newContext, "AsnAuthNTLMCredential"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthNTLMCredential | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthNTLMCredential");

		let t: ENetUC_Common_Auth.AsnAuthNTLMCredential | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnAuthNTLMCredential.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnAuthNTLMCredential["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "authdata", "OctetString", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAuthNTLMCredential"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAuthKerberosCredential_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnAuthKerberosCredential, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnAuthKerberosCredential & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthKerberosCredential");

		const t = {} as ENetUC_Common_Auth.AsnAuthKerberosCredential & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAuthKerberosCredential";
		TSConverter.fillJSONParam(s, t, "authdata", "Uint8Array", errors, newContext);

		if (errors.validateResult(newContext, "AsnAuthKerberosCredential"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthKerberosCredential | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthKerberosCredential");

		let t: ENetUC_Common_Auth.AsnAuthKerberosCredential | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnAuthKerberosCredential>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnAuthKerberosCredential["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "authdata", "string", errors, newContext, false))
				t.authdata = TSConverter.decode64(s.authdata as unknown as string);
		}

		if (errors.validateResult(newContext, "AsnAuthKerberosCredential"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnAuthKerberosCredential | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAuthKerberosCredential";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthKerberosCredential");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "authdata", "Uint8Array", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.authdata, name: "authdata" }));
		}

		if (errors.validateResult(newContext, "AsnAuthKerberosCredential"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthKerberosCredential | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthKerberosCredential");

		let t: ENetUC_Common_Auth.AsnAuthKerberosCredential | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnAuthKerberosCredential.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnAuthKerberosCredential["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "authdata", "OctetString", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAuthKerberosCredential"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAuthBearer_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnAuthBearer, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnAuthBearer & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthBearer");

		const t = {} as ENetUC_Common_Auth.AsnAuthBearer & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAuthBearer";
		TSConverter.fillJSONParam(s, t, "u8sJWT", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAuthBearer"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthBearer | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthBearer");

		let t: ENetUC_Common_Auth.AsnAuthBearer | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnAuthBearer>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnAuthBearer["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sJWT", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAuthBearer"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnAuthBearer | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAuthBearer";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthBearer");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sJWT", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sJWT, name: "u8sJWT" }));
		}

		if (errors.validateResult(newContext, "AsnAuthBearer"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthBearer | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthBearer");

		let t: ENetUC_Common_Auth.AsnAuthBearer | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnAuthBearer.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnAuthBearer["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sJWT", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAuthBearer"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAuthOpenIDC_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnAuthOpenIDC, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnAuthOpenIDC & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthOpenIDC");

		const t = {} as ENetUC_Common_Auth.AsnAuthOpenIDC & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAuthOpenIDC";
		TSConverter.fillJSONParam(s, t, "u8sScope", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sIDToken", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnAuthOpenIDC"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthOpenIDC | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthOpenIDC");

		let t: ENetUC_Common_Auth.AsnAuthOpenIDC | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnAuthOpenIDC>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnAuthOpenIDC["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sScope", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sIDToken", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnAuthOpenIDC"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnAuthOpenIDC | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAuthOpenIDC";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthOpenIDC");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sScope", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sIDToken", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (s.u8sScope !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sScope, name: "u8sScope", idBlock: { optionalID: 0 } }));
			if (s.u8sIDToken !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sIDToken, name: "u8sIDToken", idBlock: { optionalID: 1 } }));
		}

		if (errors.validateResult(newContext, "AsnAuthOpenIDC"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthOpenIDC | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthOpenIDC");

		let t: ENetUC_Common_Auth.AsnAuthOpenIDC | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnAuthOpenIDC.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnAuthOpenIDC["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sScope", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sIDToken", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnAuthOpenIDC"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAuthDigestParams_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnAuthDigestParams, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnAuthDigestParams & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthDigestParams");

		const t = {} as ENetUC_Common_Auth.AsnAuthDigestParams & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAuthDigestParams";
		TSConverter.fillJSONParam(s, t, "nonce", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "opaque", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "qop", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "algorithm", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "realm", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnAuthDigestParams"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthDigestParams | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthDigestParams");

		let t: ENetUC_Common_Auth.AsnAuthDigestParams | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnAuthDigestParams>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnAuthDigestParams["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "nonce", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "opaque", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "qop", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "algorithm", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "realm", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnAuthDigestParams"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnAuthDigestParams | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAuthDigestParams";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAuthDigestParams");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "nonce", "string", errors, newContext);
		TSConverter.validateParam(s, "opaque", "string", errors, newContext);
		TSConverter.validateParam(s, "qop", "string", errors, newContext);
		TSConverter.validateParam(s, "algorithm", "string", errors, newContext, true);
		TSConverter.validateParam(s, "realm", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.nonce, name: "nonce" }));
			t.push(new asn1ts.Utf8String({ value: s.opaque, name: "opaque" }));
			t.push(new asn1ts.Utf8String({ value: s.qop, name: "qop" }));
			if (s.algorithm !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.algorithm, name: "algorithm", idBlock: { optionalID: 0 } }));
			if (s.realm !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.realm, name: "realm", idBlock: { optionalID: 1 } }));
		}

		if (errors.validateResult(newContext, "AsnAuthDigestParams"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnAuthDigestParams | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAuthDigestParams");

		let t: ENetUC_Common_Auth.AsnAuthDigestParams | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnAuthDigestParams.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnAuthDigestParams["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "nonce", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "opaque", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "qop", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "algorithm", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "realm", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnAuthDigestParams"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2Token_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2Token, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2Token & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2Token");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2Token & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2Token";
		if (s.u8sJwt != null)
			TSConverter.fillJSONParam(s, t, "u8sJwt", "string", errors, newContext);
		else if (s.u8sToken != null)
			TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnLoginV2Token"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2Token | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2Token");

		let t: ENetUC_Common_Auth.AsnLoginV2Token | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2Token>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2Token["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.u8sJwt !== undefined) {
				if (TSConverter.validateParam(s, "u8sJwt", "string", errors, newContext))
					t.u8sJwt = s.u8sJwt;
			} else if (s.u8sToken !== undefined) {
				if (TSConverter.validateParam(s, "u8sToken", "string", errors, newContext))
					t.u8sToken = s.u8sToken;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnLoginV2Token"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2Token | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnLoginV2Token";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2Token");

		// [Print_BER_EncoderChoiceDefCode]
		if (TSConverter.validateParam(s, "u8sJwt", "string", errors, newContext, true))
			t = new asn1ts.Utf8String({ value: s.u8sJwt, name: "u8sJwt", idBlock: { optionalID: 0 } });
		else if (TSConverter.validateParam(s, "u8sToken", "string", errors, newContext, true))
			t = new asn1ts.Utf8String({ value: s.u8sToken, name: "u8sToken", idBlock: { optionalID: 1 } });
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnLoginV2Token"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2Token | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2Token");

		let t: ENetUC_Common_Auth.AsnLoginV2Token | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2Token.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2Token["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "u8sJwt" && asn1ts.Utf8String.typeGuard(s)) {
				const _u8sJwt = s.getValue();
				if (TSConverter.validateParamType(_u8sJwt, "u8sJwt", "string", errors, newContext, false))
					t.u8sJwt = _u8sJwt;
			} else if (s.choiceName === "u8sToken" && asn1ts.Utf8String.typeGuard(s)) {
				const _u8sToken = s.getValue();
				if (TSConverter.validateParamType(_u8sToken, "u8sToken", "string", errors, newContext, false))
					t.u8sToken = _u8sToken;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnLoginV2Token"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2ResultServerRedirect_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultServerRedirect");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2ResultServerRedirect";
		TSConverter.fillJSONParam(s, t, "u8sRedirectTo", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerRedirect"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultServerRedirect");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sRedirectTo", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerRedirect"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2ResultServerRedirect";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultServerRedirect");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sRedirectTo", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sRedirectTo, name: "u8sRedirectTo" }));
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerRedirect"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultServerRedirect");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultServerRedirect["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sRedirectTo", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerRedirect"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2ResultServerBusy_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2ResultServerBusy, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2ResultServerBusy & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultServerBusy");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2ResultServerBusy & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2ResultServerBusy";
		TSConverter.fillJSONParam(s, t, "iRetryInSeconds", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerBusy"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultServerBusy | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultServerBusy");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultServerBusy | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2ResultServerBusy>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultServerBusy["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iRetryInSeconds", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerBusy"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2ResultServerBusy | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2ResultServerBusy";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultServerBusy");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iRetryInSeconds", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iRetryInSeconds, name: "iRetryInSeconds" }));
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerBusy"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultServerBusy | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultServerBusy");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultServerBusy | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2ResultServerBusy.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultServerBusy["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iRetryInSeconds", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultServerBusy"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2ResultRenegotiateNTLM_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultRenegotiateNTLM");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2ResultRenegotiateNTLM";
		TSConverter.fillJSONParam(s, t, "authdata", "Uint8Array", errors, newContext);

		if (errors.validateResult(newContext, "AsnLoginV2ResultRenegotiateNTLM"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultRenegotiateNTLM");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "authdata", "string", errors, newContext, false))
				t.authdata = TSConverter.decode64(s.authdata as unknown as string);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultRenegotiateNTLM"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2ResultRenegotiateNTLM";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultRenegotiateNTLM");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "authdata", "Uint8Array", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.authdata, name: "authdata" }));
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultRenegotiateNTLM"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultRenegotiateNTLM");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultRenegotiateNTLM["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "authdata", "OctetString", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultRenegotiateNTLM"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2ChoiceArgument_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2ChoiceArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2ChoiceArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ChoiceArgument");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2ChoiceArgument & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2ChoiceArgument";
		if (s.authBasic != null) {
			const _authBasic = AsnAuthBasicCredential_Converter.toJSON(s.authBasic, errors, newContext, "authBasic");
			if (_authBasic)
				t.authBasic = _authBasic;
		} else if (s.authNTLM != null) {
			const _authNTLM = AsnAuthNTLMCredential_Converter.toJSON(s.authNTLM, errors, newContext, "authNTLM");
			if (_authNTLM)
				t.authNTLM = _authNTLM;
		} else if (s.authKerberos != null) {
			const _authKerberos = AsnAuthKerberosCredential_Converter.toJSON(s.authKerberos, errors, newContext, "authKerberos");
			if (_authKerberos)
				t.authKerberos = _authKerberos;
		} else if (s.authBearer != null) {
			const _authBearer = AsnAuthBearer_Converter.toJSON(s.authBearer, errors, newContext, "authBearer");
			if (_authBearer)
				t.authBearer = _authBearer;
		} else if (s.authOpenIDC != null) {
			const _authOpenIDC = AsnAuthOpenIDC_Converter.toJSON(s.authOpenIDC, errors, newContext, "authOpenIDC");
			if (_authOpenIDC)
				t.authOpenIDC = _authOpenIDC;
		} else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnLoginV2ChoiceArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ChoiceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ChoiceArgument");

		let t: ENetUC_Common_Auth.AsnLoginV2ChoiceArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2ChoiceArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ChoiceArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.authBasic !== undefined)
				t.authBasic = AsnAuthBasicCredential_Converter.fromJSON(s.authBasic, errors, newContext, "authBasic", false);
			else if (s.authNTLM !== undefined)
				t.authNTLM = AsnAuthNTLMCredential_Converter.fromJSON(s.authNTLM, errors, newContext, "authNTLM", false);
			else if (s.authKerberos !== undefined)
				t.authKerberos = AsnAuthKerberosCredential_Converter.fromJSON(s.authKerberos, errors, newContext, "authKerberos", false);
			else if (s.authBearer !== undefined)
				t.authBearer = AsnAuthBearer_Converter.fromJSON(s.authBearer, errors, newContext, "authBearer", false);
			else if (s.authOpenIDC !== undefined)
				t.authOpenIDC = AsnAuthOpenIDC_Converter.fromJSON(s.authOpenIDC, errors, newContext, "authOpenIDC", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnLoginV2ChoiceArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2ChoiceArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnLoginV2ChoiceArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ChoiceArgument");

		// [Print_BER_EncoderChoiceDefCode]
		if (s.authBasic)
			t = AsnAuthBasicCredential_Converter.toBER(s.authBasic, errors, newContext, "authBasic", 0);
		else if (s.authNTLM)
			t = AsnAuthNTLMCredential_Converter.toBER(s.authNTLM, errors, newContext, "authNTLM", 2);
		else if (s.authKerberos)
			t = AsnAuthKerberosCredential_Converter.toBER(s.authKerberos, errors, newContext, "authKerberos", 3);
		else if (s.authBearer)
			t = AsnAuthBearer_Converter.toBER(s.authBearer, errors, newContext, "authBearer", 4);
		else if (s.authOpenIDC)
			t = AsnAuthOpenIDC_Converter.toBER(s.authOpenIDC, errors, newContext, "authOpenIDC", 5);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnLoginV2ChoiceArgument"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ChoiceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ChoiceArgument");

		let t: ENetUC_Common_Auth.AsnLoginV2ChoiceArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2ChoiceArgument.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ChoiceArgument["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "authBasic" && asn1ts.Sequence.typeGuard(s))
				t.authBasic = AsnAuthBasicCredential_Converter.fromBER(s, undefined, newContext, "authbasic", false);
			else if (s.choiceName === "authNTLM" && asn1ts.Sequence.typeGuard(s))
				t.authNTLM = AsnAuthNTLMCredential_Converter.fromBER(s, undefined, newContext, "authntlm", false);
			else if (s.choiceName === "authKerberos" && asn1ts.Sequence.typeGuard(s))
				t.authKerberos = AsnAuthKerberosCredential_Converter.fromBER(s, undefined, newContext, "authkerberos", false);
			else if (s.choiceName === "authBearer" && asn1ts.Sequence.typeGuard(s))
				t.authBearer = AsnAuthBearer_Converter.fromBER(s, undefined, newContext, "authbearer", false);
			else if (s.choiceName === "authOpenIDC" && asn1ts.Sequence.typeGuard(s))
				t.authOpenIDC = AsnAuthOpenIDC_Converter.fromBER(s, undefined, newContext, "authopenidc", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnLoginV2ChoiceArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2SupportedAuthMethods_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2SupportedAuthMethods");

		const t = [] as ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const se of s) {
			if (TSConverter.validateParamType(se, "AsnLoginV2SupportedAuthMethods", "number", errors, newContext, false))
				t.push(se);
		}

		if (errors.validateResult(newContext, "AsnLoginV2SupportedAuthMethods"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2SupportedAuthMethods");

		let t: ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const se of s) {
				if (TSConverter.validateParamType(se, "AsnLoginV2SupportedAuthMethods", "number", errors, newContext, false))
					t.push(se);
			}
		}

		if (errors.validateResult(newContext, "AsnLoginV2SupportedAuthMethods"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2SupportedAuthMethods";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2SupportedAuthMethods");

		// [Print_BER_EncoderSetOfDefCode]
		for (const se of s) {
			if (TSConverter.validateParamType(se, "AsnLoginV2SupportedAuthMethods", "number", errors, newContext, false))
				t.push(new asn1ts.Enumerated({ value: se }));
		}

		if (errors.validateResult(newContext, "AsnLoginV2SupportedAuthMethods"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2SupportedAuthMethods");

		let t: ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Common_Auth.AsnLoginV2SupportedAuthMethods();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Enumerated.typeGuard(se)) {
					const value = se.getValue();
					if (TSConverter.validateParamType(value, "AsnLoginV2SupportedAuthMethods", "number", errors, newContext, false))
						t.push(value);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnLoginV2SupportedAuthMethods"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2ResultSupportedAuthMethods_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultSupportedAuthMethods");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2ResultSupportedAuthMethods";
		const _authMethodsOrdered = AsnLoginV2SupportedAuthMethods_Converter.toJSON(s.authMethodsOrdered, errors, newContext, "authMethodsOrdered");
		if (_authMethodsOrdered)
			t.authMethodsOrdered = _authMethodsOrdered;
		if (s.authDigest) {
			const _authDigest = AsnAuthDigestParams_Converter.toJSON(s.authDigest, errors, newContext, "authDigest");
			if (_authDigest)
				t.authDigest = _authDigest;
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSupportedAuthMethods"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultSupportedAuthMethods");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _authmethodsordered = AsnLoginV2SupportedAuthMethods_Converter.fromJSON(s.authMethodsOrdered, errors, newContext, "authMethodsOrdered", false);
			if (_authmethodsordered)
				t.authMethodsOrdered = _authmethodsordered;
			const _authdigest = AsnAuthDigestParams_Converter.fromJSON(s.authDigest, errors, newContext, "authDigest", true);
			if (_authdigest)
				t.authDigest = _authdigest;
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSupportedAuthMethods"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2ResultSupportedAuthMethods";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultSupportedAuthMethods");

		// [Print_BER_EncoderSeqDefCode]
		const _authMethodsOrdered = AsnLoginV2SupportedAuthMethods_Converter.toBER(s.authMethodsOrdered, errors, newContext, "authMethodsOrdered");
		const _authDigest = AsnAuthDigestParams_Converter.toBER(s.authDigest, errors, newContext, "authDigest", 0);
		if (!errors.hasNewErrors()) {
			if (_authMethodsOrdered)
				t.push(_authMethodsOrdered);
			if (_authDigest)
				t.push(_authDigest);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSupportedAuthMethods"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultSupportedAuthMethods");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultSupportedAuthMethods["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _authmethodsordered = AsnLoginV2SupportedAuthMethods_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "authMethodsOrdered"), errors, newContext, "authMethodsOrdered");
			if (_authmethodsordered)
				t.authMethodsOrdered = _authmethodsordered;
			t.authDigest = AsnAuthDigestParams_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "authDigest"), errors, newContext, "authDigest", true);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSupportedAuthMethods"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2ResultSuccess_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2ResultSuccess, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2ResultSuccess & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultSuccess");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2ResultSuccess & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2ResultSuccess";
		TSConverter.fillJSONParam(s, t, "u8sLoggedInUser", "string", errors, newContext, true);
		if (s.token) {
			const _token = AsnLoginV2Token_Converter.toJSON(s.token, errors, newContext, "token");
			if (_token)
				t.token = _token;
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSuccess"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultSuccess | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultSuccess");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultSuccess | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2ResultSuccess>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultSuccess["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLoggedInUser", "string", errors, newContext, true);
			const _token = AsnLoginV2Token_Converter.fromJSON(s.token, errors, newContext, "token", true);
			if (_token)
				t.token = _token;
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSuccess"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2ResultSuccess | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2ResultSuccess";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2ResultSuccess");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLoggedInUser", "string", errors, newContext, true);
		const _token = AsnLoginV2Token_Converter.toBER(s.token, errors, newContext, "token", 1);
		if (!errors.hasNewErrors()) {
			if (s.u8sLoggedInUser !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sLoggedInUser, name: "u8sLoggedInUser", idBlock: { optionalID: 0 } }));
			if (_token)
				t.push(_token);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSuccess"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2ResultSuccess | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2ResultSuccess");

		let t: ENetUC_Common_Auth.AsnLoginV2ResultSuccess | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2ResultSuccess.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnLoginV2ResultSuccess["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLoggedInUser", "Utf8String", errors, newContext, true);
			t.token = AsnLoginV2Token_Converter.fromBER(s.getValueByName("token"), errors, newContext, "token", true);
		}

		if (errors.validateResult(newContext, "AsnLoginV2ResultSuccess"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2Argument_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2Argument");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2Argument";
		if (s.auth) {
			const _auth = AsnLoginV2ChoiceArgument_Converter.toJSON(s.auth, errors, newContext, "auth");
			if (_auth)
				t.auth = _auth;
		}

		if (errors.validateResult(newContext, "AsnLoginV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2Argument");

		let t: ENetUC_Common_Auth.AsnLoginV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _auth = AsnLoginV2ChoiceArgument_Converter.fromJSON(s.auth, errors, newContext, "auth", true);
			if (_auth)
				t.auth = _auth;
		}

		if (errors.validateResult(newContext, "AsnLoginV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLoginV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		const _auth = AsnLoginV2ChoiceArgument_Converter.toBER(s.auth, errors, newContext, "auth", 0);
		if (!errors.hasNewErrors()) {
			if (_auth)
				t.push(_auth);
		}

		if (errors.validateResult(newContext, "AsnLoginV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2Argument");

		let t: ENetUC_Common_Auth.AsnLoginV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_Auth.AsnLoginV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			t.auth = AsnLoginV2ChoiceArgument_Converter.fromBER(s.getValueByName("auth"), errors, newContext, "auth", true);
		}

		if (errors.validateResult(newContext, "AsnLoginV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLoginV2Result_Converter {
	public static toJSON(s: ENetUC_Common_Auth.AsnLoginV2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_Auth.AsnLoginV2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2Result");

		const t = {} as ENetUC_Common_Auth.AsnLoginV2Result & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLoginV2Result";
		if (s.supportedAuthMethods != null) {
			const _supportedAuthMethods = AsnLoginV2ResultSupportedAuthMethods_Converter.toJSON(s.supportedAuthMethods, errors, newContext, "supportedAuthMethods");
			if (_supportedAuthMethods)
				t.supportedAuthMethods = _supportedAuthMethods;
		} else if (s.succceeded != null) {
			const _succceeded = AsnLoginV2ResultSuccess_Converter.toJSON(s.succceeded, errors, newContext, "succceeded");
			if (_succceeded)
				t.succceeded = _succceeded;
		} else if (s.serverRedirect != null) {
			const _serverRedirect = AsnLoginV2ResultServerRedirect_Converter.toJSON(s.serverRedirect, errors, newContext, "serverRedirect");
			if (_serverRedirect)
				t.serverRedirect = _serverRedirect;
		} else if (s.serverBusy != null) {
			const _serverBusy = AsnLoginV2ResultServerBusy_Converter.toJSON(s.serverBusy, errors, newContext, "serverBusy");
			if (_serverBusy)
				t.serverBusy = _serverBusy;
		} else if (s.ntlmRenegotiate != null) {
			const _ntlmRenegotiate = AsnLoginV2ResultRenegotiateNTLM_Converter.toJSON(s.ntlmRenegotiate, errors, newContext, "ntlmRenegotiate");
			if (_ntlmRenegotiate)
				t.ntlmRenegotiate = _ntlmRenegotiate;
		} else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnLoginV2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2Result");

		let t: ENetUC_Common_Auth.AsnLoginV2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_Auth.AsnLoginV2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.supportedAuthMethods !== undefined)
				t.supportedAuthMethods = AsnLoginV2ResultSupportedAuthMethods_Converter.fromJSON(s.supportedAuthMethods, errors, newContext, "supportedAuthMethods", false);
			else if (s.succceeded !== undefined)
				t.succceeded = AsnLoginV2ResultSuccess_Converter.fromJSON(s.succceeded, errors, newContext, "succceeded", false);
			else if (s.serverRedirect !== undefined)
				t.serverRedirect = AsnLoginV2ResultServerRedirect_Converter.fromJSON(s.serverRedirect, errors, newContext, "serverRedirect", false);
			else if (s.serverBusy !== undefined)
				t.serverBusy = AsnLoginV2ResultServerBusy_Converter.fromJSON(s.serverBusy, errors, newContext, "serverBusy", false);
			else if (s.ntlmRenegotiate !== undefined)
				t.ntlmRenegotiate = AsnLoginV2ResultRenegotiateNTLM_Converter.fromJSON(s.ntlmRenegotiate, errors, newContext, "ntlmRenegotiate", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnLoginV2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_Auth.AsnLoginV2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnLoginV2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLoginV2Result");

		// [Print_BER_EncoderChoiceDefCode]
		if (s.supportedAuthMethods)
			t = AsnLoginV2ResultSupportedAuthMethods_Converter.toBER(s.supportedAuthMethods, errors, newContext, "supportedAuthMethods", 0);
		else if (s.succceeded)
			t = AsnLoginV2ResultSuccess_Converter.toBER(s.succceeded, errors, newContext, "succceeded", 1);
		else if (s.serverRedirect)
			t = AsnLoginV2ResultServerRedirect_Converter.toBER(s.serverRedirect, errors, newContext, "serverRedirect", 2);
		else if (s.serverBusy)
			t = AsnLoginV2ResultServerBusy_Converter.toBER(s.serverBusy, errors, newContext, "serverBusy", 3);
		else if (s.ntlmRenegotiate)
			t = AsnLoginV2ResultRenegotiateNTLM_Converter.toBER(s.ntlmRenegotiate, errors, newContext, "ntlmRenegotiate", 4);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnLoginV2Result"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_Auth.AsnLoginV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLoginV2Result");

		let t: ENetUC_Common_Auth.AsnLoginV2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_Auth.AsnLoginV2Result.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_Auth.AsnLoginV2Result["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "supportedAuthMethods" && asn1ts.Sequence.typeGuard(s))
				t.supportedAuthMethods = AsnLoginV2ResultSupportedAuthMethods_Converter.fromBER(s, undefined, newContext, "supportedauthmethods", false);
			else if (s.choiceName === "succceeded" && asn1ts.Sequence.typeGuard(s))
				t.succceeded = AsnLoginV2ResultSuccess_Converter.fromBER(s, undefined, newContext, "succceeded", false);
			else if (s.choiceName === "serverRedirect" && asn1ts.Sequence.typeGuard(s))
				t.serverRedirect = AsnLoginV2ResultServerRedirect_Converter.fromBER(s, undefined, newContext, "serverredirect", false);
			else if (s.choiceName === "serverBusy" && asn1ts.Sequence.typeGuard(s))
				t.serverBusy = AsnLoginV2ResultServerBusy_Converter.fromBER(s, undefined, newContext, "serverbusy", false);
			else if (s.choiceName === "ntlmRenegotiate" && asn1ts.Sequence.typeGuard(s))
				t.ntlmRenegotiate = AsnLoginV2ResultRenegotiateNTLM_Converter.fromBER(s, undefined, newContext, "ntlmrenegotiate", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnLoginV2Result"))
			return t;

		return undefined;
	}
}
