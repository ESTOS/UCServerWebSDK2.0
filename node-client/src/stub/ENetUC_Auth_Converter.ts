// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Auth_Converter.ts
 * "UC-Server-Access-Protocol-Auth" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Auth from "./ENetUC_Auth";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
import * as ENetUC_Common_Auth from "./ENetUC_Common_Auth";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
import * as ENetUC_Common_AsnContact_Converter from "./ENetUC_Common_AsnContact_Converter";
import * as ENetUC_Common_Auth_Converter from "./ENetUC_Common_Auth_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Auth_Converter";
export const MODULE_LASTCHANGE = "2024-08-21T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240821;
export const MODULE_VERSION = "8.0.20240821";

// [PrintTSEncoderDecoderCode]
export class AsnAdminLoginChoice_Converter {
	public static toJSON(s: ENetUC_Auth.AsnAdminLoginChoice, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnAdminLoginChoice & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAdminLoginChoice");

		const t = {} as ENetUC_Auth.AsnAdminLoginChoice & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAdminLoginChoice";
		if (s.u8sAdminPassword != null)
			TSConverter.fillJSONParam(s, t, "u8sAdminPassword", "string", errors, newContext);
		else if (s.u8sAdminPasswordCrypted != null)
			TSConverter.fillJSONParam(s, t, "u8sAdminPasswordCrypted", "string", errors, newContext);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnAdminLoginChoice"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnAdminLoginChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAdminLoginChoice");

		let t: ENetUC_Auth.AsnAdminLoginChoice | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnAdminLoginChoice>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnAdminLoginChoice["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.u8sAdminPassword !== undefined) {
				if (TSConverter.validateParam(s, "u8sAdminPassword", "string", errors, newContext))
					t.u8sAdminPassword = s.u8sAdminPassword;
			} else if (s.u8sAdminPasswordCrypted !== undefined) {
				if (TSConverter.validateParam(s, "u8sAdminPasswordCrypted", "string", errors, newContext))
					t.u8sAdminPasswordCrypted = s.u8sAdminPasswordCrypted;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnAdminLoginChoice"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnAdminLoginChoice | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnAdminLoginChoice";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAdminLoginChoice");

		// [Print_BER_EncoderChoiceDefCode]
		if (TSConverter.validateParam(s, "u8sAdminPassword", "string", errors, newContext, true))
			t = new asn1ts.Utf8String({ value: s.u8sAdminPassword, name: "u8sAdminPassword", idBlock: { optionalID: 0 } });
		else if (TSConverter.validateParam(s, "u8sAdminPasswordCrypted", "string", errors, newContext, true))
			t = new asn1ts.Utf8String({ value: s.u8sAdminPasswordCrypted, name: "u8sAdminPasswordCrypted", idBlock: { optionalID: 1 } });
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnAdminLoginChoice"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnAdminLoginChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAdminLoginChoice");

		let t: ENetUC_Auth.AsnAdminLoginChoice | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnAdminLoginChoice.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnAdminLoginChoice["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "u8sAdminPassword" && asn1ts.Utf8String.typeGuard(s)) {
				const _u8sAdminPassword = s.getValue();
				if (TSConverter.validateParamType(_u8sAdminPassword, "u8sAdminPassword", "string", errors, newContext, false))
					t.u8sAdminPassword = _u8sAdminPassword;
			} else if (s.choiceName === "u8sAdminPasswordCrypted" && asn1ts.Utf8String.typeGuard(s)) {
				const _u8sAdminPasswordCrypted = s.getValue();
				if (TSConverter.validateParamType(_u8sAdminPasswordCrypted, "u8sAdminPasswordCrypted", "string", errors, newContext, false))
					t.u8sAdminPasswordCrypted = _u8sAdminPasswordCrypted;
			} else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnAdminLoginChoice"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionAnonymousDataArgument_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataArgument");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionAnonymousDataArgument";
		TSConverter.fillJSONParam(s, t, "u8sHintData", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataArgument");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sHintData", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateServerConnectionAnonymousDataArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sHintData", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sToken", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sHintData, name: "u8sHintData" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sToken, name: "u8sToken" }));
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataArgument");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sHintData", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sToken", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionAnonymousDataResult_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataResult");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionAnonymousDataResult";
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataResult");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateServerConnectionAnonymousDataResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sToken", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sToken, name: "u8sToken" }));
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionAnonymousDataResult");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionAnonymousDataResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sToken", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionAnonymousDataResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionV2ServerBusy_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2ServerBusy");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionV2ServerBusy";
		TSConverter.fillJSONParam(s, t, "iServerBusyTimeout", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ServerBusy"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2ServerBusy");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iServerBusyTimeout", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ServerBusy"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateServerConnectionV2ServerBusy";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2ServerBusy");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iServerBusyTimeout", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iServerBusyTimeout, name: "iServerBusyTimeout" }));
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ServerBusy"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2ServerBusy");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2ServerBusy["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iServerBusyTimeout", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ServerBusy"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion";
		TSConverter.fillJSONParam(s, t, "u8sServerInterfaceVersion", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sServerInterfaceVersion", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sServerInterfaceVersion", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sServerInterfaceVersion, name: "u8sServerInterfaceVersion" }));
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sServerInterfaceVersion", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLogoffArgument_Converter {
	public static toJSON(s: ENetUC_Auth.AsnLogoffArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnLogoffArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLogoffArgument");

		const t = {} as ENetUC_Auth.AsnLogoffArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLogoffArgument";

		if (errors.validateResult(newContext, "AsnLogoffArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnLogoffArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLogoffArgument");

		let t: ENetUC_Auth.AsnLogoffArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnLogoffArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnLogoffArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnLogoffArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnLogoffArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLogoffArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLogoffArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnLogoffArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnLogoffArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLogoffArgument");

		let t: ENetUC_Auth.AsnLogoffArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnLogoffArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnLogoffArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnLogoffArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetUserTokenV2Result_Converter {
	public static toJSON(s: ENetUC_Auth.AsnGetUserTokenV2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnGetUserTokenV2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserTokenV2Result");

		const t = {} as ENetUC_Auth.AsnGetUserTokenV2Result & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetUserTokenV2Result";
		TSConverter.fillJSONParam(s, t, "sToken", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnGetUserTokenV2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetUserTokenV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserTokenV2Result");

		let t: ENetUC_Auth.AsnGetUserTokenV2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnGetUserTokenV2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnGetUserTokenV2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "sToken", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenV2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnGetUserTokenV2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetUserTokenV2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserTokenV2Result");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "sToken", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.sToken, name: "sToken" }));
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenV2Result"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetUserTokenV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserTokenV2Result");

		let t: ENetUC_Auth.AsnGetUserTokenV2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnGetUserTokenV2Result.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnGetUserTokenV2Result["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "sToken", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenV2Result"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnProfileAttribute_Converter {
	public static toJSON(s: ENetUC_Auth.AsnProfileAttribute, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnProfileAttribute & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnProfileAttribute");

		const t = {} as ENetUC_Auth.AsnProfileAttribute & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnProfileAttribute";
		TSConverter.fillJSONParam(s, t, "u8sServiceType", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8seName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sValue", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnProfileAttribute"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnProfileAttribute | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnProfileAttribute");

		let t: ENetUC_Auth.AsnProfileAttribute | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnProfileAttribute>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnProfileAttribute["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sServiceType", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8seName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sValue", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnProfileAttribute"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnProfileAttribute | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnProfileAttribute";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnProfileAttribute");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sServiceType", "string", errors, newContext);
		TSConverter.validateParam(s, "u8seName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sValue", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sServiceType, name: "u8sServiceType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8seName, name: "u8seName" }));
			if (s.u8sValue !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sValue, name: "u8sValue", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnProfileAttribute"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnProfileAttribute | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnProfileAttribute");

		let t: ENetUC_Auth.AsnProfileAttribute | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnProfileAttribute.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnProfileAttribute["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sServiceType", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8seName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sValue", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnProfileAttribute"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetLoggedInContactArgument_Converter {
	public static toJSON(s: ENetUC_Auth.AsnGetLoggedInContactArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnGetLoggedInContactArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLoggedInContactArgument");

		const t = {} as ENetUC_Auth.AsnGetLoggedInContactArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetLoggedInContactArgument";

		if (errors.validateResult(newContext, "AsnGetLoggedInContactArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetLoggedInContactArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLoggedInContactArgument");

		let t: ENetUC_Auth.AsnGetLoggedInContactArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnGetLoggedInContactArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnGetLoggedInContactArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnGetLoggedInContactArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnGetLoggedInContactArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetLoggedInContactArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLoggedInContactArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnGetLoggedInContactArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetLoggedInContactArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLoggedInContactArgument");

		let t: ENetUC_Auth.AsnGetLoggedInContactArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnGetLoggedInContactArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnGetLoggedInContactArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnGetLoggedInContactArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetLoggedInContactV2Result_Converter {
	public static toJSON(s: ENetUC_Auth.AsnGetLoggedInContactV2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnGetLoggedInContactV2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLoggedInContactV2Result");

		const t = {} as ENetUC_Auth.AsnGetLoggedInContactV2Result & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetLoggedInContactV2Result";
		TSConverter.fillJSONParam(s, t, "u8sLoggedInUser", "string", errors, newContext);
		const _ownContact = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.toJSON(s.ownContact, errors, newContext, "ownContact");
		if (_ownContact)
			t.ownContact = _ownContact;

		if (errors.validateResult(newContext, "AsnGetLoggedInContactV2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetLoggedInContactV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLoggedInContactV2Result");

		let t: ENetUC_Auth.AsnGetLoggedInContactV2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnGetLoggedInContactV2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnGetLoggedInContactV2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLoggedInUser", "string", errors, newContext, false);
			const _owncontact = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.fromJSON(s.ownContact, errors, newContext, "ownContact", false);
			if (_owncontact)
				t.ownContact = _owncontact;
		}

		if (errors.validateResult(newContext, "AsnGetLoggedInContactV2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnGetLoggedInContactV2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetLoggedInContactV2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLoggedInContactV2Result");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLoggedInUser", "string", errors, newContext);
		const _ownContact = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.toBER(s.ownContact, errors, newContext, "ownContact");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLoggedInUser, name: "u8sLoggedInUser" }));
			if (_ownContact)
				t.push(_ownContact);
		}

		if (errors.validateResult(newContext, "AsnGetLoggedInContactV2Result"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetLoggedInContactV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLoggedInContactV2Result");

		let t: ENetUC_Auth.AsnGetLoggedInContactV2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnGetLoggedInContactV2Result.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnGetLoggedInContactV2Result["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLoggedInUser", "Utf8String", errors, newContext);
			const _owncontact = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "ownContact"), errors, newContext, "ownContact");
			if (_owncontact)
				t.ownContact = _owncontact;
		}

		if (errors.validateResult(newContext, "AsnGetLoggedInContactV2Result"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionV2Argument_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2Argument");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionV2Argument";
		TSConverter.fillJSONParam(s, t, "u8sMinSupportedInterfaceVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMaxSupportedInterfaceVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientDeviceId", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eClientAppID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientDeviceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iClientCapabilities", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConnectionGUID", "string", errors, newContext, true);
		if (s.eAnonymousLogin) {
			const _eAnonymousLogin = AsnNegotiateServerConnectionAnonymousDataArgument_Converter.toJSON(s.eAnonymousLogin, errors, newContext, "eAnonymousLogin");
			if (_eAnonymousLogin)
				t.eAnonymousLogin = _eAnonymousLogin;
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2Argument");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMinSupportedInterfaceVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMaxSupportedInterfaceVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientDeviceId", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "eClientAppID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientDeviceName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iClientCapabilities", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConnectionGUID", "string", errors, newContext, true);
			const _eanonymouslogin = AsnNegotiateServerConnectionAnonymousDataArgument_Converter.fromJSON(s.eAnonymousLogin, errors, newContext, "eAnonymousLogin", true);
			if (_eanonymouslogin)
				t.eAnonymousLogin = _eanonymouslogin;
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateServerConnectionV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMinSupportedInterfaceVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMaxSupportedInterfaceVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sClientDeviceId", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sClientVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "eClientAppID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sClientDeviceName", "string", errors, newContext);
		TSConverter.validateParam(s, "iClientCapabilities", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConnectionGUID", "string", errors, newContext, true);
		const _eAnonymousLogin = AsnNegotiateServerConnectionAnonymousDataArgument_Converter.toBER(s.eAnonymousLogin, errors, newContext, "eAnonymousLogin", 1);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMinSupportedInterfaceVersion, name: "u8sMinSupportedInterfaceVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMaxSupportedInterfaceVersion, name: "u8sMaxSupportedInterfaceVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientDeviceId, name: "u8sClientDeviceId" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientVersion, name: "u8sClientVersion" }));
			t.push(new asn1ts.Enumerated({ value: s.eClientAppID, name: "eClientAppID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientDeviceName, name: "u8sClientDeviceName" }));
			t.push(new asn1ts.Integer({ value: s.iClientCapabilities, name: "iClientCapabilities" }));
			if (s.u8sConnectionGUID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sConnectionGUID, name: "u8sConnectionGUID", idBlock: { optionalID: 0 } }));
			if (_eAnonymousLogin)
				t.push(_eAnonymousLogin);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2Argument");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMinSupportedInterfaceVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMaxSupportedInterfaceVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientDeviceId", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eClientAppID", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientDeviceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iClientCapabilities", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConnectionGUID", "Utf8String", errors, newContext, true);
			t.eAnonymousLogin = AsnNegotiateServerConnectionAnonymousDataArgument_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "eAnonymousLogin"), errors, newContext, "eAnonymousLogin", true);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionV2Result_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionV2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionV2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2Result");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionV2Result & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionV2Result";
		TSConverter.fillJSONParam(s, t, "eServerType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServerInterfaceVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eAuthenticationMethod", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "sServerAuthentication", "Uint8Array", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stServerTime", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServerVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConnectionGUID", "string", errors, newContext);
		const _u8sPresenceDomains = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sPresenceDomains, errors, newContext, "u8sPresenceDomains");
		if (_u8sPresenceDomains)
			t.u8sPresenceDomains = _u8sPresenceDomains;
		TSConverter.fillJSONParam(s, t, "iOEM", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sProductVersion", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bPresenceServicesDisabled", "boolean", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bUserUserRightsDisabled", "boolean", errors, newContext, true);
		if (s.eAnonymousDetails) {
			const _eAnonymousDetails = AsnNegotiateServerConnectionAnonymousDataResult_Converter.toJSON(s.eAnonymousDetails, errors, newContext, "eAnonymousDetails");
			if (_eAnonymousDetails)
				t.eAnonymousDetails = _eAnonymousDetails;
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2Result");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionV2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eServerType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServerInterfaceVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "eAuthenticationMethod", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "sServerAuthentication", "string", errors, newContext, false))
				t.sServerAuthentication = TSConverter.decode64(s.sServerAuthentication as unknown as string);
			if (TSConverter.validateParam(s, "stServerTime", "string", errors, newContext, false))
				t.stServerTime = new Date(s.stServerTime);
			TSConverter.fillJSONParam(s, t, "u8sServerVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConnectionGUID", "string", errors, newContext, false);
			const _u8spresencedomains = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sPresenceDomains, errors, newContext, "u8sPresenceDomains", false);
			if (_u8spresencedomains)
				t.u8sPresenceDomains = _u8spresencedomains;
			TSConverter.fillJSONParam(s, t, "iOEM", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sProductVersion", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bPresenceServicesDisabled", "boolean", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bUserUserRightsDisabled", "boolean", errors, newContext, true);
			const _eanonymousdetails = AsnNegotiateServerConnectionAnonymousDataResult_Converter.fromJSON(s.eAnonymousDetails, errors, newContext, "eAnonymousDetails", true);
			if (_eanonymousdetails)
				t.eAnonymousDetails = _eanonymousdetails;
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionV2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateServerConnectionV2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2Result");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eServerType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sServerInterfaceVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "eAuthenticationMethod", "number", errors, newContext);
		TSConverter.validateParam(s, "sServerAuthentication", "Uint8Array", errors, newContext);
		TSConverter.validateParam(s, "stServerTime", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sServerVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConnectionGUID", "string", errors, newContext);
		const _u8sPresenceDomains = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sPresenceDomains, errors, newContext, "u8sPresenceDomains");
		TSConverter.validateParam(s, "iOEM", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sProductVersion", "string", errors, newContext, true);
		TSConverter.validateParam(s, "bPresenceServicesDisabled", "boolean", errors, newContext, true);
		TSConverter.validateParam(s, "bUserUserRightsDisabled", "boolean", errors, newContext, true);
		const _eAnonymousDetails = AsnNegotiateServerConnectionAnonymousDataResult_Converter.toBER(s.eAnonymousDetails, errors, newContext, "eAnonymousDetails", 4);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Enumerated({ value: s.eServerType, name: "eServerType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServerInterfaceVersion, name: "u8sServerInterfaceVersion" }));
			t.push(new asn1ts.Enumerated({ value: s.eAuthenticationMethod, name: "eAuthenticationMethod" }));
			t.push(new asn1ts.OctetString({ valueHex: s.sServerAuthentication, name: "sServerAuthentication" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stServerTime), name: "stServerTime" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServerVersion, name: "u8sServerVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConnectionGUID, name: "u8sConnectionGUID" }));
			if (_u8sPresenceDomains)
				t.push(_u8sPresenceDomains);
			if (s.iOEM !== undefined)
				t.push(new asn1ts.Integer({ value: s.iOEM, name: "iOEM", idBlock: { optionalID: 0 } }));
			if (s.u8sProductVersion !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sProductVersion, name: "u8sProductVersion", idBlock: { optionalID: 1 } }));
			if (s.bPresenceServicesDisabled !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bPresenceServicesDisabled, name: "bPresenceServicesDisabled", idBlock: { optionalID: 2 } }));
			if (s.bUserUserRightsDisabled !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bUserUserRightsDisabled, name: "bUserUserRightsDisabled", idBlock: { optionalID: 3 } }));
			if (_eAnonymousDetails)
				t.push(_eAnonymousDetails);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Result"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2Result");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionV2Result.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2Result["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eServerType", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServerInterfaceVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eAuthenticationMethod", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "sServerAuthentication", "OctetString", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stServerTime", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServerVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConnectionGUID", "Utf8String", errors, newContext);
			const _u8spresencedomains = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sPresenceDomains"), errors, newContext, "u8sPresenceDomains");
			if (_u8spresencedomains)
				t.u8sPresenceDomains = _u8spresencedomains;
			TSConverter.fillASN1Param(s, t, "iOEM", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sProductVersion", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bPresenceServicesDisabled", "Boolean", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bUserUserRightsDisabled", "Boolean", errors, newContext, true);
			t.eAnonymousDetails = AsnNegotiateServerConnectionAnonymousDataResult_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "eAnonymousDetails"), errors, newContext, "eAnonymousDetails", true);
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2Result"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateServerConnectionV2ResultChoice_Converter {
	public static toJSON(s: ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2ResultChoice");

		const t = {} as ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateServerConnectionV2ResultChoice";
		if (s.result != null) {
			const _result = AsnNegotiateServerConnectionV2Result_Converter.toJSON(s.result, errors, newContext, "result");
			if (_result)
				t.result = _result;
		} else if (s.busy != null) {
			const _busy = AsnNegotiateServerConnectionV2ServerBusy_Converter.toJSON(s.busy, errors, newContext, "busy");
			if (_busy)
				t.busy = _busy;
		} else if (s.incompatible != null) {
			const _incompatible = AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion_Converter.toJSON(s.incompatible, errors, newContext, "incompatible");
			if (_incompatible)
				t.incompatible = _incompatible;
		} else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ResultChoice"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2ResultChoice");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.result !== undefined)
				t.result = AsnNegotiateServerConnectionV2Result_Converter.fromJSON(s.result, errors, newContext, "result", false);
			else if (s.busy !== undefined)
				t.busy = AsnNegotiateServerConnectionV2ServerBusy_Converter.fromJSON(s.busy, errors, newContext, "busy", false);
			else if (s.incompatible !== undefined)
				t.incompatible = AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion_Converter.fromJSON(s.incompatible, errors, newContext, "incompatible", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ResultChoice"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnNegotiateServerConnectionV2ResultChoice";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateServerConnectionV2ResultChoice");

		// [Print_BER_EncoderChoiceDefCode]
		if (s.result)
			t = AsnNegotiateServerConnectionV2Result_Converter.toBER(s.result, errors, newContext, "result", 0);
		else if (s.busy)
			t = AsnNegotiateServerConnectionV2ServerBusy_Converter.toBER(s.busy, errors, newContext, "busy", 1);
		else if (s.incompatible)
			t = AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion_Converter.toBER(s.incompatible, errors, newContext, "incompatible", 2);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ResultChoice"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateServerConnectionV2ResultChoice");

		let t: ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnNegotiateServerConnectionV2ResultChoice["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "result" && asn1ts.Sequence.typeGuard(s))
				t.result = AsnNegotiateServerConnectionV2Result_Converter.fromBER(s, undefined, newContext, "result", false);
			else if (s.choiceName === "busy" && asn1ts.Sequence.typeGuard(s))
				t.busy = AsnNegotiateServerConnectionV2ServerBusy_Converter.fromBER(s, undefined, newContext, "busy", false);
			else if (s.choiceName === "incompatible" && asn1ts.Sequence.typeGuard(s))
				t.incompatible = AsnNegotiateServerConnectionV2IncompatibleInterfaceVersion_Converter.fromBER(s, undefined, newContext, "incompatible", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnNegotiateServerConnectionV2ResultChoice"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAdminLogin_Converter {
	public static toJSON(s: ENetUC_Auth.AsnAdminLogin, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnAdminLogin & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAdminLogin");

		const t = {} as ENetUC_Auth.AsnAdminLogin & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAdminLogin";
		TSConverter.fillJSONParam(s, t, "u8sAdminUsername", "string", errors, newContext);
		const _adminPassword = AsnAdminLoginChoice_Converter.toJSON(s.adminPassword, errors, newContext, "adminPassword");
		if (_adminPassword)
			t.adminPassword = _adminPassword;

		if (errors.validateResult(newContext, "AsnAdminLogin"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnAdminLogin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAdminLogin");

		let t: ENetUC_Auth.AsnAdminLogin | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnAdminLogin>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnAdminLogin["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAdminUsername", "string", errors, newContext, false);
			const _adminpassword = AsnAdminLoginChoice_Converter.fromJSON(s.adminPassword, errors, newContext, "adminPassword", false);
			if (_adminpassword)
				t.adminPassword = _adminpassword;
		}

		if (errors.validateResult(newContext, "AsnAdminLogin"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnAdminLogin | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAdminLogin";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAdminLogin");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAdminUsername", "string", errors, newContext);
		const _adminPassword = AsnAdminLoginChoice_Converter.toBER(s.adminPassword, errors, newContext, "adminPassword");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAdminUsername, name: "u8sAdminUsername" }));
			if (_adminPassword)
				t.push(_adminPassword);
		}

		if (errors.validateResult(newContext, "AsnAdminLogin"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnAdminLogin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAdminLogin");

		let t: ENetUC_Auth.AsnAdminLogin | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnAdminLogin.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnAdminLogin["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAdminUsername", "Utf8String", errors, newContext);
			const _adminpassword = AsnAdminLoginChoice_Converter.fromBER(s.getValueByName("adminPassword"), errors, newContext, "adminPassword");
			if (_adminpassword)
				t.adminPassword = _adminpassword;
		}

		if (errors.validateResult(newContext, "AsnAdminLogin"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnProfileAttributeList_Converter {
	public static toJSON(s: ENetUC_Auth.AsnProfileAttributeList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnProfileAttributeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnProfileAttributeList");

		const t = [] as ENetUC_Auth.AsnProfileAttributeList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnProfileAttribute_Converter.toJSON(se, errors, newContext, "AsnProfileAttribute");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnProfileAttributeList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnProfileAttributeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnProfileAttributeList");

		let t: ENetUC_Auth.AsnProfileAttributeList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnProfileAttributeList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Auth.AsnProfileAttributeList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnProfileAttribute_Converter.fromJSON(se, errors, newContext, "AsnProfileAttribute", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnProfileAttributeList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnProfileAttributeList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnProfileAttributeList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnProfileAttributeList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnProfileAttribute_Converter.toBER(s[id], errors, newContext, "AsnProfileAttribute");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnProfileAttributeList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnProfileAttributeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnProfileAttributeList");

		let t: ENetUC_Auth.AsnProfileAttributeList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnProfileAttributeList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Auth.AsnProfileAttributeList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnProfileAttribute_Converter.fromBER(se, errors, newContext, "AsnProfileAttribute", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnProfileAttributeList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetUserTokenArgument_Converter {
	public static toJSON(s: ENetUC_Auth.AsnGetUserTokenArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Auth.AsnGetUserTokenArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserTokenArgument");

		const t = {} as ENetUC_Auth.AsnGetUserTokenArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetUserTokenArgument";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iTTL", "number", errors, newContext, true);
		if (s.lstServiceType) {
			const _lstServiceType = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.lstServiceType, errors, newContext, "lstServiceType");
			if (_lstServiceType)
				t.lstServiceType = _lstServiceType;
		}
		if (s.lstProfileAttributes) {
			const _lstProfileAttributes = AsnProfileAttributeList_Converter.toJSON(s.lstProfileAttributes, errors, newContext, "lstProfileAttributes");
			if (_lstProfileAttributes)
				t.lstProfileAttributes = _lstProfileAttributes;
		}
		if (s.adminLogin) {
			const _adminLogin = AsnAdminLogin_Converter.toJSON(s.adminLogin, errors, newContext, "adminLogin");
			if (_adminLogin)
				t.adminLogin = _adminLogin;
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetUserTokenArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserTokenArgument");

		let t: ENetUC_Auth.AsnGetUserTokenArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Auth.AsnGetUserTokenArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Auth.AsnGetUserTokenArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iTTL", "number", errors, newContext, true);
			const _lstservicetype = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.lstServiceType, errors, newContext, "lstServiceType", true);
			if (_lstservicetype)
				t.lstServiceType = _lstservicetype;
			const _lstprofileattributes = AsnProfileAttributeList_Converter.fromJSON(s.lstProfileAttributes, errors, newContext, "lstProfileAttributes", true);
			if (_lstprofileattributes)
				t.lstProfileAttributes = _lstprofileattributes;
			const _adminlogin = AsnAdminLogin_Converter.fromJSON(s.adminLogin, errors, newContext, "adminLogin", true);
			if (_adminlogin)
				t.adminLogin = _adminlogin;
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Auth.AsnGetUserTokenArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetUserTokenArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserTokenArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iTTL", "number", errors, newContext, true);
		const _lstServiceType = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.lstServiceType, errors, newContext, "lstServiceType", 2);
		const _lstProfileAttributes = AsnProfileAttributeList_Converter.toBER(s.lstProfileAttributes, errors, newContext, "lstProfileAttributes", 3);
		const _adminLogin = AsnAdminLogin_Converter.toBER(s.adminLogin, errors, newContext, "adminLogin", 4);
		if (!errors.hasNewErrors()) {
			if (s.iType !== undefined)
				t.push(new asn1ts.Integer({ value: s.iType, name: "iType", idBlock: { optionalID: 0 } }));
			if (s.iTTL !== undefined)
				t.push(new asn1ts.Integer({ value: s.iTTL, name: "iTTL", idBlock: { optionalID: 1 } }));
			if (_lstServiceType)
				t.push(_lstServiceType);
			if (_lstProfileAttributes)
				t.push(_lstProfileAttributes);
			if (_adminLogin)
				t.push(_adminLogin);
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Auth.AsnGetUserTokenArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserTokenArgument");

		let t: ENetUC_Auth.AsnGetUserTokenArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Auth.AsnGetUserTokenArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Auth.AsnGetUserTokenArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iTTL", "Integer", errors, newContext, true);
			t.lstServiceType = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lstServiceType"), errors, newContext, "lstServiceType", true);
			t.lstProfileAttributes = AsnProfileAttributeList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lstProfileAttributes"), errors, newContext, "lstProfileAttributes", true);
			t.adminLogin = AsnAdminLogin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "adminLogin"), errors, newContext, "adminLogin", true);
		}

		if (errors.validateResult(newContext, "AsnGetUserTokenArgument"))
			return t;

		return undefined;
	}
}
