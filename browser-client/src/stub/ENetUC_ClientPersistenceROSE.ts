// [PrintTSROSEHeader]
/**
 * ENetUC_ClientPersistenceROSE
 * "UC-Server-Access-Protocol-ClientPersistence" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
// [PrintTSROSEImports]
// Global imports
import { IENetUC_ClientPersistenceROSE, IENetUC_ClientPersistenceROSE_Handler } from "./ENetUC_ClientPersistenceROSE_Interface";
import { ROSEError, ROSEInvoke, ROSEReject, ROSEResult } from "./SNACCROSE";
import { AsnInvokeProblem, AsnInvokeProblemEnum, createInvokeReject, IASN1Transport, IASN1LogData, IReceiveInvokeContext, IInvokeHandler, ELogSeverity, ROSEBase } from "./TSROSEBase";
import { ISendInvokeContextParams } from "./TSInvokeContext";
// Local imports
import * as ENetUC_ClientPersistence from "./ENetUC_ClientPersistence";
import * as Converter from "./ENetUC_ClientPersistence_Converter";
// [PrintTSImports]
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_ClientPersistenceROSE";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSROSEOperationDefines]
export enum OperationIDs {
	OPID_asnClientPersistenceCreate = 4301,
	OPID_asnClientPersistenceRead = 4302,
	OPID_asnClientPersistenceUpdate = 4303,
	OPID_asnClientPersistenceDelete = 4304,
	OPID_asnClientPersistenceSubscribe = 4305,
	OPID_asnClientPersistenceEvent = 4306,
	OPID_asnClientPersistenceGetDatabaseID = 4307
}

// [PrintTSROSEModuleComment]
/**
 * Client persistence interface
 * ## Module description
 * This module defines structures and operations for a CRUD item store and its eventing.
 * With these operations, each client can persist client specific data on the UCServer and can attach to the according change notify interface.
 */

// [PrintTSROSEClass]
export class ENetUC_ClientPersistenceROSE extends ROSEBase implements IInvokeHandler, IENetUC_ClientPersistenceROSE {
	/**
	 * Contains the attributes that have to be filtered from logging
	 * Use logfilter property;property inside the asn1 root comments to specify this list
	 */
	public readonly logFilter: string[];

	/**
	 * The Loggers getLogData callback (used in all the log methods called in this class, add the classname to every log entry)
	 *
	 * @returns - an ILogData log data object provided additional data for all the logger calls in this class
	 */
	public getLogData(): IASN1LogData {
		return {
			className: MODULE_NAME
		};
	}

	/**
	 * Returns the operationName for an operationID
	 *
	 * @param id - the id we want to have the name for
	 * @returns - the name or undefined if not found
	 */
	public getNameForOperationID(id: OperationIDs): string | undefined {
		switch (id) {
			case OperationIDs.OPID_asnClientPersistenceCreate:
				return "asnClientPersistenceCreate";
			case OperationIDs.OPID_asnClientPersistenceRead:
				return "asnClientPersistenceRead";
			case OperationIDs.OPID_asnClientPersistenceUpdate:
				return "asnClientPersistenceUpdate";
			case OperationIDs.OPID_asnClientPersistenceDelete:
				return "asnClientPersistenceDelete";
			case OperationIDs.OPID_asnClientPersistenceSubscribe:
				return "asnClientPersistenceSubscribe";
			case OperationIDs.OPID_asnClientPersistenceEvent:
				return "asnClientPersistenceEvent";
			case OperationIDs.OPID_asnClientPersistenceGetDatabaseID:
				return "asnClientPersistenceGetDatabaseID";
			default:
				return undefined;
		}
	}

	/**
	 * Returns the operationID for an operationName
	 *
	 * @param name - the name we want to have the id for
	 * @returns - the id or undefined if not found
	 */
	public getIDForOperationName(name: string): OperationIDs | undefined {
		switch (name) {
			case "asnClientPersistenceCreate":
				return OperationIDs.OPID_asnClientPersistenceCreate;
			case "asnClientPersistenceRead":
				return OperationIDs.OPID_asnClientPersistenceRead;
			case "asnClientPersistenceUpdate":
				return OperationIDs.OPID_asnClientPersistenceUpdate;
			case "asnClientPersistenceDelete":
				return OperationIDs.OPID_asnClientPersistenceDelete;
			case "asnClientPersistenceSubscribe":
				return OperationIDs.OPID_asnClientPersistenceSubscribe;
			case "asnClientPersistenceEvent":
				return OperationIDs.OPID_asnClientPersistenceEvent;
			case "asnClientPersistenceGetDatabaseID":
				return OperationIDs.OPID_asnClientPersistenceGetDatabaseID;
			default:
				return undefined;
		}
	}

	// [PrintTSROSEConstructor]
	/**
	 * Constructs the invoke and oninvoke object targeting all the ROSE related parts.
	 *
	 * @param transport - The transport is the connection to the other side. It takes care of delivering the invoke
	 * to us as well as to send invokes and events to the other side. It also holds the logger.
	 * @param handleEvents - Set this to true if you want to receive events or false if the stub should cached them
	 * until you call dispatchEvents();
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public constructor(transport: IASN1Transport, handleEvents: boolean, handler?: Partial<IENetUC_ClientPersistenceROSE_Handler>) {
		super(transport, handleEvents);

		this.logFilter = [];

		if (handler)
			this.setHandler(handler);
	}

	// [PrintTSROSESetHandler]
	/**
	 * Sets the handler and registers the operations with it
	 *
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public setHandler(handler: Partial<IENetUC_ClientPersistenceROSE_Handler>): void {
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceCreate, "asnClientPersistenceCreate");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceRead, "asnClientPersistenceRead");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceUpdate, "asnClientPersistenceUpdate");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceDelete, "asnClientPersistenceDelete");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceSubscribe, "asnClientPersistenceSubscribe");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceEvent, "asnClientPersistenceEvent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientPersistenceGetDatabaseID, "asnClientPersistenceGetDatabaseID");
		this.transport.registerModuleVersion("ENetUC_ClientPersistence", 8, 0);
	}

	// [PrintTSROSEInvokeMethods]

	// [PrintTSROSEInvokeMethod]
	/**
	 * Adding a new item
	 * A new item is added to the ItemStore.
	 * The client must be subscribed to this ItemStore and pass a unique (for the client session) u8sCrossRefID.
	 * If the client does not provide a StoreID, the server generates a key itself.
	 * Confirmation from the server is via the asnClientPersistenceEvent event with the corresponding u8sCrossRefID.
	 * The configured access permissions are taken into account and acknowledged with an error if necessary.
	 *
	 * @param argument - An AsnClientPersistenceCreateArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientPersistenceCreateResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientPersistenceCreate(argument: ENetUC_ClientPersistence.AsnClientPersistenceCreateArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientPersistence.AsnClientPersistenceCreateResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientPersistence.AsnClientPersistenceCreateResult, OperationIDs.OPID_asnClientPersistenceCreate, "asnClientPersistenceCreate", Converter.AsnClientPersistenceCreateArgument_Converter, Converter.AsnClientPersistenceCreateResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Abruf von Elementen eines ItemStore
	 * The client retrieves one or more items from the passed ItemStore.
	 * The client must be subscribed to this ItemStore and pass a unique (for the client session) u8sCrossRefID.
	 * If the client does not provide a StoreID, all available items in the ItemStore will be returned.
	 * The server's response is via the asnClientPersistenceEvent event with the corresponding u8sCrossRefID.
	 * The configured access permissions are taken into account and acknowledged with an error if necessary.
	 *
	 * @param argument - An AsnClientPersistenceReadArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientPersistenceReadResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientPersistenceRead(argument: ENetUC_ClientPersistence.AsnClientPersistenceReadArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientPersistence.AsnClientPersistenceReadResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientPersistence.AsnClientPersistenceReadResult, OperationIDs.OPID_asnClientPersistenceRead, "asnClientPersistenceRead", Converter.AsnClientPersistenceReadArgument_Converter, Converter.AsnClientPersistenceReadResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Updating an existing element
	 * The client wants to update an existing item in the passed ItemStore.&lt;br \/&gt;
	 * The client must be subscribed to this ItemStore and pass a unique (for the client session) u8sCrossRefID.
	 * If the client does not provide a StoreID, all available items in the ItemStore will be returned.
	 * The server's response is via the asnClientPersistenceEvent event with the corresponding u8sCrossRefID.
	 * The configured access permissions are taken into account and acknowledged with an error if necessary.
	 *
	 * @param argument - An AsnClientPersistenceUpdateArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientPersistenceUpdateResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientPersistenceUpdate(argument: ENetUC_ClientPersistence.AsnClientPersistenceUpdateArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientPersistence.AsnClientPersistenceUpdateResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientPersistence.AsnClientPersistenceUpdateResult, OperationIDs.OPID_asnClientPersistenceUpdate, "asnClientPersistenceUpdate", Converter.AsnClientPersistenceUpdateArgument_Converter, Converter.AsnClientPersistenceUpdateResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Delete an existing item.
	 * The client wants to delete an existing item in the passed ItemStore.&lt;br \/&gt;
	 * The client must be subscribed to this ItemStore and pass a unique (for the client session) u8sCrossRefID.
	 * If the client does not provide a StoreID, all available items in the ItemStore will be returned.
	 * The server's response is via the asnClientPersistenceEvent event with the corresponding u8sCrossRefID.
	 * The configured access permissions are taken into account and acknowledged with an error if necessary.
	 *
	 * @param argument - An AsnClientPersistenceDeleteArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientPersistenceDeleteResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientPersistenceDelete(argument: ENetUC_ClientPersistence.AsnClientPersistenceDeleteArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientPersistence.AsnClientPersistenceDeleteResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientPersistence.AsnClientPersistenceDeleteResult, OperationIDs.OPID_asnClientPersistenceDelete, "asnClientPersistenceDelete", Converter.AsnClientPersistenceDeleteArgument_Converter, Converter.AsnClientPersistenceDeleteResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Subscribe for changes in the item store.
	 * The client registers for event on changes of items within the passed ItemStore.&lt;br \/&gt;
	 * Subscribe can be called multiple times and is additive in this case.
	 * The client must pass a unique (for the client session) u8sCrossRefID.
	 * The server's response is via the asnClientPersistenceEvent event with the corresponding u8sCrossRefID.
	 * The configured access permissions are taken into account and acknowledged with an error if necessary.
	 *
	 * @param argument - An AsnClientPersistenceSubscribeArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientPersistenceSubscribeResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientPersistenceSubscribe(argument: ENetUC_ClientPersistence.AsnClientPersistenceSubscribeArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientPersistence.AsnClientPersistenceSubscribeResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientPersistence.AsnClientPersistenceSubscribeResult, OperationIDs.OPID_asnClientPersistenceSubscribe, "asnClientPersistenceSubscribe", Converter.AsnClientPersistenceSubscribeArgument_Converter, Converter.AsnClientPersistenceSubscribeResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Abfrage der Datenbank ID
	 * Returns a unique ID of the database, which clients can use to determine whether the server is using a new database.&lt;br \/&gt;
	 * This may be the case, for example, if the server database has been deleted.
	 * This method is the only synchronous method of the client persistence interface.
	 *
	 * @param argument - An AsnClientPersistenceGetDatabaseIDArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientPersistenceGetDatabaseIDResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientPersistenceGetDatabaseID(argument: ENetUC_ClientPersistence.AsnClientPersistenceGetDatabaseIDArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientPersistence.AsnClientPersistenceGetDatabaseIDResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientPersistence.AsnClientPersistenceGetDatabaseIDResult, OperationIDs.OPID_asnClientPersistenceGetDatabaseID, "asnClientPersistenceGetDatabaseID", Converter.AsnClientPersistenceGetDatabaseIDArgument_Converter, Converter.AsnClientPersistenceGetDatabaseIDResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the UCServer for signalling changes in an item store.
	 * The server responds via the asnClientPersistenceEvent with the corresponding u8sCrossRefID.&lt;br \/&gt;
	 * The configured access permissions are taken into account and acknowledged with an error if necessary.
	 * The server event is also delivered if the unique ID of the server database has changed.
	 * The client should then discard its (locally cached) data and request new initial data from the server.
	 *
	 * @param argument - An AsnClientPersistenceEventArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnClientPersistenceEvent(argument: ENetUC_ClientPersistence.AsnClientPersistenceEventArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnClientPersistenceEvent, "asnClientPersistenceEvent", Converter.AsnClientPersistenceEventArgument_Converter, invokeContext);
	}

	// [PrintTSROSEOnInvokeswitchCase]
	/**
	 * This is the central onInvoke method that is called whenever a method of this module is called.
	 * Based on the operationID we step into the decoding of the method argument and call the method in the handler.
	 * The result is then again encoded and send to the other side.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the metho in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled, ROSEResult for the invoke result, ROSEError for an error or undefined if an event was called
	 */
	public async onInvoke(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_ClientPersistenceROSE_Handler): Promise<ROSEReject | ROSEResult | ROSEError | undefined> {
		switch (invoke.operationID) {
			case OperationIDs.OPID_asnClientPersistenceCreate:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientPersistenceCreate, ENetUC_ClientPersistence.AsnClientPersistenceCreateArgument, Converter.AsnClientPersistenceCreateArgument_Converter, Converter.AsnClientPersistenceCreateResult_Converter, handler, handler.onInvoke_asnClientPersistenceCreate, invokeContext);
			case OperationIDs.OPID_asnClientPersistenceRead:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientPersistenceRead, ENetUC_ClientPersistence.AsnClientPersistenceReadArgument, Converter.AsnClientPersistenceReadArgument_Converter, Converter.AsnClientPersistenceReadResult_Converter, handler, handler.onInvoke_asnClientPersistenceRead, invokeContext);
			case OperationIDs.OPID_asnClientPersistenceUpdate:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientPersistenceUpdate, ENetUC_ClientPersistence.AsnClientPersistenceUpdateArgument, Converter.AsnClientPersistenceUpdateArgument_Converter, Converter.AsnClientPersistenceUpdateResult_Converter, handler, handler.onInvoke_asnClientPersistenceUpdate, invokeContext);
			case OperationIDs.OPID_asnClientPersistenceDelete:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientPersistenceDelete, ENetUC_ClientPersistence.AsnClientPersistenceDeleteArgument, Converter.AsnClientPersistenceDeleteArgument_Converter, Converter.AsnClientPersistenceDeleteResult_Converter, handler, handler.onInvoke_asnClientPersistenceDelete, invokeContext);
			case OperationIDs.OPID_asnClientPersistenceSubscribe:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientPersistenceSubscribe, ENetUC_ClientPersistence.AsnClientPersistenceSubscribeArgument, Converter.AsnClientPersistenceSubscribeArgument_Converter, Converter.AsnClientPersistenceSubscribeResult_Converter, handler, handler.onInvoke_asnClientPersistenceSubscribe, invokeContext);
			case OperationIDs.OPID_asnClientPersistenceGetDatabaseID:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientPersistenceGetDatabaseID, ENetUC_ClientPersistence.AsnClientPersistenceGetDatabaseIDArgument, Converter.AsnClientPersistenceGetDatabaseIDArgument_Converter, Converter.AsnClientPersistenceGetDatabaseIDResult_Converter, handler, handler.onInvoke_asnClientPersistenceGetDatabaseID, invokeContext);
			case OperationIDs.OPID_asnClientPersistenceEvent:
				return this.onEvent(invoke, invokeContext, handler);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_ClientPersistenceROSE`);
		}
	}

	// [PrintTSROSEOnEventSwitchCase]
	/**
	 * This is the onEvent method that is called whenever an event is called in this module.
	 * It is called from the onInvoke in case of an event is being called.
	 * Depending on the handleEvents flag the event is either handled or cached.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the method in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled or undefined
	 */
	private async onEvent(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_ClientPersistenceROSE_Handler): Promise<ROSEReject | undefined> {
		// If the class says do not handle events and the override flag in the invokeContext has not been set, add the event to the que, otherwise we dispatch it
		if (!this.handleEvents && !invokeContext?.handleEvent) {
			this.transport.log(ELogSeverity.debug, "Adding event to queue", "onEvent", this, { operationName: invoke.operationName, operationID: invoke.operationID });
			this.cachedEvents.push({ invoke, invokeContext, handler });
			return;
		}

		switch (invoke.operationID) {
			case OperationIDs.OPID_asnClientPersistenceEvent:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnClientPersistenceEvent, ENetUC_ClientPersistence.AsnClientPersistenceEventArgument, Converter.AsnClientPersistenceEventArgument_Converter, handler, handler.onEvent_asnClientPersistenceEvent, invokeContext);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_ClientPersistenceROSE`);
		}
	}
}
