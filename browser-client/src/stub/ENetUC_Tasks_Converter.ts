// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Tasks_Converter.ts
 * "UC-Server-Access-Protocol-Tasks" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Tasks from "./ENetUC_Tasks";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Tasks_Converter";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSEncoderDecoderCode]
export class AsnNetDatabaseTaskFindOptionsV2_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNetDatabaseTaskFindOptionsV2");

		const t = {} as ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNetDatabaseTaskFindOptionsV2";
		TSConverter.fillJSONParam(s, t, "eFlags", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxNumEntries", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stUTCStartDateFrom", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stUTCStartDateTo", "Date", errors, newContext);
		const _u8slistOwnerNames = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistOwnerNames, errors, newContext, "u8slistOwnerNames");
		if (_u8slistOwnerNames)
			t.u8slistOwnerNames = _u8slistOwnerNames;

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskFindOptionsV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNetDatabaseTaskFindOptionsV2");

		let t: ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eFlags", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxNumEntries", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "stUTCStartDateFrom", "string", errors, newContext, false))
				t.stUTCStartDateFrom = new Date(s.stUTCStartDateFrom);
			if (TSConverter.validateParam(s, "stUTCStartDateTo", "string", errors, newContext, false))
				t.stUTCStartDateTo = new Date(s.stUTCStartDateTo);
			const _u8slistownernames = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistOwnerNames, errors, newContext, "u8slistOwnerNames", false);
			if (_u8slistownernames)
				t.u8slistOwnerNames = _u8slistownernames;
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskFindOptionsV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNetDatabaseTaskFindOptionsV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNetDatabaseTaskFindOptionsV2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eFlags", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxNumEntries", "number", errors, newContext);
		TSConverter.validateParam(s, "stUTCStartDateFrom", "Date", errors, newContext);
		TSConverter.validateParam(s, "stUTCStartDateTo", "Date", errors, newContext);
		const _u8slistOwnerNames = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistOwnerNames, errors, newContext, "u8slistOwnerNames");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.eFlags, name: "eFlags" }));
			t.push(new asn1ts.Integer({ value: s.iMaxNumEntries, name: "iMaxNumEntries" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCStartDateFrom), name: "stUTCStartDateFrom" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCStartDateTo), name: "stUTCStartDateTo" }));
			if (_u8slistOwnerNames)
				t.push(_u8slistOwnerNames);
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskFindOptionsV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNetDatabaseTaskFindOptionsV2");

		let t: ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnNetDatabaseTaskFindOptionsV2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eFlags", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxNumEntries", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stUTCStartDateFrom", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stUTCStartDateTo", "AsnSystemTime", errors, newContext);
			const _u8slistownernames = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistOwnerNames"), errors, newContext, "u8slistOwnerNames");
			if (_u8slistownernames)
				t.u8slistOwnerNames = _u8slistownernames;
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskFindOptionsV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskGetEntryCountResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskGetEntryCountResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskGetEntryCountResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntryCountResult");

		const t = {} as ENetUC_Tasks.AsnTaskGetEntryCountResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskGetEntryCountResult";
		TSConverter.fillJSONParam(s, t, "iCount", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntryCountResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntryCountResult");

		let t: ENetUC_Tasks.AsnTaskGetEntryCountResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskGetEntryCountResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskGetEntryCountResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iCount", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskGetEntryCountResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskGetEntryCountResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntryCountResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iCount", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iCount, name: "iCount" }));
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntryCountResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntryCountResult");

		let t: ENetUC_Tasks.AsnTaskGetEntryCountResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskGetEntryCountResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskGetEntryCountResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iCount", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskAddEntryResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskAddEntryResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskAddEntryResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskAddEntryResult");

		const t = {} as ENetUC_Tasks.AsnTaskAddEntryResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskAddEntryResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAddedTaskID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnTaskAddEntryResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskAddEntryResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskAddEntryResult");

		let t: ENetUC_Tasks.AsnTaskAddEntryResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskAddEntryResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskAddEntryResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAddedTaskID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnTaskAddEntryResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskAddEntryResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskAddEntryResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskAddEntryResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sAddedTaskID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAddedTaskID, name: "u8sAddedTaskID" }));
		}

		if (errors.validateResult(newContext, "AsnTaskAddEntryResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskAddEntryResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskAddEntryResult");

		let t: ENetUC_Tasks.AsnTaskAddEntryResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskAddEntryResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskAddEntryResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAddedTaskID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTaskAddEntryResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskRemoveEntriesArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskRemoveEntriesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskRemoveEntriesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskRemoveEntriesArgument");

		const t = {} as ENetUC_Tasks.AsnTaskRemoveEntriesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskRemoveEntriesArgument";
		const _u8slistTaskID = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTaskID, errors, newContext, "u8slistTaskID");
		if (_u8slistTaskID)
			t.u8slistTaskID = _u8slistTaskID;

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskRemoveEntriesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskRemoveEntriesArgument");

		let t: ENetUC_Tasks.AsnTaskRemoveEntriesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskRemoveEntriesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskRemoveEntriesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slisttaskid = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTaskID, errors, newContext, "u8slistTaskID", false);
			if (_u8slisttaskid)
				t.u8slistTaskID = _u8slisttaskid;
		}

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskRemoveEntriesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskRemoveEntriesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskRemoveEntriesArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistTaskID = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTaskID, errors, newContext, "u8slistTaskID");
		if (!errors.hasNewErrors()) {
			if (_u8slistTaskID)
				t.push(_u8slistTaskID);
		}

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskRemoveEntriesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskRemoveEntriesArgument");

		let t: ENetUC_Tasks.AsnTaskRemoveEntriesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskRemoveEntriesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskRemoveEntriesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slisttaskid = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTaskID"), errors, newContext, "u8slistTaskID");
			if (_u8slisttaskid)
				t.u8slistTaskID = _u8slisttaskid;
		}

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskRemoveEntriesResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskRemoveEntriesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskRemoveEntriesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskRemoveEntriesResult");

		const t = {} as ENetUC_Tasks.AsnTaskRemoveEntriesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskRemoveEntriesResult";
		TSConverter.fillJSONParam(s, t, "dummy", "null", errors, newContext);

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskRemoveEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskRemoveEntriesResult");

		let t: ENetUC_Tasks.AsnTaskRemoveEntriesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskRemoveEntriesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskRemoveEntriesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskRemoveEntriesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskRemoveEntriesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskRemoveEntriesResult");

		// [Print_BER_EncoderSeqDefCode]
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Null({ name: "dummy" }));
		}

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskRemoveEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskRemoveEntriesResult");

		let t: ENetUC_Tasks.AsnTaskRemoveEntriesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskRemoveEntriesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskRemoveEntriesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "dummy", "Null", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTaskRemoveEntriesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskModifyEntriesResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskModifyEntriesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskModifyEntriesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskModifyEntriesResult");

		const t = {} as ENetUC_Tasks.AsnTaskModifyEntriesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskModifyEntriesResult";
		TSConverter.fillJSONParam(s, t, "dummy", "null", errors, newContext);

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskModifyEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskModifyEntriesResult");

		let t: ENetUC_Tasks.AsnTaskModifyEntriesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskModifyEntriesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskModifyEntriesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskModifyEntriesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskModifyEntriesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskModifyEntriesResult");

		// [Print_BER_EncoderSeqDefCode]
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Null({ name: "dummy" }));
		}

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskModifyEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskModifyEntriesResult");

		let t: ENetUC_Tasks.AsnTaskModifyEntriesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskModifyEntriesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskModifyEntriesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "dummy", "Null", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskSetEntriesStateResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskSetEntriesStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskSetEntriesStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesStateResult");

		const t = {} as ENetUC_Tasks.AsnTaskSetEntriesStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskSetEntriesStateResult";

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesStateResult");

		let t: ENetUC_Tasks.AsnTaskSetEntriesStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskSetEntriesStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskSetEntriesStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskSetEntriesStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskSetEntriesStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesStateResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesStateResult");

		let t: ENetUC_Tasks.AsnTaskSetEntriesStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskSetEntriesStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskSetEntriesStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskDelegateEntriesArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskDelegateEntriesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskDelegateEntriesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskDelegateEntriesArgument");

		const t = {} as ENetUC_Tasks.AsnTaskDelegateEntriesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskDelegateEntriesArgument";
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		if (_u8slistTaskIDs)
			t.u8slistTaskIDs = _u8slistTaskIDs;
		const _u8slistOwners = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistOwners, errors, newContext, "u8slistOwners");
		if (_u8slistOwners)
			t.u8slistOwners = _u8slistOwners;

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskDelegateEntriesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskDelegateEntriesArgument");

		let t: ENetUC_Tasks.AsnTaskDelegateEntriesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskDelegateEntriesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskDelegateEntriesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs", false);
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
			const _u8slistowners = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistOwners, errors, newContext, "u8slistOwners", false);
			if (_u8slistowners)
				t.u8slistOwners = _u8slistowners;
		}

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskDelegateEntriesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskDelegateEntriesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskDelegateEntriesArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		const _u8slistOwners = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistOwners, errors, newContext, "u8slistOwners");
		if (!errors.hasNewErrors()) {
			if (_u8slistTaskIDs)
				t.push(_u8slistTaskIDs);
			if (_u8slistOwners)
				t.push(_u8slistOwners);
		}

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskDelegateEntriesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskDelegateEntriesArgument");

		let t: ENetUC_Tasks.AsnTaskDelegateEntriesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskDelegateEntriesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskDelegateEntriesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTaskIDs"), errors, newContext, "u8slistTaskIDs");
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
			const _u8slistowners = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistOwners"), errors, newContext, "u8slistOwners");
			if (_u8slistowners)
				t.u8slistOwners = _u8slistowners;
		}

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskDelegateEntriesResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskDelegateEntriesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskDelegateEntriesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskDelegateEntriesResult");

		const t = {} as ENetUC_Tasks.AsnTaskDelegateEntriesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskDelegateEntriesResult";

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskDelegateEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskDelegateEntriesResult");

		let t: ENetUC_Tasks.AsnTaskDelegateEntriesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskDelegateEntriesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskDelegateEntriesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskDelegateEntriesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskDelegateEntriesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskDelegateEntriesResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskDelegateEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskDelegateEntriesResult");

		let t: ENetUC_Tasks.AsnTaskDelegateEntriesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskDelegateEntriesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskDelegateEntriesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskDelegateEntriesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskSetEntriesReminderArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskSetEntriesReminderArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskSetEntriesReminderArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesReminderArgument");

		const t = {} as ENetUC_Tasks.AsnTaskSetEntriesReminderArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskSetEntriesReminderArgument";
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		if (_u8slistTaskIDs)
			t.u8slistTaskIDs = _u8slistTaskIDs;
		TSConverter.fillJSONParam(s, t, "bReminderActive", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stReminderTime", "Date", errors, newContext);

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesReminderArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesReminderArgument");

		let t: ENetUC_Tasks.AsnTaskSetEntriesReminderArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskSetEntriesReminderArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskSetEntriesReminderArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs", false);
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
			TSConverter.fillJSONParam(s, t, "bReminderActive", "boolean", errors, newContext, false);
			if (TSConverter.validateParam(s, "stReminderTime", "string", errors, newContext, false))
				t.stReminderTime = new Date(s.stReminderTime);
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskSetEntriesReminderArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskSetEntriesReminderArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesReminderArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		TSConverter.validateParam(s, "bReminderActive", "boolean", errors, newContext);
		TSConverter.validateParam(s, "stReminderTime", "Date", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_u8slistTaskIDs)
				t.push(_u8slistTaskIDs);
			t.push(new asn1ts.Boolean({ value: s.bReminderActive, name: "bReminderActive" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stReminderTime), name: "stReminderTime" }));
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesReminderArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesReminderArgument");

		let t: ENetUC_Tasks.AsnTaskSetEntriesReminderArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskSetEntriesReminderArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskSetEntriesReminderArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTaskIDs"), errors, newContext, "u8slistTaskIDs");
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
			TSConverter.fillASN1Param(s, t, "bReminderActive", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stReminderTime", "AsnSystemTime", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskSetEntriesReminderResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskSetEntriesReminderResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskSetEntriesReminderResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesReminderResult");

		const t = {} as ENetUC_Tasks.AsnTaskSetEntriesReminderResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskSetEntriesReminderResult";

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesReminderResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesReminderResult");

		let t: ENetUC_Tasks.AsnTaskSetEntriesReminderResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskSetEntriesReminderResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskSetEntriesReminderResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskSetEntriesReminderResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskSetEntriesReminderResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesReminderResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesReminderResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesReminderResult");

		let t: ENetUC_Tasks.AsnTaskSetEntriesReminderResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskSetEntriesReminderResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskSetEntriesReminderResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesReminderResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskItemsRemovedArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskItemsRemovedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskItemsRemovedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskItemsRemovedArgument");

		const t = {} as ENetUC_Tasks.AsnTaskItemsRemovedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskItemsRemovedArgument";
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		if (_u8slistTaskIDs)
			t.u8slistTaskIDs = _u8slistTaskIDs;

		if (errors.validateResult(newContext, "AsnTaskItemsRemovedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskItemsRemovedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskItemsRemovedArgument");

		let t: ENetUC_Tasks.AsnTaskItemsRemovedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskItemsRemovedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskItemsRemovedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs", false);
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
		}

		if (errors.validateResult(newContext, "AsnTaskItemsRemovedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskItemsRemovedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskItemsRemovedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskItemsRemovedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		if (!errors.hasNewErrors()) {
			if (_u8slistTaskIDs)
				t.push(_u8slistTaskIDs);
		}

		if (errors.validateResult(newContext, "AsnTaskItemsRemovedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskItemsRemovedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskItemsRemovedArgument");

		let t: ENetUC_Tasks.AsnTaskItemsRemovedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskItemsRemovedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskItemsRemovedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTaskIDs"), errors, newContext, "u8slistTaskIDs");
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
		}

		if (errors.validateResult(newContext, "AsnTaskItemsRemovedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTasksReloadArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTasksReloadArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTasksReloadArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTasksReloadArgument");

		const t = {} as ENetUC_Tasks.AsnTasksReloadArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTasksReloadArgument";

		if (errors.validateResult(newContext, "AsnTasksReloadArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTasksReloadArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTasksReloadArgument");

		let t: ENetUC_Tasks.AsnTasksReloadArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTasksReloadArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTasksReloadArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTasksReloadArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTasksReloadArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTasksReloadArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTasksReloadArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnTasksReloadArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTasksReloadArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTasksReloadArgument");

		let t: ENetUC_Tasks.AsnTasksReloadArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTasksReloadArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTasksReloadArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTasksReloadArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNetDatabaseTask_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnNetDatabaseTask, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnNetDatabaseTask & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNetDatabaseTask");

		const t = {} as ENetUC_Tasks.AsnNetDatabaseTask & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNetDatabaseTask";
		TSConverter.fillJSONParam(s, t, "u8sTaskID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSubject", "string", errors, newContext);
		const _contactData = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toJSON(s.contactData, errors, newContext, "contactData");
		if (_contactData)
			t.contactData = _contactData;
		TSConverter.fillJSONParam(s, t, "u8sCallNumber", "string", errors, newContext);
		const _projectPinRule = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRule_Converter.toJSON(s.projectPinRule, errors, newContext, "projectPinRule");
		if (_projectPinRule)
			t.projectPinRule = _projectPinRule;
		TSConverter.fillJSONParam(s, t, "stUTCStartDate", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stUTCDueDate", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "ePriority", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eDelegationState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bReminderActive", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stUTCReminderTime", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sReminderFile", "string", errors, newContext);
		const _u8sListOwners = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sListOwners, errors, newContext, "u8sListOwners");
		if (_u8sListOwners)
			t.u8sListOwners = _u8sListOwners;
		TSConverter.fillJSONParam(s, t, "u8sCreator", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stUTCCreationTime", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBody", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "stUTCDateCompleted", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCompletedFrom", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "ePrivacy", "number", errors, newContext);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTask"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnNetDatabaseTask | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNetDatabaseTask");

		let t: ENetUC_Tasks.AsnNetDatabaseTask | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnNetDatabaseTask>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnNetDatabaseTask["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTaskID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSubject", "string", errors, newContext, false);
			const _contactdata = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromJSON(s.contactData, errors, newContext, "contactData", false);
			if (_contactdata)
				t.contactData = _contactdata;
			TSConverter.fillJSONParam(s, t, "u8sCallNumber", "string", errors, newContext, false);
			const _projectpinrule = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRule_Converter.fromJSON(s.projectPinRule, errors, newContext, "projectPinRule", false);
			if (_projectpinrule)
				t.projectPinRule = _projectpinrule;
			if (TSConverter.validateParam(s, "stUTCStartDate", "string", errors, newContext, false))
				t.stUTCStartDate = new Date(s.stUTCStartDate);
			if (TSConverter.validateParam(s, "stUTCDueDate", "string", errors, newContext, false))
				t.stUTCDueDate = new Date(s.stUTCDueDate);
			TSConverter.fillJSONParam(s, t, "eState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "ePriority", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "eDelegationState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bReminderActive", "boolean", errors, newContext, false);
			if (TSConverter.validateParam(s, "stUTCReminderTime", "string", errors, newContext, false))
				t.stUTCReminderTime = new Date(s.stUTCReminderTime);
			TSConverter.fillJSONParam(s, t, "u8sReminderFile", "string", errors, newContext, false);
			const _u8slistowners = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sListOwners, errors, newContext, "u8sListOwners", false);
			if (_u8slistowners)
				t.u8sListOwners = _u8slistowners;
			TSConverter.fillJSONParam(s, t, "u8sCreator", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "stUTCCreationTime", "string", errors, newContext, false))
				t.stUTCCreationTime = new Date(s.stUTCCreationTime);
			TSConverter.fillJSONParam(s, t, "u8sBody", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "stUTCDateCompleted", "string", errors, newContext, false))
				t.stUTCDateCompleted = new Date(s.stUTCDateCompleted);
			TSConverter.fillJSONParam(s, t, "u8sCompletedFrom", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "ePrivacy", "number", errors, newContext, false);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTask"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnNetDatabaseTask | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNetDatabaseTask";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNetDatabaseTask");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTaskID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSubject", "string", errors, newContext);
		const _contactData = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toBER(s.contactData, errors, newContext, "contactData");
		TSConverter.validateParam(s, "u8sCallNumber", "string", errors, newContext);
		const _projectPinRule = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRule_Converter.toBER(s.projectPinRule, errors, newContext, "projectPinRule");
		TSConverter.validateParam(s, "stUTCStartDate", "Date", errors, newContext);
		TSConverter.validateParam(s, "stUTCDueDate", "Date", errors, newContext);
		TSConverter.validateParam(s, "eState", "number", errors, newContext);
		TSConverter.validateParam(s, "ePriority", "number", errors, newContext);
		TSConverter.validateParam(s, "eDelegationState", "number", errors, newContext);
		TSConverter.validateParam(s, "bReminderActive", "boolean", errors, newContext);
		TSConverter.validateParam(s, "stUTCReminderTime", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sReminderFile", "string", errors, newContext);
		const _u8sListOwners = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sListOwners, errors, newContext, "u8sListOwners");
		TSConverter.validateParam(s, "u8sCreator", "string", errors, newContext);
		TSConverter.validateParam(s, "stUTCCreationTime", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sBody", "string", errors, newContext);
		TSConverter.validateParam(s, "stUTCDateCompleted", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sCompletedFrom", "string", errors, newContext);
		TSConverter.validateParam(s, "ePrivacy", "number", errors, newContext);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", 0);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTaskID, name: "u8sTaskID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSubject, name: "u8sSubject" }));
			if (_contactData)
				t.push(_contactData);
			t.push(new asn1ts.Utf8String({ value: s.u8sCallNumber, name: "u8sCallNumber" }));
			if (_projectPinRule)
				t.push(_projectPinRule);
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCStartDate), name: "stUTCStartDate" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCDueDate), name: "stUTCDueDate" }));
			t.push(new asn1ts.Enumerated({ value: s.eState, name: "eState" }));
			t.push(new asn1ts.Enumerated({ value: s.ePriority, name: "ePriority" }));
			t.push(new asn1ts.Enumerated({ value: s.eDelegationState, name: "eDelegationState" }));
			t.push(new asn1ts.Boolean({ value: s.bReminderActive, name: "bReminderActive" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCReminderTime), name: "stUTCReminderTime" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sReminderFile, name: "u8sReminderFile" }));
			if (_u8sListOwners)
				t.push(_u8sListOwners);
			t.push(new asn1ts.Utf8String({ value: s.u8sCreator, name: "u8sCreator" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCCreationTime), name: "stUTCCreationTime" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBody, name: "u8sBody" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stUTCDateCompleted), name: "stUTCDateCompleted" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCompletedFrom, name: "u8sCompletedFrom" }));
			t.push(new asn1ts.Enumerated({ value: s.ePrivacy, name: "ePrivacy" }));
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTask"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnNetDatabaseTask | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNetDatabaseTask");

		let t: ENetUC_Tasks.AsnNetDatabaseTask | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnNetDatabaseTask.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnNetDatabaseTask["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTaskID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSubject", "Utf8String", errors, newContext);
			const _contactdata = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "contactData"), errors, newContext, "contactData");
			if (_contactdata)
				t.contactData = _contactdata;
			TSConverter.fillASN1Param(s, t, "u8sCallNumber", "Utf8String", errors, newContext);
			const _projectpinrule = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRule_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "projectPinRule"), errors, newContext, "projectPinRule");
			if (_projectpinrule)
				t.projectPinRule = _projectpinrule;
			TSConverter.fillASN1Param(s, t, "stUTCStartDate", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stUTCDueDate", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eState", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "ePriority", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eDelegationState", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bReminderActive", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stUTCReminderTime", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sReminderFile", "Utf8String", errors, newContext);
			const _u8slistowners = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sListOwners"), errors, newContext, "u8sListOwners");
			if (_u8slistowners)
				t.u8sListOwners = _u8slistowners;
			TSConverter.fillASN1Param(s, t, "u8sCreator", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stUTCCreationTime", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBody", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "stUTCDateCompleted", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCompletedFrom", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "ePrivacy", "Enumerated", errors, newContext);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTask"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNetDatabaseTaskList_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnNetDatabaseTaskList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnNetDatabaseTaskList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNetDatabaseTaskList");

		const t = [] as ENetUC_Tasks.AsnNetDatabaseTaskList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnNetDatabaseTask_Converter.toJSON(se, errors, newContext, "AsnNetDatabaseTask");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnNetDatabaseTaskList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNetDatabaseTaskList");

		let t: ENetUC_Tasks.AsnNetDatabaseTaskList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnNetDatabaseTaskList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Tasks.AsnNetDatabaseTaskList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnNetDatabaseTask_Converter.fromJSON(se, errors, newContext, "AsnNetDatabaseTask", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnNetDatabaseTaskList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNetDatabaseTaskList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNetDatabaseTaskList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnNetDatabaseTask_Converter.toBER(s[id], errors, newContext, "AsnNetDatabaseTask");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnNetDatabaseTaskList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnNetDatabaseTaskList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNetDatabaseTaskList");

		let t: ENetUC_Tasks.AsnNetDatabaseTaskList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnNetDatabaseTaskList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Tasks.AsnNetDatabaseTaskList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnNetDatabaseTask_Converter.fromBER(se, errors, newContext, "AsnNetDatabaseTask", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnNetDatabaseTaskList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskGetEntriesResult_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskGetEntriesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskGetEntriesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntriesResult");

		const t = {} as ENetUC_Tasks.AsnTaskGetEntriesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskGetEntriesResult";
		const _listTasks = AsnNetDatabaseTaskList_Converter.toJSON(s.listTasks, errors, newContext, "listTasks");
		if (_listTasks)
			t.listTasks = _listTasks;

		if (errors.validateResult(newContext, "AsnTaskGetEntriesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntriesResult");

		let t: ENetUC_Tasks.AsnTaskGetEntriesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskGetEntriesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskGetEntriesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromJSON(s.listTasks, errors, newContext, "listTasks", false);
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntriesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskGetEntriesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskGetEntriesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntriesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _listTasks = AsnNetDatabaseTaskList_Converter.toBER(s.listTasks, errors, newContext, "listTasks");
		if (!errors.hasNewErrors()) {
			if (_listTasks)
				t.push(_listTasks);
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntriesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntriesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntriesResult");

		let t: ENetUC_Tasks.AsnTaskGetEntriesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskGetEntriesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskGetEntriesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listTasks"), errors, newContext, "listTasks");
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntriesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskGetEntriesV2Argument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskGetEntriesV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskGetEntriesV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntriesV2Argument");

		const t = {} as ENetUC_Tasks.AsnTaskGetEntriesV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskGetEntriesV2Argument";
		const _findOptions = AsnNetDatabaseTaskFindOptionsV2_Converter.toJSON(s.findOptions, errors, newContext, "findOptions");
		if (_findOptions)
			t.findOptions = _findOptions;

		if (errors.validateResult(newContext, "AsnTaskGetEntriesV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntriesV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntriesV2Argument");

		let t: ENetUC_Tasks.AsnTaskGetEntriesV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskGetEntriesV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskGetEntriesV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _findoptions = AsnNetDatabaseTaskFindOptionsV2_Converter.fromJSON(s.findOptions, errors, newContext, "findOptions", false);
			if (_findoptions)
				t.findOptions = _findoptions;
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntriesV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskGetEntriesV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskGetEntriesV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntriesV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		const _findOptions = AsnNetDatabaseTaskFindOptionsV2_Converter.toBER(s.findOptions, errors, newContext, "findOptions");
		if (!errors.hasNewErrors()) {
			if (_findOptions)
				t.push(_findOptions);
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntriesV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntriesV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntriesV2Argument");

		let t: ENetUC_Tasks.AsnTaskGetEntriesV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskGetEntriesV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskGetEntriesV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _findoptions = AsnNetDatabaseTaskFindOptionsV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "findOptions"), errors, newContext, "findOptions");
			if (_findoptions)
				t.findOptions = _findoptions;
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntriesV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskGetEntryCountArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskGetEntryCountArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskGetEntryCountArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntryCountArgument");

		const t = {} as ENetUC_Tasks.AsnTaskGetEntryCountArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskGetEntryCountArgument";
		const _findOptions = AsnNetDatabaseTaskFindOptionsV2_Converter.toJSON(s.findOptions, errors, newContext, "findOptions");
		if (_findOptions)
			t.findOptions = _findOptions;

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntryCountArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntryCountArgument");

		let t: ENetUC_Tasks.AsnTaskGetEntryCountArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskGetEntryCountArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskGetEntryCountArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _findoptions = AsnNetDatabaseTaskFindOptionsV2_Converter.fromJSON(s.findOptions, errors, newContext, "findOptions", false);
			if (_findoptions)
				t.findOptions = _findoptions;
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskGetEntryCountArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskGetEntryCountArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskGetEntryCountArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _findOptions = AsnNetDatabaseTaskFindOptionsV2_Converter.toBER(s.findOptions, errors, newContext, "findOptions");
		if (!errors.hasNewErrors()) {
			if (_findOptions)
				t.push(_findOptions);
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskGetEntryCountArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskGetEntryCountArgument");

		let t: ENetUC_Tasks.AsnTaskGetEntryCountArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskGetEntryCountArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskGetEntryCountArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _findoptions = AsnNetDatabaseTaskFindOptionsV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "findOptions"), errors, newContext, "findOptions");
			if (_findoptions)
				t.findOptions = _findoptions;
		}

		if (errors.validateResult(newContext, "AsnTaskGetEntryCountArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskAddEntryArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskAddEntryArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskAddEntryArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskAddEntryArgument");

		const t = {} as ENetUC_Tasks.AsnTaskAddEntryArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskAddEntryArgument";
		const _taskEntry = AsnNetDatabaseTask_Converter.toJSON(s.taskEntry, errors, newContext, "taskEntry");
		if (_taskEntry)
			t.taskEntry = _taskEntry;

		if (errors.validateResult(newContext, "AsnTaskAddEntryArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskAddEntryArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskAddEntryArgument");

		let t: ENetUC_Tasks.AsnTaskAddEntryArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskAddEntryArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskAddEntryArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _taskentry = AsnNetDatabaseTask_Converter.fromJSON(s.taskEntry, errors, newContext, "taskEntry", false);
			if (_taskentry)
				t.taskEntry = _taskentry;
		}

		if (errors.validateResult(newContext, "AsnTaskAddEntryArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskAddEntryArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskAddEntryArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskAddEntryArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _taskEntry = AsnNetDatabaseTask_Converter.toBER(s.taskEntry, errors, newContext, "taskEntry");
		if (!errors.hasNewErrors()) {
			if (_taskEntry)
				t.push(_taskEntry);
		}

		if (errors.validateResult(newContext, "AsnTaskAddEntryArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskAddEntryArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskAddEntryArgument");

		let t: ENetUC_Tasks.AsnTaskAddEntryArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskAddEntryArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskAddEntryArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _taskentry = AsnNetDatabaseTask_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "taskEntry"), errors, newContext, "taskEntry");
			if (_taskentry)
				t.taskEntry = _taskentry;
		}

		if (errors.validateResult(newContext, "AsnTaskAddEntryArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskModifyEntriesArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskModifyEntriesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskModifyEntriesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskModifyEntriesArgument");

		const t = {} as ENetUC_Tasks.AsnTaskModifyEntriesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskModifyEntriesArgument";
		const _listTasks = AsnNetDatabaseTaskList_Converter.toJSON(s.listTasks, errors, newContext, "listTasks");
		if (_listTasks)
			t.listTasks = _listTasks;

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskModifyEntriesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskModifyEntriesArgument");

		let t: ENetUC_Tasks.AsnTaskModifyEntriesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskModifyEntriesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskModifyEntriesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromJSON(s.listTasks, errors, newContext, "listTasks", false);
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskModifyEntriesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskModifyEntriesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskModifyEntriesArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listTasks = AsnNetDatabaseTaskList_Converter.toBER(s.listTasks, errors, newContext, "listTasks");
		if (!errors.hasNewErrors()) {
			if (_listTasks)
				t.push(_listTasks);
		}

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskModifyEntriesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskModifyEntriesArgument");

		let t: ENetUC_Tasks.AsnTaskModifyEntriesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskModifyEntriesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskModifyEntriesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listTasks"), errors, newContext, "listTasks");
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskModifyEntriesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskSetEntriesStateArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskSetEntriesStateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskSetEntriesStateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesStateArgument");

		const t = {} as ENetUC_Tasks.AsnTaskSetEntriesStateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskSetEntriesStateArgument";
		TSConverter.fillJSONParam(s, t, "eState", "number", errors, newContext);
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		if (_u8slistTaskIDs)
			t.u8slistTaskIDs = _u8slistTaskIDs;

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesStateArgument");

		let t: ENetUC_Tasks.AsnTaskSetEntriesStateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskSetEntriesStateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskSetEntriesStateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eState", "number", errors, newContext, false);
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs", false);
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskSetEntriesStateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskSetEntriesStateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskSetEntriesStateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eState", "number", errors, newContext);
		const _u8slistTaskIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTaskIDs, errors, newContext, "u8slistTaskIDs");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Enumerated({ value: s.eState, name: "eState" }));
			if (_u8slistTaskIDs)
				t.push(_u8slistTaskIDs);
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskSetEntriesStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskSetEntriesStateArgument");

		let t: ENetUC_Tasks.AsnTaskSetEntriesStateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskSetEntriesStateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskSetEntriesStateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eState", "Enumerated", errors, newContext);
			const _u8slisttaskids = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTaskIDs"), errors, newContext, "u8slistTaskIDs");
			if (_u8slisttaskids)
				t.u8slistTaskIDs = _u8slisttaskids;
		}

		if (errors.validateResult(newContext, "AsnTaskSetEntriesStateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskItemsModifiedArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskItemsModifiedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskItemsModifiedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskItemsModifiedArgument");

		const t = {} as ENetUC_Tasks.AsnTaskItemsModifiedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskItemsModifiedArgument";
		const _listTasks = AsnNetDatabaseTaskList_Converter.toJSON(s.listTasks, errors, newContext, "listTasks");
		if (_listTasks)
			t.listTasks = _listTasks;

		if (errors.validateResult(newContext, "AsnTaskItemsModifiedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskItemsModifiedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskItemsModifiedArgument");

		let t: ENetUC_Tasks.AsnTaskItemsModifiedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskItemsModifiedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskItemsModifiedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromJSON(s.listTasks, errors, newContext, "listTasks", false);
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskItemsModifiedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskItemsModifiedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskItemsModifiedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskItemsModifiedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listTasks = AsnNetDatabaseTaskList_Converter.toBER(s.listTasks, errors, newContext, "listTasks");
		if (!errors.hasNewErrors()) {
			if (_listTasks)
				t.push(_listTasks);
		}

		if (errors.validateResult(newContext, "AsnTaskItemsModifiedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskItemsModifiedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskItemsModifiedArgument");

		let t: ENetUC_Tasks.AsnTaskItemsModifiedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskItemsModifiedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskItemsModifiedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listTasks"), errors, newContext, "listTasks");
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskItemsModifiedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTaskItemsAddedArgument_Converter {
	public static toJSON(s: ENetUC_Tasks.AsnTaskItemsAddedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Tasks.AsnTaskItemsAddedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskItemsAddedArgument");

		const t = {} as ENetUC_Tasks.AsnTaskItemsAddedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTaskItemsAddedArgument";
		const _listTasks = AsnNetDatabaseTaskList_Converter.toJSON(s.listTasks, errors, newContext, "listTasks");
		if (_listTasks)
			t.listTasks = _listTasks;

		if (errors.validateResult(newContext, "AsnTaskItemsAddedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskItemsAddedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskItemsAddedArgument");

		let t: ENetUC_Tasks.AsnTaskItemsAddedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Tasks.AsnTaskItemsAddedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Tasks.AsnTaskItemsAddedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromJSON(s.listTasks, errors, newContext, "listTasks", false);
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskItemsAddedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Tasks.AsnTaskItemsAddedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTaskItemsAddedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTaskItemsAddedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listTasks = AsnNetDatabaseTaskList_Converter.toBER(s.listTasks, errors, newContext, "listTasks");
		if (!errors.hasNewErrors()) {
			if (_listTasks)
				t.push(_listTasks);
		}

		if (errors.validateResult(newContext, "AsnTaskItemsAddedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Tasks.AsnTaskItemsAddedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTaskItemsAddedArgument");

		let t: ENetUC_Tasks.AsnTaskItemsAddedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Tasks.AsnTaskItemsAddedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Tasks.AsnTaskItemsAddedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listtasks = AsnNetDatabaseTaskList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listTasks"), errors, newContext, "listTasks");
			if (_listtasks)
				t.listTasks = _listtasks;
		}

		if (errors.validateResult(newContext, "AsnTaskItemsAddedArgument"))
			return t;

		return undefined;
	}
}
