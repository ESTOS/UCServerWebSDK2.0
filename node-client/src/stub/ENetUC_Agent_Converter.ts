// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Agent_Converter.ts
 * "UC-Server-Access-Protocol-Agent" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Agent from "./ENetUC_Agent";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_ServicesAgents from "./ENetUC_ServicesAgents";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_ServicesAgents_Converter from "./ENetUC_ServicesAgents_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Agent_Converter";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSEncoderDecoderCode]
export class AsnAgentGroupInfo_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentGroupInfo, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentGroupInfo & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentGroupInfo");

		const t = {} as ENetUC_Agent.AsnAgentGroupInfo & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentGroupInfo";
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDisplayName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iGroupCapabilities", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAgentState", "number", errors, newContext);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfo"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentGroupInfo | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentGroupInfo");

		let t: ENetUC_Agent.AsnAgentGroupInfo | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentGroupInfo>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentGroupInfo["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDisplayName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iGroupCapabilities", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAgentState", "number", errors, newContext, false);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfo"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentGroupInfo | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentGroupInfo";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentGroupInfo");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sGroupURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDisplayName", "string", errors, newContext);
		TSConverter.validateParam(s, "iGroupCapabilities", "number", errors, newContext);
		TSConverter.validateParam(s, "iAgentState", "number", errors, newContext);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", 0);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupURI, name: "u8sGroupURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDisplayName, name: "u8sDisplayName" }));
			t.push(new asn1ts.Integer({ value: s.iGroupCapabilities, name: "iGroupCapabilities" }));
			t.push(new asn1ts.Integer({ value: s.iAgentState, name: "iAgentState" }));
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfo"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentGroupInfo | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentGroupInfo");

		let t: ENetUC_Agent.AsnAgentGroupInfo | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentGroupInfo.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentGroupInfo["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGroupURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDisplayName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iGroupCapabilities", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAgentState", "Integer", errors, newContext);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfo"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentMonitorStartArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentMonitorStartArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentMonitorStartArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStartArgument");

		const t = {} as ENetUC_Agent.AsnAgentMonitorStartArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentMonitorStartArgument";
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAgentMonitorStartArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStartArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStartArgument");

		let t: ENetUC_Agent.AsnAgentMonitorStartArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentMonitorStartArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentMonitorStartArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStartArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentMonitorStartArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentMonitorStartArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStartArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStartArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStartArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStartArgument");

		let t: ENetUC_Agent.AsnAgentMonitorStartArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentMonitorStartArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentMonitorStartArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStartArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentMonitorStopArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentMonitorStopArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentMonitorStopArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStopArgument");

		const t = {} as ENetUC_Agent.AsnAgentMonitorStopArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentMonitorStopArgument";
		TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAgentMonitorStopArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStopArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStopArgument");

		let t: ENetUC_Agent.AsnAgentMonitorStopArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentMonitorStopArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentMonitorStopArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStopArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentMonitorStopArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentMonitorStopArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStopArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMonitorCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMonitorCrossRefID, name: "u8sMonitorCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStopArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStopArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStopArgument");

		let t: ENetUC_Agent.AsnAgentMonitorStopArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentMonitorStopArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentMonitorStopArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMonitorCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStopArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentMonitorStopResult_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentMonitorStopResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentMonitorStopResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStopResult");

		const t = {} as ENetUC_Agent.AsnAgentMonitorStopResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentMonitorStopResult";

		if (errors.validateResult(newContext, "AsnAgentMonitorStopResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStopResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStopResult");

		let t: ENetUC_Agent.AsnAgentMonitorStopResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentMonitorStopResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentMonitorStopResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStopResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentMonitorStopResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentMonitorStopResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStopResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnAgentMonitorStopResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStopResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStopResult");

		let t: ENetUC_Agent.AsnAgentMonitorStopResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentMonitorStopResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentMonitorStopResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStopResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentLoginArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentLoginArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentLoginArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLoginArgument");

		const t = {} as ENetUC_Agent.AsnAgentLoginArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentLoginArgument";
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext);
		if (s.acdLoginData) {
			const _acdLoginData = ENetUC_ServicesAgents_Converter.AsnAgentACDLoginData_Converter.toJSON(s.acdLoginData, errors, newContext, "acdLoginData");
			if (_acdLoginData)
				t.acdLoginData = _acdLoginData;
		}

		if (errors.validateResult(newContext, "AsnAgentLoginArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLoginArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLoginArgument");

		let t: ENetUC_Agent.AsnAgentLoginArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentLoginArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentLoginArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext, false);
			const _acdlogindata = ENetUC_ServicesAgents_Converter.AsnAgentACDLoginData_Converter.fromJSON(s.acdLoginData, errors, newContext, "acdLoginData", true);
			if (_acdlogindata)
				t.acdLoginData = _acdlogindata;
		}

		if (errors.validateResult(newContext, "AsnAgentLoginArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentLoginArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentLoginArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLoginArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sGroupURI", "string", errors, newContext);
		const _acdLoginData = ENetUC_ServicesAgents_Converter.AsnAgentACDLoginData_Converter.toBER(s.acdLoginData, errors, newContext, "acdLoginData", 0);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupURI, name: "u8sGroupURI" }));
			if (_acdLoginData)
				t.push(_acdLoginData);
		}

		if (errors.validateResult(newContext, "AsnAgentLoginArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLoginArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLoginArgument");

		let t: ENetUC_Agent.AsnAgentLoginArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentLoginArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentLoginArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGroupURI", "Utf8String", errors, newContext);
			t.acdLoginData = ENetUC_ServicesAgents_Converter.AsnAgentACDLoginData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "acdLoginData"), errors, newContext, "acdLoginData", true);
		}

		if (errors.validateResult(newContext, "AsnAgentLoginArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentLoginResult_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentLoginResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentLoginResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLoginResult");

		const t = {} as ENetUC_Agent.AsnAgentLoginResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentLoginResult";

		if (errors.validateResult(newContext, "AsnAgentLoginResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLoginResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLoginResult");

		let t: ENetUC_Agent.AsnAgentLoginResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentLoginResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentLoginResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentLoginResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentLoginResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentLoginResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLoginResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnAgentLoginResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLoginResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLoginResult");

		let t: ENetUC_Agent.AsnAgentLoginResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentLoginResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentLoginResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentLoginResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentLogoffArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentLogoffArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentLogoffArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLogoffArgument");

		const t = {} as ENetUC_Agent.AsnAgentLogoffArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentLogoffArgument";
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAgentLogoffArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLogoffArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLogoffArgument");

		let t: ENetUC_Agent.AsnAgentLogoffArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentLogoffArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentLogoffArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAgentLogoffArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentLogoffArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentLogoffArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLogoffArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sGroupURI", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupURI, name: "u8sGroupURI" }));
		}

		if (errors.validateResult(newContext, "AsnAgentLogoffArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLogoffArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLogoffArgument");

		let t: ENetUC_Agent.AsnAgentLogoffArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentLogoffArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentLogoffArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGroupURI", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAgentLogoffArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentLogoffResult_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentLogoffResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentLogoffResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLogoffResult");

		const t = {} as ENetUC_Agent.AsnAgentLogoffResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentLogoffResult";

		if (errors.validateResult(newContext, "AsnAgentLogoffResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLogoffResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLogoffResult");

		let t: ENetUC_Agent.AsnAgentLogoffResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentLogoffResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentLogoffResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentLogoffResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentLogoffResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentLogoffResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentLogoffResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnAgentLogoffResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentLogoffResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentLogoffResult");

		let t: ENetUC_Agent.AsnAgentLogoffResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentLogoffResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentLogoffResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentLogoffResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentSetStateArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentSetStateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentSetStateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentSetStateArgument");

		const t = {} as ENetUC_Agent.AsnAgentSetStateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentSetStateArgument";
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iAgentState", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnAgentSetStateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentSetStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentSetStateArgument");

		let t: ENetUC_Agent.AsnAgentSetStateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentSetStateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentSetStateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iAgentState", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAgentSetStateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentSetStateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentSetStateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentSetStateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sGroupURI", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iAgentState", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
			if (s.u8sGroupURI !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sGroupURI, name: "u8sGroupURI", idBlock: { optionalID: 0 } }));
			t.push(new asn1ts.Integer({ value: s.iAgentState, name: "iAgentState" }));
		}

		if (errors.validateResult(newContext, "AsnAgentSetStateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentSetStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentSetStateArgument");

		let t: ENetUC_Agent.AsnAgentSetStateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentSetStateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentSetStateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGroupURI", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iAgentState", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAgentSetStateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentSetStateResult_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentSetStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentSetStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentSetStateResult");

		const t = {} as ENetUC_Agent.AsnAgentSetStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentSetStateResult";

		if (errors.validateResult(newContext, "AsnAgentSetStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentSetStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentSetStateResult");

		let t: ENetUC_Agent.AsnAgentSetStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentSetStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentSetStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentSetStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentSetStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentSetStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentSetStateResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnAgentSetStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentSetStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentSetStateResult");

		let t: ENetUC_Agent.AsnAgentSetStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentSetStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentSetStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnAgentSetStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentNotifyStateChangedArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentNotifyStateChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentNotifyStateChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentNotifyStateChangedArgument");

		const t = {} as ENetUC_Agent.AsnAgentNotifyStateChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentNotifyStateChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAgentState", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnAgentNotifyStateChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentNotifyStateChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentNotifyStateChangedArgument");

		let t: ENetUC_Agent.AsnAgentNotifyStateChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentNotifyStateChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentNotifyStateChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGroupURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAgentState", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyStateChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentNotifyStateChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentNotifyStateChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentNotifyStateChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMonitorCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sGroupURI", "string", errors, newContext);
		TSConverter.validateParam(s, "iAgentState", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMonitorCrossRefID, name: "u8sMonitorCrossRefID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupURI, name: "u8sGroupURI" }));
			t.push(new asn1ts.Integer({ value: s.iAgentState, name: "iAgentState" }));
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyStateChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentNotifyStateChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentNotifyStateChangedArgument");

		let t: ENetUC_Agent.AsnAgentNotifyStateChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentNotifyStateChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentNotifyStateChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMonitorCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGroupURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAgentState", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyStateChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentNotifyBlockedRTCChangedArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentNotifyBlockedRTCChangedArgument");

		const t = {} as ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentNotifyBlockedRTCChangedArgument";
		const _listu8sBlockedUserURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.listu8sBlockedUserURIs, errors, newContext, "listu8sBlockedUserURIs");
		if (_listu8sBlockedUserURIs)
			t.listu8sBlockedUserURIs = _listu8sBlockedUserURIs;

		if (errors.validateResult(newContext, "AsnAgentNotifyBlockedRTCChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentNotifyBlockedRTCChangedArgument");

		let t: ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listu8sblockeduseruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.listu8sBlockedUserURIs, errors, newContext, "listu8sBlockedUserURIs", false);
			if (_listu8sblockeduseruris)
				t.listu8sBlockedUserURIs = _listu8sblockeduseruris;
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyBlockedRTCChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentNotifyBlockedRTCChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentNotifyBlockedRTCChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listu8sBlockedUserURIs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.listu8sBlockedUserURIs, errors, newContext, "listu8sBlockedUserURIs");
		if (!errors.hasNewErrors()) {
			if (_listu8sBlockedUserURIs)
				t.push(_listu8sBlockedUserURIs);
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyBlockedRTCChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentNotifyBlockedRTCChangedArgument");

		let t: ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentNotifyBlockedRTCChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listu8sblockeduseruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listu8sBlockedUserURIs"), errors, newContext, "listu8sBlockedUserURIs");
			if (_listu8sblockeduseruris)
				t.listu8sBlockedUserURIs = _listu8sblockeduseruris;
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyBlockedRTCChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentGroupInfoList_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentGroupInfoList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentGroupInfoList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentGroupInfoList");

		const t = [] as ENetUC_Agent.AsnAgentGroupInfoList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnAgentGroupInfo_Converter.toJSON(se, errors, newContext, "AsnAgentGroupInfo");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfoList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentGroupInfoList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentGroupInfoList");

		let t: ENetUC_Agent.AsnAgentGroupInfoList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentGroupInfoList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Agent.AsnAgentGroupInfoList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnAgentGroupInfo_Converter.fromJSON(se, errors, newContext, "AsnAgentGroupInfo", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfoList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentGroupInfoList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentGroupInfoList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentGroupInfoList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnAgentGroupInfo_Converter.toBER(s[id], errors, newContext, "AsnAgentGroupInfo");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnAgentGroupInfoList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentGroupInfoList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentGroupInfoList");

		let t: ENetUC_Agent.AsnAgentGroupInfoList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentGroupInfoList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Agent.AsnAgentGroupInfoList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnAgentGroupInfo_Converter.fromBER(se, errors, newContext, "AsnAgentGroupInfo", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnAgentGroupInfoList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentMonitorStartResult_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentMonitorStartResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentMonitorStartResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStartResult");

		const t = {} as ENetUC_Agent.AsnAgentMonitorStartResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentMonitorStartResult";
		TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext);
		const _listGroups = AsnAgentGroupInfoList_Converter.toJSON(s.listGroups, errors, newContext, "listGroups");
		if (_listGroups)
			t.listGroups = _listGroups;

		if (errors.validateResult(newContext, "AsnAgentMonitorStartResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStartResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStartResult");

		let t: ENetUC_Agent.AsnAgentMonitorStartResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentMonitorStartResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentMonitorStartResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext, false);
			const _listgroups = AsnAgentGroupInfoList_Converter.fromJSON(s.listGroups, errors, newContext, "listGroups", false);
			if (_listgroups)
				t.listGroups = _listgroups;
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStartResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentMonitorStartResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentMonitorStartResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentMonitorStartResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMonitorCrossRefID", "string", errors, newContext);
		const _listGroups = AsnAgentGroupInfoList_Converter.toBER(s.listGroups, errors, newContext, "listGroups");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMonitorCrossRefID, name: "u8sMonitorCrossRefID" }));
			if (_listGroups)
				t.push(_listGroups);
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStartResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentMonitorStartResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentMonitorStartResult");

		let t: ENetUC_Agent.AsnAgentMonitorStartResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentMonitorStartResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentMonitorStartResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMonitorCrossRefID", "Utf8String", errors, newContext);
			const _listgroups = AsnAgentGroupInfoList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listGroups"), errors, newContext, "listGroups");
			if (_listgroups)
				t.listGroups = _listgroups;
		}

		if (errors.validateResult(newContext, "AsnAgentMonitorStartResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAgentNotifyGroupsChangedArgument_Converter {
	public static toJSON(s: ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentNotifyGroupsChangedArgument");

		const t = {} as ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAgentNotifyGroupsChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext);
		const _listGroups = AsnAgentGroupInfoList_Converter.toJSON(s.listGroups, errors, newContext, "listGroups");
		if (_listGroups)
			t.listGroups = _listGroups;

		if (errors.validateResult(newContext, "AsnAgentNotifyGroupsChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentNotifyGroupsChangedArgument");

		let t: ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMonitorCrossRefID", "string", errors, newContext, false);
			const _listgroups = AsnAgentGroupInfoList_Converter.fromJSON(s.listGroups, errors, newContext, "listGroups", false);
			if (_listgroups)
				t.listGroups = _listgroups;
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyGroupsChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAgentNotifyGroupsChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAgentNotifyGroupsChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMonitorCrossRefID", "string", errors, newContext);
		const _listGroups = AsnAgentGroupInfoList_Converter.toBER(s.listGroups, errors, newContext, "listGroups");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMonitorCrossRefID, name: "u8sMonitorCrossRefID" }));
			if (_listGroups)
				t.push(_listGroups);
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyGroupsChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAgentNotifyGroupsChangedArgument");

		let t: ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Agent.AsnAgentNotifyGroupsChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMonitorCrossRefID", "Utf8String", errors, newContext);
			const _listgroups = AsnAgentGroupInfoList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listGroups"), errors, newContext, "listGroups");
			if (_listgroups)
				t.listGroups = _listgroups;
		}

		if (errors.validateResult(newContext, "AsnAgentNotifyGroupsChangedArgument"))
			return t;

		return undefined;
	}
}
