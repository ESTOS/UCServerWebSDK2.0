// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Appointments_Converter.ts
 * "UC-Server-Access-Protocol-Appointments" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Appointments from "./ENetUC_Appointments";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_Appointments from "./ENetUC_Common_Appointments";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_Appointments_Converter from "./ENetUC_Common_Appointments_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Appointments_Converter";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentSetEntryListArgument_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentSetEntryListArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentSetEntryListArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryListArgument");

		const t = {} as ENetUC_Appointments.AsnAppointmentSetEntryListArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentSetEntryListArgument";
		TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDataSource", "string", errors, newContext);
		const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toJSON(s.appointments, errors, newContext, "appointments");
		if (_appointments)
			t.appointments = _appointments;

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryListArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryListArgument");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryListArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentSetEntryListArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryListArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDataSource", "string", errors, newContext, false);
			const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromJSON(s.appointments, errors, newContext, "appointments", false);
			if (_appointments)
				t.appointments = _appointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentSetEntryListArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentSetEntryListArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryListArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sOwner", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDataSource", "string", errors, newContext);
		const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toBER(s.appointments, errors, newContext, "appointments");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sOwner, name: "u8sOwner" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDataSource, name: "u8sDataSource" }));
			if (_appointments)
				t.push(_appointments);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryListArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryListArgument");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryListArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentSetEntryListArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryListArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sOwner", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDataSource", "Utf8String", errors, newContext);
			const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "appointments"), errors, newContext, "appointments");
			if (_appointments)
				t.appointments = _appointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentSetEntryListResult_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentSetEntryListResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentSetEntryListResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryListResult");

		const t = {} as ENetUC_Appointments.AsnAppointmentSetEntryListResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentSetEntryListResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryListResult");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryListResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentSetEntryListResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryListResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentSetEntryListResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentSetEntryListResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryListResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryListResult");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryListResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentSetEntryListResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryListResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryListResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentSetSeriesEntriesListArgument_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetSeriesEntriesListArgument");

		const t = {} as ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentSetSeriesEntriesListArgument";
		TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDataSource", "string", errors, newContext);
		const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toJSON(s.appointments, errors, newContext, "appointments");
		if (_appointments)
			t.appointments = _appointments;

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetSeriesEntriesListArgument");

		let t: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDataSource", "string", errors, newContext, false);
			const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromJSON(s.appointments, errors, newContext, "appointments", false);
			if (_appointments)
				t.appointments = _appointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentSetSeriesEntriesListArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetSeriesEntriesListArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sOwner", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDataSource", "string", errors, newContext);
		const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toBER(s.appointments, errors, newContext, "appointments");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sOwner, name: "u8sOwner" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDataSource, name: "u8sDataSource" }));
			if (_appointments)
				t.push(_appointments);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetSeriesEntriesListArgument");

		let t: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sOwner", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDataSource", "Utf8String", errors, newContext);
			const _appointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "appointments"), errors, newContext, "appointments");
			if (_appointments)
				t.appointments = _appointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentSetSeriesEntriesListResult_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetSeriesEntriesListResult");

		const t = {} as ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentSetSeriesEntriesListResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetSeriesEntriesListResult");

		let t: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentSetSeriesEntriesListResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetSeriesEntriesListResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetSeriesEntriesListResult");

		let t: ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentSetSeriesEntriesListResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetSeriesEntriesListResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentRemoveEntryArgument_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentRemoveEntryArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentRemoveEntryArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentRemoveEntryArgument");

		const t = {} as ENetUC_Appointments.AsnAppointmentRemoveEntryArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentRemoveEntryArgument";
		TSConverter.fillJSONParam(s, t, "u8sEntryID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentRemoveEntryArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentRemoveEntryArgument");

		let t: ENetUC_Appointments.AsnAppointmentRemoveEntryArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentRemoveEntryArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentRemoveEntryArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sEntryID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentRemoveEntryArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentRemoveEntryArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentRemoveEntryArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sEntryID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sEntryID, name: "u8sEntryID" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentRemoveEntryArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentRemoveEntryArgument");

		let t: ENetUC_Appointments.AsnAppointmentRemoveEntryArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentRemoveEntryArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentRemoveEntryArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sEntryID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentRemoveEntryResult_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentRemoveEntryResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentRemoveEntryResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentRemoveEntryResult");

		const t = {} as ENetUC_Appointments.AsnAppointmentRemoveEntryResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentRemoveEntryResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentRemoveEntryResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentRemoveEntryResult");

		let t: ENetUC_Appointments.AsnAppointmentRemoveEntryResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentRemoveEntryResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentRemoveEntryResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentRemoveEntryResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentRemoveEntryResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentRemoveEntryResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentRemoveEntryResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentRemoveEntryResult");

		let t: ENetUC_Appointments.AsnAppointmentRemoveEntryResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentRemoveEntryResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentRemoveEntryResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentRemoveEntryResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentSetEntryArgument_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentSetEntryArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentSetEntryArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryArgument");

		const t = {} as ENetUC_Appointments.AsnAppointmentSetEntryArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentSetEntryArgument";
		const _appointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.toJSON(s.appointment, errors, newContext, "appointment");
		if (_appointment)
			t.appointment = _appointment;

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryArgument");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentSetEntryArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _appointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.fromJSON(s.appointment, errors, newContext, "appointment", false);
			if (_appointment)
				t.appointment = _appointment;
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentSetEntryArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentSetEntryArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _appointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.toBER(s.appointment, errors, newContext, "appointment");
		if (!errors.hasNewErrors()) {
			if (_appointment)
				t.push(_appointment);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryArgument");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentSetEntryArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _appointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "appointment"), errors, newContext, "appointment");
			if (_appointment)
				t.appointment = _appointment;
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentSetEntryResult_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentSetEntryResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentSetEntryResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryResult");

		const t = {} as ENetUC_Appointments.AsnAppointmentSetEntryResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentSetEntryResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryResult");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentSetEntryResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentSetEntryResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentSetEntryResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentSetEntryResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentSetEntryResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentSetEntryResult");

		let t: ENetUC_Appointments.AsnAppointmentSetEntryResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentSetEntryResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentSetEntryResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentSetEntryResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentGetAllEntriesForUserArgument_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetAllEntriesForUserArgument");

		const t = {} as ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentGetAllEntriesForUserArgument";
		TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetAllEntriesForUserArgument");

		let t: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentGetAllEntriesForUserArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetAllEntriesForUserArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sOwner", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sOwner, name: "u8sOwner" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetAllEntriesForUserArgument");

		let t: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sOwner", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentGetAllEntriesForUserResult_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetAllEntriesForUserResult");

		const t = {} as ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentGetAllEntriesForUserResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		const _listAppointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toJSON(s.listAppointments, errors, newContext, "listAppointments");
		if (_listAppointments)
			t.listAppointments = _listAppointments;

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetAllEntriesForUserResult");

		let t: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			const _listappointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromJSON(s.listAppointments, errors, newContext, "listAppointments", false);
			if (_listappointments)
				t.listAppointments = _listappointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentGetAllEntriesForUserResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetAllEntriesForUserResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		const _listAppointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toBER(s.listAppointments, errors, newContext, "listAppointments");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			if (_listAppointments)
				t.push(_listAppointments);
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetAllEntriesForUserResult");

		let t: ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentGetAllEntriesForUserResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			const _listappointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listAppointments"), errors, newContext, "listAppointments");
			if (_listappointments)
				t.listAppointments = _listappointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetAllEntriesForUserResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentGetActualEntryForUserArgument_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetActualEntryForUserArgument");

		const t = {} as ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentGetActualEntryForUserArgument";
		TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetActualEntryForUserArgument");

		let t: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sOwner", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentGetActualEntryForUserArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetActualEntryForUserArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sOwner", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sOwner, name: "u8sOwner" }));
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetActualEntryForUserArgument");

		let t: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentGetActualEntryForUserArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sOwner", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAppointmentGetActualEntryForUserResult_Converter {
	public static toJSON(s: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetActualEntryForUserResult");

		const t = {} as ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAppointmentGetActualEntryForUserResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		const _listAppointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toJSON(s.listAppointments, errors, newContext, "listAppointments");
		if (_listAppointments)
			t.listAppointments = _listAppointments;

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetActualEntryForUserResult");

		let t: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			const _listappointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromJSON(s.listAppointments, errors, newContext, "listAppointments", false);
			if (_listappointments)
				t.listAppointments = _listappointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAppointmentGetActualEntryForUserResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAppointmentGetActualEntryForUserResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		const _listAppointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toBER(s.listAppointments, errors, newContext, "listAppointments");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			if (_listAppointments)
				t.push(_listAppointments);
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAppointmentGetActualEntryForUserResult");

		let t: ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Appointments.AsnAppointmentGetActualEntryForUserResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			const _listappointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listAppointments"), errors, newContext, "listAppointments");
			if (_listappointments)
				t.listAppointments = _listappointments;
		}

		if (errors.validateResult(newContext, "AsnAppointmentGetActualEntryForUserResult"))
			return t;

		return undefined;
	}
}
