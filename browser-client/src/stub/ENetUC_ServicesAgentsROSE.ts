// [PrintTSROSEHeader]
/**
 * ENetUC_ServicesAgentsROSE
 * "UC-Server-Access-Protocol-AgentServices" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
// [PrintTSROSEImports]
// Global imports
import { IENetUC_ServicesAgentsROSE, IENetUC_ServicesAgentsROSE_Handler } from "./ENetUC_ServicesAgentsROSE_Interface";
import { ROSEError, ROSEInvoke, ROSEReject, ROSEResult } from "./SNACCROSE";
import { AsnInvokeProblem, AsnInvokeProblemEnum, createInvokeReject, IASN1Transport, IASN1LogData, IReceiveInvokeContext, IInvokeHandler, ELogSeverity, ROSEBase } from "./TSROSEBase";
import { ISendInvokeContextParams } from "./TSInvokeContext";
// Local imports
import * as ENetUC_ServicesAgents from "./ENetUC_ServicesAgents";
import * as Converter from "./ENetUC_ServicesAgents_Converter";
// [PrintTSImports]
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_ServicesAgentsROSE";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSROSEOperationDefines]
export enum OperationIDs {
	OPID_asnRegisterServiceAgents = 4900,
	OPID_asnUnregisterServiceAgents = 4901,
	OPID_asnSetServiceAgentStates = 4902,
	OPID_asnResponseSetServiceAgentStatesFailed = 4903,
	OPID_asnRequestServiceAgentStateChange = 4904,
	OPID_asnRequestServiceAgentLogin = 4905,
	OPID_asnRequestServiceAgentLogout = 4906,
	OPID_asnRequestServiceAgentsStatusUpdate = 4910
}

// [PrintTSROSEModuleComment]
/**
 * API for Server to Server Agents functionality
 * ## Module description
 * This module defines structures and operations for a agent functionality backend other than UCServer or PBX.
 *
 * ## Prerequisite for using the interface
 * - The other service needs a socket for secure data Transmission between client-server and vise versa.
 * - Installation of ProCall Software in advance at the client side
 * - Login the other service at the UCServer
 * - Provide IDs (full canonical telephone numbers or user IDs) of the User, which should use the agnet functionality
 * - Attach to Events for the user commands (like logon or logoff)
 * - Provide state changes of the agent with its IDas event to the UCServer
 * - While closing the connection, detach from events first, unregister IDs and close socket connection to the UCServer.
 *
 *
 * ## Functionalities
 * - If the user can be recognized as agnet user oft the other server it will gain the client UI for agnet state changes
 * - User commands according state changes of the user will be provided to the other service
 * - State changes from the other service will be provided to the corresponding clients
 *
 * ## Sequence diagram
 * \"Call\": Like a RPC Call, expect results or errors as an answer.
 *
 * \"Event\": Behaviour is like an event it is named, this call will not have any results sent back.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * UML section is not exported to this file!
 */

// [PrintTSROSEClass]
export class ENetUC_ServicesAgentsROSE extends ROSEBase implements IInvokeHandler, IENetUC_ServicesAgentsROSE {
	/**
	 * Contains the attributes that have to be filtered from logging
	 * Use logfilter property;property inside the asn1 root comments to specify this list
	 */
	public readonly logFilter: string[];

	/**
	 * The Loggers getLogData callback (used in all the log methods called in this class, add the classname to every log entry)
	 *
	 * @returns - an ILogData log data object provided additional data for all the logger calls in this class
	 */
	public getLogData(): IASN1LogData {
		return {
			className: MODULE_NAME
		};
	}

	/**
	 * Returns the operationName for an operationID
	 *
	 * @param id - the id we want to have the name for
	 * @returns - the name or undefined if not found
	 */
	public getNameForOperationID(id: OperationIDs): string | undefined {
		switch (id) {
			case OperationIDs.OPID_asnRegisterServiceAgents:
				return "asnRegisterServiceAgents";
			case OperationIDs.OPID_asnUnregisterServiceAgents:
				return "asnUnregisterServiceAgents";
			case OperationIDs.OPID_asnSetServiceAgentStates:
				return "asnSetServiceAgentStates";
			case OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed:
				return "asnResponseSetServiceAgentStatesFailed";
			case OperationIDs.OPID_asnRequestServiceAgentStateChange:
				return "asnRequestServiceAgentStateChange";
			case OperationIDs.OPID_asnRequestServiceAgentLogin:
				return "asnRequestServiceAgentLogin";
			case OperationIDs.OPID_asnRequestServiceAgentLogout:
				return "asnRequestServiceAgentLogout";
			case OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate:
				return "asnRequestServiceAgentsStatusUpdate";
			default:
				return undefined;
		}
	}

	/**
	 * Returns the operationID for an operationName
	 *
	 * @param name - the name we want to have the id for
	 * @returns - the id or undefined if not found
	 */
	public getIDForOperationName(name: string): OperationIDs | undefined {
		switch (name) {
			case "asnRegisterServiceAgents":
				return OperationIDs.OPID_asnRegisterServiceAgents;
			case "asnUnregisterServiceAgents":
				return OperationIDs.OPID_asnUnregisterServiceAgents;
			case "asnSetServiceAgentStates":
				return OperationIDs.OPID_asnSetServiceAgentStates;
			case "asnResponseSetServiceAgentStatesFailed":
				return OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed;
			case "asnRequestServiceAgentStateChange":
				return OperationIDs.OPID_asnRequestServiceAgentStateChange;
			case "asnRequestServiceAgentLogin":
				return OperationIDs.OPID_asnRequestServiceAgentLogin;
			case "asnRequestServiceAgentLogout":
				return OperationIDs.OPID_asnRequestServiceAgentLogout;
			case "asnRequestServiceAgentsStatusUpdate":
				return OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate;
			default:
				return undefined;
		}
	}

	// [PrintTSROSEConstructor]
	/**
	 * Constructs the invoke and oninvoke object targeting all the ROSE related parts.
	 *
	 * @param transport - The transport is the connection to the other side. It takes care of delivering the invoke
	 * to us as well as to send invokes and events to the other side. It also holds the logger.
	 * @param handleEvents - Set this to true if you want to receive events or false if the stub should cached them
	 * until you call dispatchEvents();
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public constructor(transport: IASN1Transport, handleEvents: boolean, handler?: Partial<IENetUC_ServicesAgentsROSE_Handler>) {
		super(transport, handleEvents);

		this.logFilter = [];

		if (handler)
			this.setHandler(handler);
	}

	// [PrintTSROSESetHandler]
	/**
	 * Sets the handler and registers the operations with it
	 *
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public setHandler(handler: Partial<IENetUC_ServicesAgentsROSE_Handler>): void {
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRegisterServiceAgents, "asnRegisterServiceAgents");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnUnregisterServiceAgents, "asnUnregisterServiceAgents");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnSetServiceAgentStates, "asnSetServiceAgentStates");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed, "asnResponseSetServiceAgentStatesFailed");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRequestServiceAgentStateChange, "asnRequestServiceAgentStateChange");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRequestServiceAgentLogin, "asnRequestServiceAgentLogin");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRequestServiceAgentLogout, "asnRequestServiceAgentLogout");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate, "asnRequestServiceAgentsStatusUpdate");
		this.transport.registerModuleVersion("ENetUC_ServicesAgents", 8, 0);
	}

	// [PrintTSROSEInvokeMethods]

	// [PrintTSROSEInvokeMethod]
	/**
	 * register agents to the service
	 * UML section is not exported to this file!
	 *
	 * @param argument - An AsnRegisterServiceAgentsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnRegisterServiceAgentsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnRegisterServiceAgents(argument: ENetUC_ServicesAgents.AsnRegisterServiceAgentsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ServicesAgents.AsnRegisterServiceAgentsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ServicesAgents.AsnRegisterServiceAgentsResult, OperationIDs.OPID_asnRegisterServiceAgents, "asnRegisterServiceAgents", Converter.AsnRegisterServiceAgentsArgument_Converter, Converter.AsnRegisterServiceAgentsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * unregister agents from the service
	 * UML section is not exported to this file!
	 *
	 * @param argument - An AsnUnregisterServiceAgentsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnUnregisterServiceAgentsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnUnregisterServiceAgents(argument: ENetUC_ServicesAgents.AsnUnregisterServiceAgentsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ServicesAgents.AsnUnregisterServiceAgentsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ServicesAgents.AsnUnregisterServiceAgentsResult, OperationIDs.OPID_asnUnregisterServiceAgents, "asnUnregisterServiceAgents", Converter.AsnUnregisterServiceAgentsArgument_Converter, Converter.AsnUnregisterServiceAgentsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event to set the state of agent(s). There is no answer to this event.
	 * UML section is not exported to this file!
	 *
	 * @param argument - An AsnSetServiceAgentStatesArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnSetServiceAgentStates(argument: ENetUC_ServicesAgents.AsnSetServiceAgentStatesArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnSetServiceAgentStates, "asnSetServiceAgentStates", Converter.AsnSetServiceAgentStatesArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event to for agent states that the UCServer was unable to set
	 * If the UCServer was unable to set agent states while processing asnSetServiceAgentStates, it will
	 * send back this event with the failed agent states.
	 *
	 * @param argument - An AsnResponseSetServiceAgentStatesFailedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnResponseSetServiceAgentStatesFailed(argument: ENetUC_ServicesAgents.AsnResponseSetServiceAgentStatesFailedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed, "asnResponseSetServiceAgentStatesFailed", Converter.AsnResponseSetServiceAgentStatesFailedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * The state of a agent should be changed
	 * This event will be sent by the UCServer when the user wants to change his agent state (button in the UI).
	 * The connected service should change the agents satte accordingliy and send an update of the resulting agent state back to the UCServer.
	 *
	 * The UCServer by itself will not cache or predict the agent state resulting, so it will only change the internal state only the service
	 * send the update.
	 *
	 *
	 * UML section is not exported to this file!
	 *
	 * @param argument - An AsnRequestServiceAgentStateChangeArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnRequestServiceAgentStateChange(argument: ENetUC_ServicesAgents.AsnRequestServiceAgentStateChangeArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnRequestServiceAgentStateChange, "asnRequestServiceAgentStateChange", Converter.AsnRequestServiceAgentStateChangeArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * The agent should be logged in
	 * This event will be sent by the UCServer when the user wants to login.
	 * The connected service should change the agents satte accordingliy and send an update of the resulting agent state back to the UCServer.
	 *
	 * The UCServer by itself will not cache or predict the agent state resulting, so it will only change the internal state only the service
	 * send the update.
	 *
	 * @param argument - An AsnRequestServiceAgentLoginArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnRequestServiceAgentLogin(argument: ENetUC_ServicesAgents.AsnRequestServiceAgentLoginArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnRequestServiceAgentLogin, "asnRequestServiceAgentLogin", Converter.AsnRequestServiceAgentLoginArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * The agent request a logout
	 * This event will be sent by the UCServer when the user wants to logout.
	 * The connected service should change the agents state accordingliy and send an update of the resulting agent state () back to the UCServer.
	 *
	 * The UCServer by itself will not cache or predict the agent state resulting, so it will only change the internal state only the service
	 * send the update.
	 *
	 * @param argument - An AsnRequestServiceAgentLogoutArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnRequestServiceAgentLogout(argument: ENetUC_ServicesAgents.AsnRequestServiceAgentLogoutArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnRequestServiceAgentLogout, "asnRequestServiceAgentLogout", Converter.AsnRequestServiceAgentLogoutArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * The connected service should update the state of the given agents or all agents
	 *
	 * @param argument - An AsnRequestServiceAgentsStatusUpdateArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnRequestServiceAgentsStatusUpdate(argument: ENetUC_ServicesAgents.AsnRequestServiceAgentsStatusUpdateArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate, "asnRequestServiceAgentsStatusUpdate", Converter.AsnRequestServiceAgentsStatusUpdateArgument_Converter, invokeContext);
	}

	// [PrintTSROSEOnInvokeswitchCase]
	/**
	 * This is the central onInvoke method that is called whenever a method of this module is called.
	 * Based on the operationID we step into the decoding of the method argument and call the method in the handler.
	 * The result is then again encoded and send to the other side.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the metho in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled, ROSEResult for the invoke result, ROSEError for an error or undefined if an event was called
	 */
	public async onInvoke(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_ServicesAgentsROSE_Handler): Promise<ROSEReject | ROSEResult | ROSEError | undefined> {
		switch (invoke.operationID) {
			case OperationIDs.OPID_asnRegisterServiceAgents:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnRegisterServiceAgents, ENetUC_ServicesAgents.AsnRegisterServiceAgentsArgument, Converter.AsnRegisterServiceAgentsArgument_Converter, Converter.AsnRegisterServiceAgentsResult_Converter, handler, handler.onInvoke_asnRegisterServiceAgents, invokeContext);
			case OperationIDs.OPID_asnUnregisterServiceAgents:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnUnregisterServiceAgents, ENetUC_ServicesAgents.AsnUnregisterServiceAgentsArgument, Converter.AsnUnregisterServiceAgentsArgument_Converter, Converter.AsnUnregisterServiceAgentsResult_Converter, handler, handler.onInvoke_asnUnregisterServiceAgents, invokeContext);
			case OperationIDs.OPID_asnSetServiceAgentStates:
			case OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed:
			case OperationIDs.OPID_asnRequestServiceAgentStateChange:
			case OperationIDs.OPID_asnRequestServiceAgentLogin:
			case OperationIDs.OPID_asnRequestServiceAgentLogout:
			case OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate:
				return this.onEvent(invoke, invokeContext, handler);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_ServicesAgentsROSE`);
		}
	}

	// [PrintTSROSEOnEventSwitchCase]
	/**
	 * This is the onEvent method that is called whenever an event is called in this module.
	 * It is called from the onInvoke in case of an event is being called.
	 * Depending on the handleEvents flag the event is either handled or cached.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the method in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled or undefined
	 */
	private async onEvent(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_ServicesAgentsROSE_Handler): Promise<ROSEReject | undefined> {
		// If the class says do not handle events and the override flag in the invokeContext has not been set, add the event to the que, otherwise we dispatch it
		if (!this.handleEvents && !invokeContext?.handleEvent) {
			this.transport.log(ELogSeverity.debug, "Adding event to queue", "onEvent", this, { operationName: invoke.operationName, operationID: invoke.operationID });
			this.cachedEvents.push({ invoke, invokeContext, handler });
			return;
		}

		switch (invoke.operationID) {
			case OperationIDs.OPID_asnSetServiceAgentStates:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnSetServiceAgentStates, ENetUC_ServicesAgents.AsnSetServiceAgentStatesArgument, Converter.AsnSetServiceAgentStatesArgument_Converter, handler, handler.onEvent_asnSetServiceAgentStates, invokeContext);
			case OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnResponseSetServiceAgentStatesFailed, ENetUC_ServicesAgents.AsnResponseSetServiceAgentStatesFailedArgument, Converter.AsnResponseSetServiceAgentStatesFailedArgument_Converter, handler, handler.onEvent_asnResponseSetServiceAgentStatesFailed, invokeContext);
			case OperationIDs.OPID_asnRequestServiceAgentStateChange:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnRequestServiceAgentStateChange, ENetUC_ServicesAgents.AsnRequestServiceAgentStateChangeArgument, Converter.AsnRequestServiceAgentStateChangeArgument_Converter, handler, handler.onEvent_asnRequestServiceAgentStateChange, invokeContext);
			case OperationIDs.OPID_asnRequestServiceAgentLogin:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnRequestServiceAgentLogin, ENetUC_ServicesAgents.AsnRequestServiceAgentLoginArgument, Converter.AsnRequestServiceAgentLoginArgument_Converter, handler, handler.onEvent_asnRequestServiceAgentLogin, invokeContext);
			case OperationIDs.OPID_asnRequestServiceAgentLogout:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnRequestServiceAgentLogout, ENetUC_ServicesAgents.AsnRequestServiceAgentLogoutArgument, Converter.AsnRequestServiceAgentLogoutArgument_Converter, handler, handler.onEvent_asnRequestServiceAgentLogout, invokeContext);
			case OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnRequestServiceAgentsStatusUpdate, ENetUC_ServicesAgents.AsnRequestServiceAgentsStatusUpdateArgument, Converter.AsnRequestServiceAgentsStatusUpdateArgument_Converter, handler, handler.onEvent_asnRequestServiceAgentsStatusUpdate, invokeContext);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_ServicesAgentsROSE`);
		}
	}
}
