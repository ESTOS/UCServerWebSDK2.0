// [PrintTSCodeOne]
// [PrintTSComments]
/*
 * ENetUC_ChatV2.ts
 * "UC-Server-Access-Protocol-ChatV2" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
/**
 * Text chat functions
 * ## Module description
 * This module defines structures and functions for the text chat functionality of the UCServer.
 *
 * Example for sending a Chat Message from \"ProCall A\" to \"ProCall B\":
 * UML section is not exported to this file!
 */
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Journal from "./ENetUC_Journal";
import * as ENetUC_BinaryTransfer from "./ENetUC_BinaryTransfer";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_ChatV2";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnChatResultEnum {
	/** no error */
	noerror = 0,
	/** User is not allowed to perform this operation */
	forbidden = 1,
	/** Conversation ID is invalid */
	invalidconversationid = 2,
	/** Message ID is invalid */
	invalidmessageid = 3,
	/** Too many messages, make a smaller request */
	tomanymessages = 4,
	/** unknown receiver */
	unknownrecipient = 5,
	/** Database error in the server */
	databasefail = 6,
	/** Request was not accepted because a CrossRefID that already existed in the database was used */
	invalidcrossrefid = 7,
	/** Message was not accepted by the federated server */
	federationfail = 8,
	/** Request could not be processed, e.g. if a user is to be removed from a chat room but is not a member of the chat room */
	requestfail = 9,
	/** Invalid parameter */
	invalidparam = 10,
	/** If the client sends asnChatTextMessage, asnChatBinaryMessage, asnChatForwardMessage, asnChatForward, asnChatSetUserlist, asnChatUserlistModify or asnChatSetMessagesStatus without beeing subscribed (asnChatSubscribeEvents) for chat events first \"notsubscribed\" is returned. This means that the request of the client has been processed, but the client will not receive any events because of the missing subscription. */
	notsubscribed = 11
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnChatUserlistModify {
	/** User added */
	added = 1,
	/** User removed */
	removed = 2,
	/** complete user list is attached, e.g. when user joins a chat room and gets the current status of the participant */
	update = 3
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnChatWatchModeEnum {
	/** Chat-Raum Start observation */
	watch = 1,
	/** Chat-Raum End observation */
	unwatch = 0
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnConversationType {
	/** Chat between two participants */
	one_to_one = 1,
	/** Chat with more than two participants (chat room) */
	multi_user = 2,
	static_chatroom = 3,
	/** Chat between participants, e.g. Anonymous and agent, participants can actively join and follow the history completely */
	public_chatroom = 4
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnChatMessageStatus {
	/** read */
	eRead = 1,
	/** unread */
	eUnread = 2,
	/** deleted */
	eDeleted = 3,
	/** undeleted */
	eUndeleted = 4
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnChatTypingTime {
	/** Interval in Seconds a client has to refresh the server that the user is typing */
	refreshInterval = 20,
	/** Time after which a client decides that the other side no longer is typing due to network lag\/error */
	timeout = 30
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum EnumRequestConversationAvatarResult {
	/** There is no image\/avatar defined for the given conversationID - so please use the default one */
	eDEFAULT = 0,
	/** The image\/avatar has not changed according to the given hash and therefore there is no image in the result. */
	eHASHNOTCHANGED = 1,
	/** The requested image\/avatar is attached in the result. */
	eATTACHED = 2
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatParty {
	public constructor(that: AsnChatParty) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatParty {
		return new AsnChatParty({
			u8sContactURI: "",
			iContactRights: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sContactURI",
			"iContactRights"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sDisplayName",
				"iLastReadSequenceID",
				"bReadNotifySupported",
				"contactInformation"
			);
		}
		return p;
	}

	public static type = "AsnChatParty";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatParty",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sContactURI" }),
				new asn1ts.Utf8String({ name: "u8sDisplayName", optional: true }),
				new asn1ts.Integer({ name: "iContactRights" }),
				new asn1ts.Integer({ name: "iLastReadSequenceID", idBlock: { optionalID: 0 } }),
				new asn1ts.Boolean({ name: "bReadNotifySupported", idBlock: { optionalID: 1 } }),
				ENetUC_Common.AsnNetDatabaseContact.getASN1Schema({ name: "contactInformation", idBlock: { optionalID: 2 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** Contact URI, including display names jan\@estos.de; display = Jan Rievenherm */
	public u8sContactURI!: string;
	/** Anzeigename des Kontaktes, e.g. 'Jan Rievenherm' */
	public u8sDisplayName?: string;
	/** Rights (bit mask) of the user in this chat&lt;br \/&gt;0x0000 0001					may write&lt;br \/&gt;0x0000 0002					may add and remove users */
	public iContactRights!: number;
	/** Sequence ID up to which the party read (optional, only AsnChatEventConversation) */
	public iLastReadSequenceID?: number;
	/** If a federated contact does not send read notifications, this flag is set to false */
	public bReadNotifySupported?: boolean;
	/** Contact information for SMS, MMS etc. where the party is NOT a CtiServer user and therefore the contact information is not available on the client, is only filled and sent with PArty Added and ConversationCreated */
	public contactInformation?: ENetUC_Common.AsnNetDatabaseContact;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSubscribeEventsArgument {
	public constructor(that: AsnChatSubscribeEventsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSubscribeEventsArgument {
		return new AsnChatSubscribeEventsArgument({
			bReceiveChatEvents: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"bReceiveChatEvents"
		];
		if (bIncludeOptionals) {
			p.push(
				"iLastKnownGlobTransactionID",
				"iMaxEvents",
				"u8sEventListCrossRefID",
				"optionalParams",
				"bSupportReactions"
			);
		}
		return p;
	}

	public static type = "AsnChatSubscribeEventsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSubscribeEventsArgument",
			...params,
			value: [
				new asn1ts.Boolean({ name: "bReceiveChatEvents" }),
				new asn1ts.Integer({ name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iMaxEvents", idBlock: { optionalID: 1 } }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }),
				ENetUC_Common.AsnOptionalParameters.getASN1Schema({ name: "optionalParams", idBlock: { optionalID: 3 } }),
				new asn1ts.Boolean({ name: "bSupportReactions", idBlock: { optionalID: 4 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** Chat Events abbonieren (true = subscribe \/ false = unsubscribe) */
	public bReceiveChatEvents!: boolean;
	/** last known global TransactionsID */
	public iLastKnownGlobTransactionID?: number;
	/** Max x events back (will be set to 100 by the server if not specified) */
	public iMaxEvents?: number;
	/** The event list that is sent back by the server based on this request contains this CrossRefID. This enables the client to assign events to a request sent by it. The CrossRefID must be assigned by the client and cannot be generated by the server and returned in the return. The reason for this is that there is no guarantee that the return will reach the client before the event list. */
	public u8sEventListCrossRefID?: string;
	/**
	 * - optionalParams name \"bFilterAVJournalEvents\" Value BOOLEAN false: AV JournalEvents are sent to the client as ChatV2 events. (Default) true: AV JournalEvents are not sent to the client as ChatV2 events.
	 * - optionalParams name \"bSubscribeDBMaintenance\" Value BOOLEAN false: ChatDatabaseMaintenance events are NOT sent to the client (default) true: ChatDatabaseMaintenance events are sent to the client
	 */
	public optionalParams?: ENetUC_Common.AsnOptionalParameters;
	/** if NOT present treat as false */
	public bSupportReactions?: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSubscribeEventsResult {
	public constructor(that: AsnChatSubscribeEventsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSubscribeEventsResult {
		return new AsnChatSubscribeEventsResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatSubscribeEventsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSubscribeEventsResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetDatabaseIDArgument {
	public constructor(that?: AsnChatGetDatabaseIDArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetDatabaseIDArgument {
		return new AsnChatGetDatabaseIDArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnChatGetDatabaseIDArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetDatabaseIDArgument",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetDatabaseIDResult {
	public constructor(that: AsnChatGetDatabaseIDResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetDatabaseIDResult {
		return new AsnChatGetDatabaseIDResult({
			iResult: 0,
			u8sDatabaseID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"u8sDatabaseID"
		];
		return p;
	}

	public static type = "AsnChatGetDatabaseIDResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetDatabaseIDResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Utf8String({ name: "u8sDatabaseID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Unique ID of the current server database */
	public u8sDatabaseID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetDiffUpdateArgument {
	public constructor(that?: AsnChatGetDiffUpdateArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetDiffUpdateArgument {
		return new AsnChatGetDiffUpdateArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"iLastKnownGlobTransactionID",
				"iMaxEvents",
				"u8sEventListCrossRefID",
				"u8sConversationID",
				"iMaxSequenceID"
			);
		}
		return p;
	}

	public static type = "AsnChatGetDiffUpdateArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetDiffUpdateArgument",
			...params,
			value: [
				new asn1ts.Integer({ name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iMaxEvents", idBlock: { optionalID: 1 } }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }),
				new asn1ts.Utf8String({ name: "u8sConversationID", idBlock: { optionalID: 3 } }),
				new asn1ts.Integer({ name: "iMaxSequenceID", idBlock: { optionalID: 4 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** last known global TransactionsID */
	public iLastKnownGlobTransactionID?: number;
	/** Max x events back (will be set to 100 by the server if not specified) */
	public iMaxEvents?: number;
	/** The event list that is sent back by the server based on this request contains this CrossRefID. This enables the client to assign events to a request sent by it. The CrossRefID must be assigned by the client and cannot be generated by the server and returned in the return. The reason for this is that there is no guarantee that the return will reach the client before the event list. */
	public u8sEventListCrossRefID?: string;
	/** Conversation ID (if not specified, Diff Update will be fetched for all conversations) */
	public u8sConversationID?: string;
	/** If a conversation ID has been specified, this parameter can be used to limit the update up to iMaxSequenceID. The client then only receives updates for data records that it already knows. New records can be fetched using paging. */
	public iMaxSequenceID?: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetDiffUpdateResult {
	public constructor(that: AsnChatGetDiffUpdateResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetDiffUpdateResult {
		return new AsnChatGetDiffUpdateResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatGetDiffUpdateResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetDiffUpdateResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationOverviewArgument {
	public constructor(that?: AsnChatGetConversationOverviewArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationOverviewArgument {
		return new AsnChatGetConversationOverviewArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"iLastKnownGlobTransactionID",
				"iMaxConversations",
				"u8sEventListCrossRefID",
				"iNumLastMessages",
				"bAddUnread"
			);
		}
		return p;
	}

	public static type = "AsnChatGetConversationOverviewArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationOverviewArgument",
			...params,
			value: [
				new asn1ts.Integer({ name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iMaxConversations", idBlock: { optionalID: 1 } }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }),
				new asn1ts.Integer({ name: "iNumLastMessages", idBlock: { optionalID: 3 } }),
				new asn1ts.Boolean({ name: "bAddUnread", idBlock: { optionalID: 4 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** last known global TransactionsID (for diff update) */
	public iLastKnownGlobTransactionID?: number;
	/** Conversation limit, all if not specified */
	public iMaxConversations?: number;
	/** The event list that is sent back by the server based on this request contains this CrossRefID. This enables the client to assign events to a request sent by it. The CrossRefID must be assigned by the client and cannot be generated by the server and returned in the return. The reason for this is that there is no guarantee that the return will reach the client before the event list. */
	public u8sEventListCrossRefID?: string;
	/** Number of the latest message events that are delivered for each conversation */
	public iNumLastMessages?: number;
	/** Provide unread message events for every requested conversation */
	public bAddUnread?: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationOverviewResult {
	public constructor(that: AsnChatGetConversationOverviewResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationOverviewResult {
		return new AsnChatGetConversationOverviewResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatGetConversationOverviewResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationOverviewResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatTextMessageArgument {
	public constructor(that: AsnChatTextMessageArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatTextMessageArgument {
		return new AsnChatTextMessageArgument({
			u8sRecipientURIs: new ENetUC_Common.UTF8StringList(),
			u8sMessage: "",
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sRecipientURIs",
			"u8sMessage",
			"u8sEventCrossRefID"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sConversationID",
				"u8sConversationName",
				"iConversationType",
				"iReplyToSequenceID"
			);
		}
		return p;
	}

	public static type = "AsnChatTextMessageArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatTextMessageArgument",
			...params,
			value: [
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sRecipientURIs" }),
				new asn1ts.Utf8String({ name: "u8sMessage" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Utf8String({ name: "u8sConversationID", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sConversationName", idBlock: { optionalID: 1 } }),
				new asn1ts.Integer({ name: "iConversationType", idBlock: { optionalID: 2 } }),
				new asn1ts.Integer({ name: "iReplyToSequenceID", idBlock: { optionalID: 3 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** URIs of the recipients, must be filled if the ConversationID is empty */
	public u8sRecipientURIs!: ENetUC_Common.UTF8StringList;
	/** Message that will be sent */
	public u8sMessage!: string;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
	/** Chat ID, can be empty if it is a 1: 1 chat and the recipient is named */
	public u8sConversationID?: string;
	/** Title of the Chatrooms */
	public u8sConversationName?: string;
	/** AsnConversationType enum for the type of chat. e.g. One-to-one, group, static, public ... */
	public iConversationType?: number;
	/** Text Message is a reply to another message with SequenceID = iReplyToSequenceID */
	public iReplyToSequenceID?: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatTextMessageResult {
	public constructor(that: AsnChatTextMessageResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatTextMessageResult {
		return new AsnChatTextMessageResult({
			iResult: 0,
			iConvSequenceID: 0,
			u8sConversationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iConvSequenceID",
			"u8sConversationID"
		];
		return p;
	}

	public static type = "AsnChatTextMessageResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatTextMessageResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Sequence ID des Events */
	public iConvSequenceID!: number;
	/** Reference ID for the chat, */
	public u8sConversationID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatBinaryMessageArgument {
	public constructor(that: AsnChatBinaryMessageArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatBinaryMessageArgument {
		return new AsnChatBinaryMessageArgument({
			u8sRecipientURIs: new ENetUC_Common.UTF8StringList(),
			u8sTransferID: "",
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sRecipientURIs",
			"u8sTransferID",
			"u8sEventCrossRefID"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sConversationID",
				"u8sMessage",
				"iConversationType",
				"iReplyToSequenceID",
				"u8sConversationName"
			);
		}
		return p;
	}

	public static type = "AsnChatBinaryMessageArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatBinaryMessageArgument",
			...params,
			value: [
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sRecipientURIs" }),
				new asn1ts.Utf8String({ name: "u8sTransferID" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Utf8String({ name: "u8sConversationID", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sMessage", idBlock: { optionalID: 1 } }),
				new asn1ts.Integer({ name: "iConversationType", idBlock: { optionalID: 2 } }),
				new asn1ts.Integer({ name: "iReplyToSequenceID", idBlock: { optionalID: 3 } }),
				new asn1ts.Utf8String({ name: "u8sConversationName", idBlock: { optionalID: 5 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** URIs of the recipient, must be filled if the ConversationID is empty */
	public u8sRecipientURIs!: ENetUC_Common.UTF8StringList;
	/** ID assigned by the BinaryTransfer Manager (The BinaryTransfer Manager takes care of the binary data, the chat only references it here) */
	public u8sTransferID!: string;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
	/** Chat ID, can be empty if it is a 1: 1 chat and the recipient is named */
	public u8sConversationID?: string;
	/** Binary message text, e.g. caption */
	public u8sMessage?: string;
	/** AsnConversationType enum for the type of chat. e.g. One-to-one, group, static, public ... */
	public iConversationType?: number;
	/** Binary Message is a reply to another message with SequenceID = iReplyToSequenceID */
	public iReplyToSequenceID?: number;
	/** Titel des Chatrooms */
	public u8sConversationName?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatBinaryMessageResult {
	public constructor(that: AsnChatBinaryMessageResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatBinaryMessageResult {
		return new AsnChatBinaryMessageResult({
			iResult: 0,
			iConvSequenceID: 0,
			u8sConversationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iConvSequenceID",
			"u8sConversationID"
		];
		return p;
	}

	public static type = "AsnChatBinaryMessageResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatBinaryMessageResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Sequence ID des Events */
	public iConvSequenceID!: number;
	/** Reference ID for the chat, */
	public u8sConversationID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnConversationIDChoice {
	public constructor(that?: AsnConversationIDChoice) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnConversationIDChoice {
		return new AsnConversationIDChoice();
	}

	public static type = "AsnConversationIDChoice";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnConversationIDChoice",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sPartnerURI", idBlock: { optionalID: 1 } })
			]
		});
	}

	public u8sConversationID?: string;
	public u8sPartnerURI?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatForwardMessageResult {
	public constructor(that: AsnChatForwardMessageResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatForwardMessageResult {
		return new AsnChatForwardMessageResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatForwardMessageResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatForwardMessageResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatUserlistModifyArgument {
	public constructor(that: AsnChatUserlistModifyArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatUserlistModifyArgument {
		return new AsnChatUserlistModifyArgument({
			u8sConversationID: "",
			iChatUserlistModify: 0,
			u8sUserURIs: new ENetUC_Common.UTF8StringList(),
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"iChatUserlistModify",
			"u8sUserURIs",
			"u8sEventCrossRefID"
		];
		return p;
	}

	public static type = "AsnChatUserlistModifyArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatUserlistModifyArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Integer({ name: "iChatUserlistModify" }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sUserURIs" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Reference ID for the chat */
	public u8sConversationID!: string;
	/** AsnChatUserlistModify enum added or removed for users */
	public iChatUserlistModify!: number;
	/** List of URIs that are added \/ removed, or URI of the user to be forwarded to */
	public u8sUserURIs!: ENetUC_Common.UTF8StringList;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatUserlistModifyResult {
	public constructor(that: AsnChatUserlistModifyResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatUserlistModifyResult {
		return new AsnChatUserlistModifyResult({
			iResult: 0,
			iConvSequenceID: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iConvSequenceID"
		];
		if (bIncludeOptionals)
			p.push("u8sConversationID");
		return p;
	}

	public static type = "AsnChatUserlistModifyResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatUserlistModifyResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Utf8String({ name: "u8sConversationID", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Sequence ID des Events */
	public iConvSequenceID!: number;
	/** New reference ID for the chat, e.g. when a 1: 1 chat becomes a conference (by adding a user) */
	public u8sConversationID?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatFindEventsArgument {
	public constructor(that: AsnChatFindEventsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatFindEventsArgument {
		return new AsnChatFindEventsArgument({
			u8sSearchString: "",
			iMaxEvents: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sSearchString",
			"iMaxEvents"
		];
		if (bIncludeOptionals) {
			p.push(
				"iOffset",
				"u8sConversationID"
			);
		}
		return p;
	}

	public static type = "AsnChatFindEventsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatFindEventsArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sSearchString" }),
				new asn1ts.Integer({ name: "iMaxEvents" }),
				new asn1ts.Integer({ name: "iOffset", optional: true }),
				new asn1ts.Utf8String({ name: "u8sConversationID", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** String to search for */
	public u8sSearchString!: string;
	/** Number of search results */
	public iMaxEvents!: number;
	/** Paging offset, 0 if not specified */
	public iOffset?: number;
	/** Can optionally be specified if you only want to search within a specific conversation. Otherwise, all of the user's conversations are searched. */
	public u8sConversationID?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetEventsRangeResult {
	public constructor(that: AsnChatGetEventsRangeResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetEventsRangeResult {
		return new AsnChatGetEventsRangeResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatGetEventsRangeResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetEventsRangeResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetBinaryMessageEventsResult {
	public constructor(that: AsnChatGetBinaryMessageEventsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetBinaryMessageEventsResult {
		return new AsnChatGetBinaryMessageEventsResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatGetBinaryMessageEventsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetBinaryMessageEventsResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnChatSequenceIDSet {
	public constructor(that?: AsnChatSequenceIDSet) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSequenceIDSet {
		return new AsnChatSequenceIDSet();
	}

	public static type = "AsnChatSequenceIDSet";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnChatSequenceIDSet",
			...params,
			value: [
				new asn1ts.Integer({ name: "asnSequenceIDs" }),
				new asn1ts.Integer({ name: "iLastSequenceID" })
			]
		});
	}

	public asnSequenceIDs?: ENetUC_Common.SEQInteger;
	public iLastSequenceID?: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetMessagesStatusResult {
	public constructor(that: AsnChatSetMessagesStatusResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetMessagesStatusResult {
		return new AsnChatSetMessagesStatusResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatSetMessagesStatusResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetMessagesStatusResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationsArgument {
	public constructor(that?: AsnChatGetConversationsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationsArgument {
		return new AsnChatGetConversationsArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"u8sConversationID",
				"u8sContactURI",
				"bStaticConversations"
			);
		}
		return p;
	}

	public static type = "AsnChatGetConversationsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationsArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sContactURI", idBlock: { optionalID: 1 } }),
				new asn1ts.Boolean({ name: "bStaticConversations", idBlock: { optionalID: 2 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** ID of the chat room, if empty all of the user */
	public u8sConversationID?: string;
	/** delivers all conversations in which the requesting user and u8sContactURI are participants */
	public u8sContactURI?: string;
	/** Get information about static conversations */
	public bStaticConversations?: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationIDArgument {
	public constructor(that: AsnChatGetConversationIDArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationIDArgument {
		return new AsnChatGetConversationIDArgument({
			u8sContactURI: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sContactURI"
		];
		return p;
	}

	public static type = "AsnChatGetConversationIDArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationIDArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sContactURI" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Contact for whom the ConversationID should be queried */
	public u8sContactURI!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationIDResult {
	public constructor(that: AsnChatGetConversationIDResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationIDResult {
		return new AsnChatGetConversationIDResult({
			iResult: 0,
			u8sConversationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"u8sConversationID"
		];
		return p;
	}

	public static type = "AsnChatGetConversationIDResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationIDResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Conversation ID */
	public u8sConversationID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatForwardArgument {
	public constructor(that: AsnChatForwardArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatForwardArgument {
		return new AsnChatForwardArgument({
			u8sConversationID: "",
			u8sForwardURI: "",
			u8sForwardToURIs: new ENetUC_Common.UTF8StringList(),
			u8sMessage: "",
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sForwardURI",
			"u8sForwardToURIs",
			"u8sMessage",
			"u8sEventCrossRefID"
		];
		return p;
	}

	public static type = "AsnChatForwardArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatForwardArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sForwardURI" }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sForwardToURIs" }),
				new asn1ts.Utf8String({ name: "u8sMessage" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** ID of the conversation from which to forward. The forwarding may result in a new ConversationID */
	public u8sConversationID!: string;
	/** URI of the subscriber who is forwarded */
	public u8sForwardURI!: string;
	/** URIs of the participants to be forwarded to */
	public u8sForwardToURIs!: ENetUC_Common.UTF8StringList;
	/** Forwarding message, will be sent to the participants to whom the forwarding will take place */
	public u8sMessage!: string;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatForwardResult {
	public constructor(that: AsnChatForwardResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatForwardResult {
		return new AsnChatForwardResult({
			iResult: 0,
			iConvSequenceID: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iConvSequenceID"
		];
		return p;
	}

	public static type = "AsnChatForwardResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatForwardResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Sequence ID des Events */
	public iConvSequenceID!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatIsGlobalDisabledArgument {
	public constructor(that?: AsnChatIsGlobalDisabledArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatIsGlobalDisabledArgument {
		return new AsnChatIsGlobalDisabledArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnChatIsGlobalDisabledArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatIsGlobalDisabledArgument",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatIsGlobalDisabledResult {
	public constructor(that: AsnChatIsGlobalDisabledResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatIsGlobalDisabledResult {
		return new AsnChatIsGlobalDisabledResult({
			iResult: 0,
			bDisabled: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"bDisabled"
		];
		return p;
	}

	public static type = "AsnChatIsGlobalDisabledResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatIsGlobalDisabledResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Boolean({ name: "bDisabled" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** true: Chat ist global disabled, false: Chat ist global enabled */
	public bDisabled!: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatWatchConversationArgument {
	public constructor(that: AsnChatWatchConversationArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatWatchConversationArgument {
		return new AsnChatWatchConversationArgument({
			iWatchMode: 0,
			u8sConversationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iWatchMode",
			"u8sConversationID"
		];
		if (bIncludeOptionals) {
			p.push(
				"iConvSequenceID",
				"iMaxEvents",
				"u8sEventListCrossRefID"
			);
		}
		return p;
	}

	public static type = "AsnChatWatchConversationArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatWatchConversationArgument",
			...params,
			value: [
				new asn1ts.Integer({ name: "iWatchMode" }),
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Integer({ name: "iConvSequenceID", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iMaxEvents", idBlock: { optionalID: 1 } }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatWatchModeEnum) */
	public iWatchMode!: number;
	/** ConversationID subscribe\/unsubscribe */
	public u8sConversationID!: string;
	/** last SequenceId known in the client for the chat room (without an iConvSequenceID no events are implicitly delivered) */
	public iConvSequenceID?: number;
	/** Max x events back (will be set to 100 by the server if not specified) */
	public iMaxEvents?: number;
	/** The event list that is sent back by the server based on this request contains this CrossRefID. This enables the client to assign events to a request sent by it. The CrossRefID must be assigned by the client and cannot be generated by the server and returned in the return. The reason for this is that there is no guarantee that the return will reach the client before the event list. */
	public u8sEventListCrossRefID?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatWatchConversationResult {
	public constructor(that: AsnChatWatchConversationResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatWatchConversationResult {
		return new AsnChatWatchConversationResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatWatchConversationResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatWatchConversationResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetUserlistArgument {
	public constructor(that: AsnChatSetUserlistArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetUserlistArgument {
		return new AsnChatSetUserlistArgument({
			u8sConversationID: "",
			u8sUserURIs: new ENetUC_Common.UTF8StringList(),
			u8sEventListCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sUserURIs",
			"u8sEventListCrossRefID"
		];
		return p;
	}

	public static type = "AsnChatSetUserlistArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetUserlistArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sUserURIs" }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Reference ID for the chat */
	public u8sConversationID!: string;
	/** Complete list of URIs that should be the new conversation participants from now on */
	public u8sUserURIs!: ENetUC_Common.UTF8StringList;
	/** The event list that is sent back by the server based on this request contains this CrossRefID. This enables the client to assign events to a request sent by it. The CrossRefID must be assigned by the client and cannot be generated by the server and returned in the return. The reason for this is that there is no guarantee that the return will reach the client before the event list. */
	public u8sEventListCrossRefID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetUserlistResult {
	public constructor(that: AsnChatSetUserlistResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetUserlistResult {
		return new AsnChatSetUserlistResult({
			iResult: 0,
			iConvSequenceID: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iConvSequenceID"
		];
		return p;
	}

	public static type = "AsnChatSetUserlistResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetUserlistResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Sequence ID des Events */
	public iConvSequenceID!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatUserStatusArgument {
	public constructor(that: AsnChatUserStatusArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatUserStatusArgument {
		return new AsnChatUserStatusArgument({
			u8sConversationID: "",
			u8sSenderURI: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sSenderURI"
		];
		if (bIncludeOptionals)
			p.push("bUserTyping");
		return p;
	}

	public static type = "AsnChatUserStatusArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatUserStatusArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sSenderURI" }),
				new asn1ts.Boolean({ name: "bUserTyping", idBlock: { optionalID: 0 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** ID of Chats (Chatraumes) */
	public u8sConversationID!: string;
	/** Contact URI of the sender of the message */
	public u8sSenderURI!: string;
	/** User types a message or not. */
	public bUserTyping?: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatDatabaseIDChangedArgument {
	public constructor(that: AsnChatDatabaseIDChangedArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatDatabaseIDChangedArgument {
		return new AsnChatDatabaseIDChangedArgument({
			u8sDatabaseID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sDatabaseID"
		];
		return p;
	}

	public static type = "AsnChatDatabaseIDChangedArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatDatabaseIDChangedArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sDatabaseID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Unique ID of the current server database */
	public u8sDatabaseID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatDatabaseMaintenanceArgument {
	public constructor(that: AsnChatDatabaseMaintenanceArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatDatabaseMaintenanceArgument {
		return new AsnChatDatabaseMaintenanceArgument({
			iDeletedToSequenceID: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iDeletedToSequenceID"
		];
		return p;
	}

	public static type = "AsnChatDatabaseMaintenanceArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatDatabaseMaintenanceArgument",
			...params,
			value: [
				new asn1ts.Integer({ name: "iDeletedToSequenceID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Sequence ID up to which TExt messages were deleted */
	public iDeletedToSequenceID!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatMuteConversationArgument {
	public constructor(that: AsnChatMuteConversationArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatMuteConversationArgument {
		return new AsnChatMuteConversationArgument({
			u8sConversationID: "",
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sEventCrossRefID"
		];
		if (bIncludeOptionals)
			p.push("asnMutedUntilTime");
		return p;
	}

	public static type = "AsnChatMuteConversationArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatMuteConversationArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Real({ name: "asnMutedUntilTime", idBlock: { optionalID: 0 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** Reference ID for the chat */
	public u8sConversationID!: string;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
	/** Time until this channel should be handled muted (UTC time) */
	public asnMutedUntilTime?: Date;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatMuteConversationResult {
	public constructor(that: AsnChatMuteConversationResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatMuteConversationResult {
		return new AsnChatMuteConversationResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatMuteConversationResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatMuteConversationResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatUnmuteConversationArgument {
	public constructor(that: AsnChatUnmuteConversationArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatUnmuteConversationArgument {
		return new AsnChatUnmuteConversationArgument({
			u8sConversationID: "",
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sEventCrossRefID"
		];
		return p;
	}

	public static type = "AsnChatUnmuteConversationArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatUnmuteConversationArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Reference ID for the chat */
	public u8sConversationID!: string;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatUnmuteConversationResult {
	public constructor(that: AsnChatUnmuteConversationResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatUnmuteConversationResult {
		return new AsnChatUnmuteConversationResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatUnmuteConversationResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatUnmuteConversationResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatMuteStatusChangedArgument {
	public constructor(that: AsnChatMuteStatusChangedArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatMuteStatusChangedArgument {
		return new AsnChatMuteStatusChangedArgument({
			u8sConversationID: "",
			u8sSenderURI: "",
			u8sEventCrossRefID: "",
			bMuted: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sSenderURI",
			"u8sEventCrossRefID",
			"bMuted"
		];
		if (bIncludeOptionals)
			p.push("asnMutedUntilTime");
		return p;
	}

	public static type = "AsnChatMuteStatusChangedArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatMuteStatusChangedArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sSenderURI" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Boolean({ name: "bMuted" }),
				new asn1ts.Real({ name: "asnMutedUntilTime", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** ID of Chats (Chatraumes) */
	public u8sConversationID!: string;
	/** Contact URI of the sender of the message */
	public u8sSenderURI!: string;
	/** For the assignment of events to the corresponding request. */
	public u8sEventCrossRefID!: string;
	/** TRUE: channel should be handled as muted */
	public bMuted!: boolean;
	/** Time until this channel should be handled muted (UTC time) */
	public asnMutedUntilTime?: Date;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetConversationAvatarArgument {
	public constructor(that: AsnChatSetConversationAvatarArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetConversationAvatarArgument {
		return new AsnChatSetConversationAvatarArgument({
			u8sConversationID: "",
			u8sEventCrossRefID: "",
			u8sImageData: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sEventCrossRefID",
			"u8sImageData"
		];
		return p;
	}

	public static type = "AsnChatSetConversationAvatarArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetConversationAvatarArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Utf8String({ name: "u8sImageData" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Reference ID for the chat */
	public u8sConversationID!: string;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
	/** binaryData (base64 encoded jpg) of the image */
	public u8sImageData!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetConversationAvatarResult {
	public constructor(that: AsnChatSetConversationAvatarResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetConversationAvatarResult {
		return new AsnChatSetConversationAvatarResult({
			iResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult"
		];
		return p;
	}

	public static type = "AsnChatSetConversationAvatarResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetConversationAvatarResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationAvatarArgument {
	public constructor(that: AsnChatGetConversationAvatarArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationAvatarArgument {
		return new AsnChatGetConversationAvatarArgument({
			u8sConversationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID"
		];
		if (bIncludeOptionals)
			p.push("u8sKnownHash");
		return p;
	}

	public static type = "AsnChatGetConversationAvatarArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationAvatarArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sKnownHash", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** Reference ID for the chat */
	public u8sConversationID!: string;
	/** If the client has an image already, it sends its hash so the server can determine if the image has changed. */
	public u8sKnownHash?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationAvatarResult {
	public constructor(that: AsnChatGetConversationAvatarResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationAvatarResult {
		return new AsnChatGetConversationAvatarResult({
			iResult: 0,
			iImageResult: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iImageResult"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sImageHash",
				"u8sImageData"
			);
		}
		return p;
	}

	public static type = "AsnChatGetConversationAvatarResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationAvatarResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iImageResult" }),
				new asn1ts.Utf8String({ name: "u8sImageHash", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sImageData", idBlock: { optionalID: 1 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** (see EnumRequestConversationAvatarResult - result of the call, if there is a new image, no image at all or the image hash has not changed.) */
	public iImageResult!: number;
	/** If an image is send to the client, this field contains the corresponding hash value for that image. */
	public u8sImageHash?: string;
	/** If an image is send to the client, this field contains the binaryData (base64 encoded jpg) */
	public u8sImageData?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatConversationAvatarChangedArgument {
	public constructor(that: AsnChatConversationAvatarChangedArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatConversationAvatarChangedArgument {
		return new AsnChatConversationAvatarChangedArgument({
			u8sConversationID: "",
			u8sSenderURI: "",
			u8sImageHash: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sSenderURI",
			"u8sImageHash"
		];
		return p;
	}

	public static type = "AsnChatConversationAvatarChangedArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatConversationAvatarChangedArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sSenderURI" }),
				new asn1ts.Utf8String({ name: "u8sImageHash" }),
				new asn1ts.Extension()
			]
		});
	}

	/** ID of Chats (Chatraumes) */
	public u8sConversationID!: string;
	/** Contact URI of the sender of the message (who changed the avatar) */
	public u8sSenderURI!: string;
	/** the client can compare with its internal hash and request the new avatar with asnChatGetConversationAvatar */
	public u8sImageHash!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatReactionsEmoji {
	public constructor(that: AsnChatReactionsEmoji) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatReactionsEmoji {
		return new AsnChatReactionsEmoji({
			u8sEmoji: "",
			u8sUsers: new ENetUC_Common.UTF8StringList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sEmoji",
			"u8sUsers"
		];
		return p;
	}

	public static type = "AsnChatReactionsEmoji";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatReactionsEmoji",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sEmoji" }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sUsers" }),
				new asn1ts.Extension()
			]
		});
	}

	/** single Emoji */
	public u8sEmoji!: string;
	/** Contact URIs voted */
	public u8sUsers!: ENetUC_Common.UTF8StringList;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetReactionArgument {
	public constructor(that: AsnChatSetReactionArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetReactionArgument {
		return new AsnChatSetReactionArgument({
			u8sConversationID: "",
			iConvSequenceID: 0,
			u8sEmoji: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"iConvSequenceID",
			"u8sEmoji"
		];
		return p;
	}

	public static type = "AsnChatSetReactionArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetReactionArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Utf8String({ name: "u8sEmoji" }),
				new asn1ts.Extension()
			]
		});
	}

	/**
	 * primaryKey (u8sConversationID, iConvSequenceID)
	 * Conversation ID (of the room)
	 */
	public u8sConversationID!: string;
	/** Chat Sequence ID */
	public iConvSequenceID!: number;
	/**
	 * payload
	 * a single emoji
	 */
	public u8sEmoji!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetReactionResult {
	public constructor(that?: AsnChatSetReactionResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetReactionResult {
		return new AsnChatSetReactionResult();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnChatSetReactionResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetReactionResult",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnChatParties extends Array<AsnChatParty> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnChatParty.getASN1Schema()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatForwardMessageArgument {
	public constructor(that: AsnChatForwardMessageArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatForwardMessageArgument {
		return new AsnChatForwardMessageArgument({
			u8sSourceConversationID: "",
			iSourceSequenceID: 0,
			asnForwardDestinationIDChoice: AsnConversationIDChoice["initEmpty"].call(0),
			u8sEventCrossRefID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sSourceConversationID",
			"iSourceSequenceID",
			"asnForwardDestinationIDChoice",
			"u8sEventCrossRefID"
		];
		return p;
	}

	public static type = "AsnChatForwardMessageArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatForwardMessageArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sSourceConversationID" }),
				new asn1ts.Integer({ name: "iSourceSequenceID" }),
				AsnConversationIDChoice.getASN1Schema({ name: "asnForwardDestinationIDChoice" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** ConversationID of the forwarded Message */
	public u8sSourceConversationID!: string;
	/** Sequence ID of the forwarded Message */
	public iSourceSequenceID!: number;
	/** Destination for forward */
	public asnForwardDestinationIDChoice!: AsnConversationIDChoice;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetEventsRangeArgument {
	public constructor(that: AsnChatGetEventsRangeArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetEventsRangeArgument {
		return new AsnChatGetEventsRangeArgument({
			asnConversationIDChoice: AsnConversationIDChoice["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"asnConversationIDChoice"
		];
		if (bIncludeOptionals) {
			p.push(
				"iSequenceID",
				"iNumLessThanSeqID",
				"iNumGreaterThanOrEqualSeqID",
				"u8sEventListCrossRefID"
			);
		}
		return p;
	}

	public static type = "AsnChatGetEventsRangeArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetEventsRangeArgument",
			...params,
			value: [
				AsnConversationIDChoice.getASN1Schema({ name: "asnConversationIDChoice" }),
				new asn1ts.Integer({ name: "iSequenceID", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iNumLessThanSeqID", idBlock: { optionalID: 1 } }),
				new asn1ts.Integer({ name: "iNumGreaterThanOrEqualSeqID", idBlock: { optionalID: 2 } }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** Conversation ID Choice */
	public asnConversationIDChoice!: AsnConversationIDChoice;
	/** Starting point for the range. The parameters iNumLessThanSeqID and iNumGreaterThanOrEqualSeqID can be used to determine how many events will be returned before and after the iSquenceID. If iSequenceID is not specified, the highest (newest) SequenceID + 1 in the conversation is used. */
	public iSequenceID?: number;
	/** Maximum number of events that are BEFORE the iSequenceID. Restricted to 100 if not specified. */
	public iNumLessThanSeqID?: number;
	/** Maximum number of events that are AFTER the iSequenceID. Is set to 0 if not specified. If no iSequenceID was specified, iNumGreaterThanOrEqualSeqID is ignored. */
	public iNumGreaterThanOrEqualSeqID?: number;
	/** The event list that is sent back by the server based on this request contains this CrossRefID. This enables the client to assign events to a request sent by it. The CrossRefID must be assigned by the client and cannot be generated by the server and returned in the return. The reason for this is that there is no guarantee that the return will reach the client before the event list. */
	public u8sEventListCrossRefID?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetBinaryMessageEventsArgument {
	public constructor(that: AsnChatGetBinaryMessageEventsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetBinaryMessageEventsArgument {
		return new AsnChatGetBinaryMessageEventsArgument({
			asnConversationIDChoice: AsnConversationIDChoice["initEmpty"].call(0),
			iPageSize: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"asnConversationIDChoice",
			"iPageSize"
		];
		if (bIncludeOptionals) {
			p.push(
				"iPageOffset",
				"iLastKnownGlobTransactionID",
				"u8sEventListCrossRefID"
			);
		}
		return p;
	}

	public static type = "AsnChatGetBinaryMessageEventsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetBinaryMessageEventsArgument",
			...params,
			value: [
				AsnConversationIDChoice.getASN1Schema({ name: "asnConversationIDChoice" }),
				new asn1ts.Integer({ name: "iPageSize" }),
				new asn1ts.Integer({ name: "iPageOffset", idBlock: { optionalID: 0 } }),
				new asn1ts.Integer({ name: "iLastKnownGlobTransactionID", idBlock: { optionalID: 1 } }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", idBlock: { optionalID: 2 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** Conversation ID Choice */
	public asnConversationIDChoice!: AsnConversationIDChoice;
	/** Number of elements for the page. Allowed values: 1-100 */
	public iPageSize!: number;
	/** Offset for Paging, Default = 0. iPageOffset = 0 returns the first Page. For example, if iPageSize = 10, the iPageOffset for the second page would be 10, for the third 20 and so on. */
	public iPageOffset?: number;
	/** can be set to request a diff update */
	public iLastKnownGlobTransactionID?: number;
	/** The event list returned by the server based on this request contains this CrossRefID. This enables the client to match events to a request that it has sent. */
	public u8sEventListCrossRefID?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatSetMessagesStatusArgument {
	public constructor(that: AsnChatSetMessagesStatusArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatSetMessagesStatusArgument {
		return new AsnChatSetMessagesStatusArgument({
			u8sConversationID: "",
			iStatus: 0,
			u8sEventCrossRefID: "",
			asnSequenceIDSet: AsnChatSequenceIDSet["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"iStatus",
			"u8sEventCrossRefID",
			"asnSequenceIDSet"
		];
		return p;
	}

	public static type = "AsnChatSetMessagesStatusArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatSetMessagesStatusArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Integer({ name: "iStatus" }),
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				AsnChatSequenceIDSet.getASN1Schema({ name: "asnSequenceIDSet" }),
				new asn1ts.Extension()
			]
		});
	}

	/** ID of Chats */
	public u8sConversationID!: string;
	/** Status Type (see enum AsnChatMessageStatus) */
	public iStatus!: number;
	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
	/** Description of the sequence IDs for which the status is to be set */
	public asnSequenceIDSet!: AsnChatSequenceIDSet;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnChatReactionsEmojiList extends Array<AsnChatReactionsEmoji> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnChatReactionsEmoji.getASN1Schema()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatReactionsResult {
	public constructor(that: AsnChatReactionsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatReactionsResult {
		return new AsnChatReactionsResult({
			u8sConversationID: "",
			iConvSequenceID: 0,
			iTransactionID: 0,
			asnEmojiList: new AsnChatReactionsEmojiList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"iConvSequenceID",
			"iTransactionID",
			"asnEmojiList"
		];
		return p;
	}

	public static type = "AsnChatReactionsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatReactionsResult",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Integer({ name: "iTransactionID" }),
				AsnChatReactionsEmojiList.getASN1Schema({ name: "asnEmojiList" }),
				new asn1ts.Extension()
			]
		});
	}

	/**
	 * primaryKey\/FK (u8sConversationID, iConvSequenceID)
	 * je nach verwendeter sprache\/implementierung ist das optional\/mandatory.
	 * ein JavaScript kann evtl. ueber ein closure zugreifen ...
	 * Conversation ID (of the room)
	 */
	public u8sConversationID!: string;
	/** Chat Sequence ID */
	public iConvSequenceID!: number;
	/** the TransactionID */
	public iTransactionID!: number;
	/**
	 * payload
	 * eine map von &lt;emoji&gt; -&gt; &lt;lstUser&gt;
	 */
	public asnEmojiList!: AsnChatReactionsEmojiList;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatEventConversation {
	public constructor(that?: AsnChatEventConversation) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatEventConversation {
		return new AsnChatEventConversation();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"u8sConversationName",
				"asnChatParties",
				"iChatUserlistModify",
				"u8sUsersModified",
				"u8sForwardedFromURI",
				"u8sForwardedURI",
				"u8sLinkedConversationID",
				"iConversationType",
				"bDeleted",
				"optionalParams"
			);
		}
		return p;
	}

	public static type = "AsnChatEventConversation";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatEventConversation",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationName", idBlock: { optionalID: 0 } }),
				AsnChatParties.getASN1Schema({ name: "asnChatParties", idBlock: { optionalID: 1 } }),
				new asn1ts.Integer({ name: "iChatUserlistModify", idBlock: { optionalID: 2 } }),
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sUsersModified", idBlock: { optionalID: 3 } }),
				new asn1ts.Utf8String({ name: "u8sForwardedFromURI", idBlock: { optionalID: 4 } }),
				new asn1ts.Utf8String({ name: "u8sForwardedURI", idBlock: { optionalID: 5 } }),
				new asn1ts.Utf8String({ name: "u8sLinkedConversationID", idBlock: { optionalID: 6 } }),
				new asn1ts.Integer({ name: "iConversationType", idBlock: { optionalID: 7 } }),
				new asn1ts.Boolean({ name: "bDeleted", idBlock: { optionalID: 8 } }),
				ENetUC_Common.AsnOptionalParameters.getASN1Schema({ name: "optionalParams", idBlock: { optionalID: 9 } }),
				new asn1ts.Extension()
			]
		});
	}

	/**
	 * chatname (changed)
	 * Name of the conversation
	 */
	public u8sConversationName?: string;
	/**
	 * conversationparties (changed)
	 * Chat participants with their permissions (after adding, removing a party)
	 */
	public asnChatParties?: AsnChatParties;
	/**
	 * users added, removed
	 * AsnChatUserlistModify enum added or removed for users
	 */
	public iChatUserlistModify?: number;
	/** Contact URIs of added, removed contacts */
	public u8sUsersModified?: ENetUC_Common.UTF8StringList;
	/**
	 * forwarding
	 * URI of the user who forwarded
	 */
	public u8sForwardedFromURI?: string;
	/** URI of the user who was forwarded */
	public u8sForwardedURI?: string;
	/**
	 * link to other conversation
	 * Link to another conversation if group chat was created from one-to-one or if it was forwarded.
	 */
	public u8sLinkedConversationID?: string;
	/**
	 * Type of conversation
	 * AsnConversationType enum for the type of chat. e.g. One-to-one, group, static, public ...
	 */
	public iConversationType?: number;
	/**
	 * Conversation Deleted
	 * Conversation has been deleted
	 */
	public bDeleted?: boolean;
	/**
	 * **Liste der optionalen Parameter:*
	 * - optionalParams Name \"IsMuted\" Value BOOLEAN ('TRUE' für aktiv) für den Client des Empfängers soll diese ConversationID gemuted sein
	 * - optionalParams Name \"MutedUntilTime\"  Value AsnSystemTime Time until this conversationID should be handled as muted (UTC time)
	 * - optionalParams Name \"AvatarID\" Value UTF8String - AvatarID\/hash für den jeweiligen Chat - kann via asnChatGetConversationAvatar abgeholt werden
	 * Optional parameters
	 */
	public optionalParams?: ENetUC_Common.AsnOptionalParameters;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatConversation {
	public constructor(that: AsnChatConversation) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatConversation {
		return new AsnChatConversation({
			u8sConversationID: "",
			u8sConversationName: "",
			iConversationType: 0,
			iConvSequenceID: 0,
			iGlobTransactionID: 0,
			asnChatParties: new AsnChatParties()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID",
			"u8sConversationName",
			"iConversationType",
			"iConvSequenceID",
			"iGlobTransactionID",
			"asnChatParties"
		];
		return p;
	}

	public static type = "AsnChatConversation";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatConversation",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Utf8String({ name: "u8sConversationName" }),
				new asn1ts.Integer({ name: "iConversationType" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Integer({ name: "iGlobTransactionID" }),
				AsnChatParties.getASN1Schema({ name: "asnChatParties" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Conversation ID (of the room) */
	public u8sConversationID!: string;
	/** Name of the conversation */
	public u8sConversationName!: string;
	/** AsnConversationType enum for the type of chat. e.g. One-to-one, group, static, public ... */
	public iConversationType!: number;
	/** Chat Sequence ID */
	public iConvSequenceID!: number;
	/** globale Transaction ID */
	public iGlobTransactionID!: number;
	/** Chat participants with their permissions */
	public asnChatParties!: AsnChatParties;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnChatConversationList extends Array<AsnChatConversation> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnChatConversation.getASN1Schema()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatGetConversationsResult {
	public constructor(that: AsnChatGetConversationsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatGetConversationsResult {
		return new AsnChatGetConversationsResult({
			iResult: 0,
			asnConversationList: new AsnChatConversationList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"asnConversationList"
		];
		return p;
	}

	public static type = "AsnChatGetConversationsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatGetConversationsResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				AsnChatConversationList.getASN1Schema({ name: "asnConversationList" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Description of the conversations */
	public asnConversationList!: AsnChatConversationList;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatEvent {
	public constructor(that: AsnChatEvent) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatEvent {
		return new AsnChatEvent({
			u8sEventCrossRefID: "",
			u8sConversationID: "",
			iConvSequenceID: 0,
			iGlobTransactionID: 0,
			bUpdate: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sEventCrossRefID",
			"u8sConversationID",
			"iConvSequenceID",
			"iGlobTransactionID",
			"bUpdate"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sSenderURI",
				"asnCreateTime",
				"asnChatMessage",
				"asnChatConversation",
				"iError",
				"optionalParams"
			);
		}
		return p;
	}

	public static type = "AsnChatEvent";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatEvent",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sEventCrossRefID" }),
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Integer({ name: "iConvSequenceID" }),
				new asn1ts.Integer({ name: "iGlobTransactionID" }),
				new asn1ts.Boolean({ name: "bUpdate" }),
				new asn1ts.Utf8String({ name: "u8sSenderURI", idBlock: { optionalID: 0 } }),
				new asn1ts.Real({ name: "asnCreateTime", idBlock: { optionalID: 1 } }),
				AsnChatEventMessage.getASN1Schema({ name: "asnChatMessage", idBlock: { optionalID: 2 } }),
				AsnChatEventConversation.getASN1Schema({ name: "asnChatConversation", idBlock: { optionalID: 3 } }),
				new asn1ts.Integer({ name: "iError", idBlock: { optionalID: 4 } }),
				ENetUC_Common.AsnOptionalParameters.getASN1Schema({ name: "optionalParams", idBlock: { optionalID: 5 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** For the assignment of events to a request. u8sEventCrossRefID must not be longer than 80 characters! */
	public u8sEventCrossRefID!: string;
	/** Conversation ID (of the room) */
	public u8sConversationID!: string;
	/** Index of the event within the corresponding conversation. If iConvSequenceID = 0, the event changes communicated to a conversation, but which should not be visible in the course of the conversation. e.g. Update the iLastReadSequenceID of a party in multi-user chat */
	public iConvSequenceID!: number;
	/** global transaction ID */
	public iGlobTransactionID!: number;
	/** false = new data record, true = update for existing data record */
	public bUpdate!: boolean;
	/** Contact URI of the sender of the message. e.g. 'sip: jan\@estos.de' */
	public u8sSenderURI?: string;
	/** Time at which the event was triggered (e.g. when a read revision was sent for a user) */
	public asnCreateTime?: Date;
	/**
	 * message (changed)
	 * A text message, binary message, or journal entry
	 */
	public asnChatMessage?: AsnChatEventMessage;
	/**
	 * conversation, users, name (changed)
	 * Conversation description
	 */
	public asnChatConversation?: AsnChatEventConversation;
	/** error code */
	/** (see AsnChatResultEnum) */
	public iError?: number;
	/**
	 * **Liste der optionalen Parameter:*
	 * - optionalParams Name \"IsMuted\" Value BOOLEAN ('TRUE' für aktiv) für den Client des Empfängers soll diese ConversationID gemuted sein
	 * - optionalParams Name \"AvatarID\" Value UTF8String - AvatarID\/hash für den jeweiligen Chat - kann via asnChatGetConversationAvatar abgeholt werden
	 */
	public optionalParams?: ENetUC_Common.AsnOptionalParameters;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatEventMessage {
	public constructor(that?: AsnChatEventMessage) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatEventMessage {
		return new AsnChatEventMessage();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"u8sMessage",
				"asnBinaryDescription",
				"journalEntry",
				"asnDeliverTime",
				"asnReadTime",
				"bRead",
				"bDeleted",
				"asnReplyToEvent",
				"u8sForwardOrigin",
				"asnReactions"
			);
		}
		return p;
	}

	public static type = "AsnChatEventMessage";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatEventMessage",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sMessage", idBlock: { optionalID: 0 } }),
				ENetUC_BinaryTransfer.AsnBinaryTransferMetaData.getASN1Schema({ name: "asnBinaryDescription", idBlock: { optionalID: 1 } }),
				ENetUC_Journal.AsnNetDatabaseJournal.getASN1Schema({ name: "journalEntry", idBlock: { optionalID: 2 } }),
				new asn1ts.Real({ name: "asnDeliverTime", idBlock: { optionalID: 3 } }),
				new asn1ts.Real({ name: "asnReadTime", idBlock: { optionalID: 4 } }),
				new asn1ts.Boolean({ name: "bRead", idBlock: { optionalID: 5 } }),
				new asn1ts.Boolean({ name: "bDeleted", idBlock: { optionalID: 6 } }),
				AsnChatEvent.getASN1Schema({ name: "asnReplyToEvent", idBlock: { optionalID: 7 } }),
				new asn1ts.Utf8String({ name: "u8sForwardOrigin", idBlock: { optionalID: 8 } }),
				AsnChatReactionsEmojiList.getASN1Schema({ name: "asnReactions", idBlock: { optionalID: 9 } }),
				new asn1ts.Extension()
			]
		});
	}

	/**
	 * textmessage
	 * Chat message
	 */
	public u8sMessage?: string;
	/**
	 * binarymessage
	 * Description of the binary data
	 */
	public asnBinaryDescription?: ENetUC_BinaryTransfer.AsnBinaryTransferMetaData;
	/**
	 * journalentry
	 * Journal entry (CTI \/ AV)
	 */
	public journalEntry?: ENetUC_Journal.AsnNetDatabaseJournal;
	/**
	 * messageupdate
	 * Time at which the message was delivered to the recipient
	 */
	public asnDeliverTime?: Date;
	/** Time at which the message was read by the recipient */
	public asnReadTime?: Date;
	/** Message was read by the recipient */
	public bRead?: boolean;
	/** Message has been deleted */
	public bDeleted?: boolean;
	/**
	 * reply
	 * If this parameter exists, this message is a reply to the in Message contained asnReplyToEvent
	 */
	public asnReplyToEvent?: AsnChatEvent;
	/**
	 * message forward&lt;br \/&gt;
	 * SIP URI of the original sender of a forwarded message. If this parameter is set, this is a forwarded message.
	 */
	public u8sForwardOrigin?: string;
	/**
	 * reactions
	 * Reactions to this message
	 */
	public asnReactions?: AsnChatReactionsEmojiList;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnChatEventList extends Array<AsnChatEvent> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnChatEvent.getASN1Schema()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatFindEventsResult {
	public constructor(that: AsnChatFindEventsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatFindEventsResult {
		return new AsnChatFindEventsResult({
			iResult: 0,
			iNumTotalResults: 0,
			asnChatEventList: new AsnChatEventList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iResult",
			"iNumTotalResults",
			"asnChatEventList"
		];
		return p;
	}

	public static type = "AsnChatFindEventsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatFindEventsResult",
			...params,
			value: [
				new asn1ts.Integer({ name: "iResult" }),
				new asn1ts.Integer({ name: "iNumTotalResults" }),
				AsnChatEventList.getASN1Schema({ name: "asnChatEventList" }),
				new asn1ts.Extension()
			]
		});
	}

	/** (see AsnChatResultEnum) */
	public iResult!: number;
	/** Total search results (asnChatEventList is limited to AsnChatFindEventsArgument.iMaxEvents) */
	public iNumTotalResults!: number;
	/** Paged Search Result */
	public asnChatEventList!: AsnChatEventList;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnChatEventArgument {
	public constructor(that: AsnChatEventArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatEventArgument {
		return new AsnChatEventArgument({
			asnChatEventList: new AsnChatEventList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"asnChatEventList"
		];
		if (bIncludeOptionals) {
			p.push(
				"u8sEventListCrossRefID",
				"bLastSegment",
				"optionalParams"
			);
		}
		return p;
	}

	public static type = "AsnChatEventArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatEventArgument",
			...params,
			value: [
				AsnChatEventList.getASN1Schema({ name: "asnChatEventList" }),
				new asn1ts.Utf8String({ name: "u8sEventListCrossRefID", optional: true }),
				new asn1ts.Boolean({ name: "bLastSegment", optional: true }),
				ENetUC_Common.AsnOptionalParameters.getASN1Schema({ name: "optionalParams", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** Events in Chat */
	public asnChatEventList!: AsnChatEventList;
	/** Request to EventList Correlator */
	public u8sEventListCrossRefID?: string;
	/** last segment for this u8sEventListCrossRefID, TRUE if this segment is the last in a list of related event lists. */
	public bLastSegment?: boolean;
	/** optionalParams Name \"iNumTotalResults\" Value INTEGER	Number of total results for paged search request (e.g. asnChatGetBinaryMessageEvents) */
	public optionalParams?: ENetUC_Common.AsnOptionalParameters;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * execute action from App
 * the following type's prefixed with AsnChatAppAction currently not part of the client\/server communication
 * it will be used within the Win32-Client to communicate with the ProCallApp for Web
 * the advantage using different types is, keep the action and its parameters together!
 * navigate to existing room, args &lt;ConversationId&gt;
 */
export class AsnChatAppActionNavigateArgument {
	public constructor(that: AsnChatAppActionNavigateArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatAppActionNavigateArgument {
		return new AsnChatAppActionNavigateArgument({
			u8sConversationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sConversationID"
		];
		return p;
	}

	public static type = "AsnChatAppActionNavigateArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatAppActionNavigateArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sConversationID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Conversation ID (of the room) */
	public u8sConversationID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * trigger Action\/Wizzard for new Multiparty-Chat, args list of UserId's
 */
export class AsnChatAppActionCreateRoomArgument {
	public constructor(that: AsnChatAppActionCreateRoomArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnChatAppActionCreateRoomArgument {
		return new AsnChatAppActionCreateRoomArgument({
			u8sUsers: new ENetUC_Common.UTF8StringList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sUsers"
		];
		return p;
	}

	public static type = "AsnChatAppActionCreateRoomArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnChatAppActionCreateRoomArgument",
			...params,
			value: [
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "u8sUsers" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Contact URIs of initial room member */
	public u8sUsers!: ENetUC_Common.UTF8StringList;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnChatReactionsResultList extends Array<AsnChatReactionsResult> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnChatReactionsResult.getASN1Schema()
		});
	}
}
