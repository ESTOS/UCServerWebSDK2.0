// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetROSEInterface_Converter.ts
 * "UC-Server-Access-Protocol-Main" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetROSEInterface from "./ENetROSEInterface";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
import * as ENetUC_Common_Appointments from "./ENetUC_Common_Appointments";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
import * as ENetUC_Common_AsnContact_Converter from "./ENetUC_Common_AsnContact_Converter";
import * as ENetUC_Common_Appointments_Converter from "./ENetUC_Common_Appointments_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetROSEInterface_Converter";
export const MODULE_LASTCHANGE = "2024-08-22T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240822;
export const MODULE_VERSION = "8.0.20240822";

// [PrintTSEncoderDecoderCode]
export class AsnNumberFormatRegExpression2_Converter {
	public static toJSON(s: ENetROSEInterface.AsnNumberFormatRegExpression2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnNumberFormatRegExpression2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpression2");

		const t = {} as ENetROSEInterface.AsnNumberFormatRegExpression2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNumberFormatRegExpression2";
		TSConverter.fillJSONParam(s, t, "u8sSearch", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sReplace", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMatchReplace", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpression2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnNumberFormatRegExpression2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpression2");

		let t: ENetROSEInterface.AsnNumberFormatRegExpression2 | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnNumberFormatRegExpression2>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnNumberFormatRegExpression2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sSearch", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sReplace", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMatchReplace", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpression2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnNumberFormatRegExpression2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNumberFormatRegExpression2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpression2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sSearch", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sReplace", "string", errors, newContext);
		TSConverter.validateParam(s, "bMatchReplace", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sSearch, name: "u8sSearch" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sReplace, name: "u8sReplace" }));
			t.push(new asn1ts.Boolean({ value: s.bMatchReplace, name: "bMatchReplace" }));
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpression2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnNumberFormatRegExpression2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpression2");

		let t: ENetROSEInterface.AsnNumberFormatRegExpression2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnNumberFormatRegExpression2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnNumberFormatRegExpression2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sSearch", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sReplace", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMatchReplace", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpression2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnKeepAliveArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnKeepAliveArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnKeepAliveArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnKeepAliveArgument");

		const t = {} as ENetROSEInterface.AsnKeepAliveArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnKeepAliveArgument";
		TSConverter.fillJSONParam(s, t, "dummy", "null", errors, newContext);

		if (errors.validateResult(newContext, "AsnKeepAliveArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnKeepAliveArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnKeepAliveArgument");

		let t: ENetROSEInterface.AsnKeepAliveArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnKeepAliveArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnKeepAliveArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnKeepAliveArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnKeepAliveArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnKeepAliveArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnKeepAliveArgument");

		// [Print_BER_EncoderSeqDefCode]
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Null({ name: "dummy" }));
		}

		if (errors.validateResult(newContext, "AsnKeepAliveArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnKeepAliveArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnKeepAliveArgument");

		let t: ENetROSEInterface.AsnKeepAliveArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnKeepAliveArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnKeepAliveArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "dummy", "Null", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnKeepAliveArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetLocationInformationArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetLocationInformationArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetLocationInformationArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationInformationArgument");

		const t = {} as ENetROSEInterface.AsnGetLocationInformationArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetLocationInformationArgument";
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnGetLocationInformationArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationInformationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationInformationArgument");

		let t: ENetROSEInterface.AsnGetLocationInformationArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetLocationInformationArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetLocationInformationArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnGetLocationInformationArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetLocationInformationArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetLocationInformationArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationInformationArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
		}

		if (errors.validateResult(newContext, "AsnGetLocationInformationArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationInformationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationInformationArgument");

		let t: ENetROSEInterface.AsnGetLocationInformationArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetLocationInformationArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetLocationInformationArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnGetLocationInformationArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSetLocationInformation2Result_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSetLocationInformation2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSetLocationInformation2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetLocationInformation2Result");

		const t = {} as ENetROSEInterface.AsnSetLocationInformation2Result & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSetLocationInformation2Result";

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetLocationInformation2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetLocationInformation2Result");

		let t: ENetROSEInterface.AsnSetLocationInformation2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSetLocationInformation2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSetLocationInformation2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSetLocationInformation2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSetLocationInformation2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetLocationInformation2Result");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Result"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetLocationInformation2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetLocationInformation2Result");

		let t: ENetROSEInterface.AsnSetLocationInformation2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSetLocationInformation2Result.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSetLocationInformation2Result["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Result"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetLocationIDsArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetLocationIDsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetLocationIDsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationIDsArgument");

		const t = {} as ENetROSEInterface.AsnGetLocationIDsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetLocationIDsArgument";
		if (s.locationIDs) {
			const _locationIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.locationIDs, errors, newContext, "locationIDs");
			if (_locationIDs)
				t.locationIDs = _locationIDs;
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationIDsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationIDsArgument");

		let t: ENetROSEInterface.AsnGetLocationIDsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetLocationIDsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetLocationIDsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _locationids = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.locationIDs, errors, newContext, "locationIDs", true);
			if (_locationids)
				t.locationIDs = _locationids;
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetLocationIDsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetLocationIDsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationIDsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _locationIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.locationIDs, errors, newContext, "locationIDs", 0);
		if (!errors.hasNewErrors()) {
			if (_locationIDs)
				t.push(_locationIDs);
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationIDsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationIDsArgument");

		let t: ENetROSEInterface.AsnGetLocationIDsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetLocationIDsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetLocationIDsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			t.locationIDs = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "locationIDs"), errors, newContext, "locationIDs", true);
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetLocationIDsResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetLocationIDsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetLocationIDsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationIDsResult");

		const t = {} as ENetROSEInterface.AsnGetLocationIDsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetLocationIDsResult";
		const _locationIDMD5ChecksumList = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.locationIDMD5ChecksumList, errors, newContext, "locationIDMD5ChecksumList");
		if (_locationIDMD5ChecksumList)
			t.locationIDMD5ChecksumList = _locationIDMD5ChecksumList;

		if (errors.validateResult(newContext, "AsnGetLocationIDsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationIDsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationIDsResult");

		let t: ENetROSEInterface.AsnGetLocationIDsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetLocationIDsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetLocationIDsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _locationidmd5checksumlist = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.locationIDMD5ChecksumList, errors, newContext, "locationIDMD5ChecksumList", false);
			if (_locationidmd5checksumlist)
				t.locationIDMD5ChecksumList = _locationidmd5checksumlist;
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetLocationIDsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetLocationIDsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationIDsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _locationIDMD5ChecksumList = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.locationIDMD5ChecksumList, errors, newContext, "locationIDMD5ChecksumList");
		if (!errors.hasNewErrors()) {
			if (_locationIDMD5ChecksumList)
				t.push(_locationIDMD5ChecksumList);
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationIDsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationIDsResult");

		let t: ENetROSEInterface.AsnGetLocationIDsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetLocationIDsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetLocationIDsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _locationidmd5checksumlist = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "locationIDMD5ChecksumList"), errors, newContext, "locationIDMD5ChecksumList");
			if (_locationidmd5checksumlist)
				t.locationIDMD5ChecksumList = _locationidmd5checksumlist;
		}

		if (errors.validateResult(newContext, "AsnGetLocationIDsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLocationInformationChangedArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnLocationInformationChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnLocationInformationChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLocationInformationChangedArgument");

		const t = {} as ENetROSEInterface.AsnLocationInformationChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLocationInformationChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnLocationInformationChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnLocationInformationChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLocationInformationChangedArgument");

		let t: ENetROSEInterface.AsnLocationInformationChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnLocationInformationChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnLocationInformationChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnLocationInformationChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnLocationInformationChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLocationInformationChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLocationInformationChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnLocationInformationChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnLocationInformationChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLocationInformationChangedArgument");

		let t: ENetROSEInterface.AsnLocationInformationChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnLocationInformationChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnLocationInformationChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnLocationInformationChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnUpdateMyContactConfigurationV2Argument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUpdateMyContactConfigurationV2Argument");

		const t = {} as ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnUpdateMyContactConfigurationV2Argument";
		const _contactChanged = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.toJSON(s.contactChanged, errors, newContext, "contactChanged");
		if (_contactChanged)
			t.contactChanged = _contactChanged;

		if (errors.validateResult(newContext, "AsnUpdateMyContactConfigurationV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUpdateMyContactConfigurationV2Argument");

		let t: ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _contactchanged = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.fromJSON(s.contactChanged, errors, newContext, "contactChanged", false);
			if (_contactchanged)
				t.contactChanged = _contactchanged;
		}

		if (errors.validateResult(newContext, "AsnUpdateMyContactConfigurationV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnUpdateMyContactConfigurationV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUpdateMyContactConfigurationV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		const _contactChanged = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.toBER(s.contactChanged, errors, newContext, "contactChanged");
		if (!errors.hasNewErrors()) {
			if (_contactChanged)
				t.push(_contactChanged);
		}

		if (errors.validateResult(newContext, "AsnUpdateMyContactConfigurationV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUpdateMyContactConfigurationV2Argument");

		let t: ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnUpdateMyContactConfigurationV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _contactchanged = ENetUC_Common_AsnContact_Converter.AsnContactV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "contactChanged"), errors, newContext, "contactChanged");
			if (_contactchanged)
				t.contactChanged = _contactchanged;
		}

		if (errors.validateResult(newContext, "AsnUpdateMyContactConfigurationV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSetUserAbsentStateArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSetUserAbsentStateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSetUserAbsentStateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetUserAbsentStateArgument");

		const t = {} as ENetROSEInterface.AsnSetUserAbsentStateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSetUserAbsentStateArgument";
		const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.toJSON(s.absentstate, errors, newContext, "absentstate");
		if (_absentstate)
			t.absentstate = _absentstate;

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetUserAbsentStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetUserAbsentStateArgument");

		let t: ENetROSEInterface.AsnSetUserAbsentStateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSetUserAbsentStateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSetUserAbsentStateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.fromJSON(s.absentstate, errors, newContext, "absentstate", false);
			if (_absentstate)
				t.absentstate = _absentstate;
		}

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSetUserAbsentStateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSetUserAbsentStateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetUserAbsentStateArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.toBER(s.absentstate, errors, newContext, "absentstate");
		if (!errors.hasNewErrors()) {
			if (_absentstate)
				t.push(_absentstate);
		}

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetUserAbsentStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetUserAbsentStateArgument");

		let t: ENetROSEInterface.AsnSetUserAbsentStateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSetUserAbsentStateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSetUserAbsentStateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "absentstate"), errors, newContext, "absentstate");
			if (_absentstate)
				t.absentstate = _absentstate;
		}

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSetUserAbsentStateResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSetUserAbsentStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSetUserAbsentStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetUserAbsentStateResult");

		const t = {} as ENetROSEInterface.AsnSetUserAbsentStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSetUserAbsentStateResult";
		TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetUserAbsentStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetUserAbsentStateResult");

		let t: ENetROSEInterface.AsnSetUserAbsentStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSetUserAbsentStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSetUserAbsentStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSetUserAbsentStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSetUserAbsentStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetUserAbsentStateResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bSuccess", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bSuccess, name: "bSuccess" }));
		}

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetUserAbsentStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetUserAbsentStateResult");

		let t: ENetROSEInterface.AsnSetUserAbsentStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSetUserAbsentStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSetUserAbsentStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bSuccess", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnSetUserAbsentStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetUserAbsentStateResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetUserAbsentStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetUserAbsentStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserAbsentStateResult");

		const t = {} as ENetROSEInterface.AsnGetUserAbsentStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetUserAbsentStateResult";
		const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.toJSON(s.absentstate, errors, newContext, "absentstate");
		if (_absentstate)
			t.absentstate = _absentstate;

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetUserAbsentStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserAbsentStateResult");

		let t: ENetROSEInterface.AsnGetUserAbsentStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetUserAbsentStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetUserAbsentStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.fromJSON(s.absentstate, errors, newContext, "absentstate", false);
			if (_absentstate)
				t.absentstate = _absentstate;
		}

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetUserAbsentStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetUserAbsentStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserAbsentStateResult");

		// [Print_BER_EncoderSeqDefCode]
		const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.toBER(s.absentstate, errors, newContext, "absentstate");
		if (!errors.hasNewErrors()) {
			if (_absentstate)
				t.push(_absentstate);
		}

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetUserAbsentStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserAbsentStateResult");

		let t: ENetROSEInterface.AsnGetUserAbsentStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetUserAbsentStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetUserAbsentStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "absentstate"), errors, newContext, "absentstate");
			if (_absentstate)
				t.absentstate = _absentstate;
		}

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnResetUserAbsentStateArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnResetUserAbsentStateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnResetUserAbsentStateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnResetUserAbsentStateArgument");

		const t = {} as ENetROSEInterface.AsnResetUserAbsentStateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnResetUserAbsentStateArgument";
		TSConverter.fillJSONParam(s, t, "u8sContactId", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnResetUserAbsentStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnResetUserAbsentStateArgument");

		let t: ENetROSEInterface.AsnResetUserAbsentStateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnResetUserAbsentStateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnResetUserAbsentStateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactId", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnResetUserAbsentStateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnResetUserAbsentStateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnResetUserAbsentStateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactId", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactId, name: "u8sContactId" }));
		}

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnResetUserAbsentStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnResetUserAbsentStateArgument");

		let t: ENetROSEInterface.AsnResetUserAbsentStateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnResetUserAbsentStateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnResetUserAbsentStateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactId", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnResetUserAbsentStateResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnResetUserAbsentStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnResetUserAbsentStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnResetUserAbsentStateResult");

		const t = {} as ENetROSEInterface.AsnResetUserAbsentStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnResetUserAbsentStateResult";

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnResetUserAbsentStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnResetUserAbsentStateResult");

		let t: ENetROSEInterface.AsnResetUserAbsentStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnResetUserAbsentStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnResetUserAbsentStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnResetUserAbsentStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnResetUserAbsentStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnResetUserAbsentStateResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnResetUserAbsentStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnResetUserAbsentStateResult");

		let t: ENetROSEInterface.AsnResetUserAbsentStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnResetUserAbsentStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnResetUserAbsentStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnResetUserAbsentStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnUpdateMyAbsentStateV2Argument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUpdateMyAbsentStateV2Argument");

		const t = {} as ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnUpdateMyAbsentStateV2Argument";
		const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.toJSON(s.absentstate, errors, newContext, "absentstate");
		if (_absentstate)
			t.absentstate = _absentstate;

		if (errors.validateResult(newContext, "AsnUpdateMyAbsentStateV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUpdateMyAbsentStateV2Argument");

		let t: ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.fromJSON(s.absentstate, errors, newContext, "absentstate", false);
			if (_absentstate)
				t.absentstate = _absentstate;
		}

		if (errors.validateResult(newContext, "AsnUpdateMyAbsentStateV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnUpdateMyAbsentStateV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUpdateMyAbsentStateV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.toBER(s.absentstate, errors, newContext, "absentstate");
		if (!errors.hasNewErrors()) {
			if (_absentstate)
				t.push(_absentstate);
		}

		if (errors.validateResult(newContext, "AsnUpdateMyAbsentStateV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUpdateMyAbsentStateV2Argument");

		let t: ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnUpdateMyAbsentStateV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _absentstate = ENetUC_Common_AsnContact_Converter.AsnAbsentStateV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "absentstate"), errors, newContext, "absentstate");
			if (_absentstate)
				t.absentstate = _absentstate;
		}

		if (errors.validateResult(newContext, "AsnUpdateMyAbsentStateV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCustomNoteSetArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnCustomNoteSetArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnCustomNoteSetArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCustomNoteSetArgument");

		const t = {} as ENetROSEInterface.AsnCustomNoteSetArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCustomNoteSetArgument";
		const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.toJSON(s.customnote, errors, newContext, "customnote");
		if (_customnote)
			t.customnote = _customnote;

		if (errors.validateResult(newContext, "AsnCustomNoteSetArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnCustomNoteSetArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCustomNoteSetArgument");

		let t: ENetROSEInterface.AsnCustomNoteSetArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnCustomNoteSetArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnCustomNoteSetArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.fromJSON(s.customnote, errors, newContext, "customnote", false);
			if (_customnote)
				t.customnote = _customnote;
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnCustomNoteSetArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCustomNoteSetArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCustomNoteSetArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.toBER(s.customnote, errors, newContext, "customnote");
		if (!errors.hasNewErrors()) {
			if (_customnote)
				t.push(_customnote);
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnCustomNoteSetArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCustomNoteSetArgument");

		let t: ENetROSEInterface.AsnCustomNoteSetArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnCustomNoteSetArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnCustomNoteSetArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "customnote"), errors, newContext, "customnote");
			if (_customnote)
				t.customnote = _customnote;
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCustomNoteSetResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnCustomNoteSetResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnCustomNoteSetResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCustomNoteSetResult");

		const t = {} as ENetROSEInterface.AsnCustomNoteSetResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCustomNoteSetResult";
		if (s.optionalParams) {
			const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toJSON(s.optionalParams, errors, newContext, "optionalParams");
			if (_optionalParams)
				t.optionalParams = _optionalParams;
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnCustomNoteSetResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCustomNoteSetResult");

		let t: ENetROSEInterface.AsnCustomNoteSetResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnCustomNoteSetResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnCustomNoteSetResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _optionalparams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromJSON(s.optionalParams, errors, newContext, "optionalParams", true);
			if (_optionalparams)
				t.optionalParams = _optionalparams;
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnCustomNoteSetResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCustomNoteSetResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCustomNoteSetResult");

		// [Print_BER_EncoderSeqDefCode]
		const _optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.toBER(s.optionalParams, errors, newContext, "optionalParams", true);
		if (!errors.hasNewErrors()) {
			if (_optionalParams)
				t.push(_optionalParams);
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnCustomNoteSetResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCustomNoteSetResult");

		let t: ENetROSEInterface.AsnCustomNoteSetResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnCustomNoteSetResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnCustomNoteSetResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			t.optionalParams = ENetUC_Common_Converter.AsnOptionalParameters_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "optionalParams"), errors, newContext, "optionalParams", true);
		}

		if (errors.validateResult(newContext, "AsnCustomNoteSetResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnUpdateMyCustomNoteArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnUpdateMyCustomNoteArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnUpdateMyCustomNoteArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUpdateMyCustomNoteArgument");

		const t = {} as ENetROSEInterface.AsnUpdateMyCustomNoteArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnUpdateMyCustomNoteArgument";
		const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.toJSON(s.customnote, errors, newContext, "customnote");
		if (_customnote)
			t.customnote = _customnote;

		if (errors.validateResult(newContext, "AsnUpdateMyCustomNoteArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnUpdateMyCustomNoteArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUpdateMyCustomNoteArgument");

		let t: ENetROSEInterface.AsnUpdateMyCustomNoteArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnUpdateMyCustomNoteArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnUpdateMyCustomNoteArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.fromJSON(s.customnote, errors, newContext, "customnote", false);
			if (_customnote)
				t.customnote = _customnote;
		}

		if (errors.validateResult(newContext, "AsnUpdateMyCustomNoteArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnUpdateMyCustomNoteArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnUpdateMyCustomNoteArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUpdateMyCustomNoteArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.toBER(s.customnote, errors, newContext, "customnote");
		if (!errors.hasNewErrors()) {
			if (_customnote)
				t.push(_customnote);
		}

		if (errors.validateResult(newContext, "AsnUpdateMyCustomNoteArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnUpdateMyCustomNoteArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUpdateMyCustomNoteArgument");

		let t: ENetROSEInterface.AsnUpdateMyCustomNoteArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnUpdateMyCustomNoteArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnUpdateMyCustomNoteArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _customnote = ENetUC_Common_AsnContact_Converter.AsnCustomNote_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "customnote"), errors, newContext, "customnote");
			if (_customnote)
				t.customnote = _customnote;
		}

		if (errors.validateResult(newContext, "AsnUpdateMyCustomNoteArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSetMetaSettingsResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSetMetaSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSetMetaSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetMetaSettingsResult");

		const t = {} as ENetROSEInterface.AsnSetMetaSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSetMetaSettingsResult";

		if (errors.validateResult(newContext, "AsnSetMetaSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetMetaSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetMetaSettingsResult");

		let t: ENetROSEInterface.AsnSetMetaSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSetMetaSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSetMetaSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSetMetaSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSetMetaSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSetMetaSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetMetaSettingsResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnSetMetaSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetMetaSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetMetaSettingsResult");

		let t: ENetROSEInterface.AsnSetMetaSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSetMetaSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSetMetaSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSetMetaSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSubscribeServicesArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSubscribeServicesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSubscribeServicesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSubscribeServicesArgument");

		const t = {} as ENetROSEInterface.AsnSubscribeServicesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSubscribeServicesArgument";

		if (errors.validateResult(newContext, "AsnSubscribeServicesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSubscribeServicesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSubscribeServicesArgument");

		let t: ENetROSEInterface.AsnSubscribeServicesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSubscribeServicesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSubscribeServicesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSubscribeServicesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSubscribeServicesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSubscribeServicesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSubscribeServicesArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnSubscribeServicesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSubscribeServicesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSubscribeServicesArgument");

		let t: ENetROSEInterface.AsnSubscribeServicesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSubscribeServicesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSubscribeServicesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSubscribeServicesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSubscribeServicesResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSubscribeServicesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSubscribeServicesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSubscribeServicesResult");

		const t = {} as ENetROSEInterface.AsnSubscribeServicesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSubscribeServicesResult";

		if (errors.validateResult(newContext, "AsnSubscribeServicesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSubscribeServicesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSubscribeServicesResult");

		let t: ENetROSEInterface.AsnSubscribeServicesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSubscribeServicesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSubscribeServicesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSubscribeServicesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSubscribeServicesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSubscribeServicesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSubscribeServicesResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnSubscribeServicesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSubscribeServicesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSubscribeServicesResult");

		let t: ENetROSEInterface.AsnSubscribeServicesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSubscribeServicesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSubscribeServicesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnSubscribeServicesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNumberFormatRegExpressList2_Converter {
	public static toJSON(s: ENetROSEInterface.AsnNumberFormatRegExpressList2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnNumberFormatRegExpressList2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressList2");

		const t = [] as ENetROSEInterface.AsnNumberFormatRegExpressList2;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnNumberFormatRegExpression2_Converter.toJSON(se, errors, newContext, "AsnNumberFormatRegExpression2");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressList2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnNumberFormatRegExpressList2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressList2");

		let t: ENetROSEInterface.AsnNumberFormatRegExpressList2 | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnNumberFormatRegExpressList2>(data, errors, newContext, optional);
		if (s) {
			t = new ENetROSEInterface.AsnNumberFormatRegExpressList2();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnNumberFormatRegExpression2_Converter.fromJSON(se, errors, newContext, "AsnNumberFormatRegExpression2", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressList2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnNumberFormatRegExpressList2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNumberFormatRegExpressList2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressList2");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnNumberFormatRegExpression2_Converter.toBER(s[id], errors, newContext, "AsnNumberFormatRegExpression2");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressList2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnNumberFormatRegExpressList2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressList2");

		let t: ENetROSEInterface.AsnNumberFormatRegExpressList2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnNumberFormatRegExpressList2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetROSEInterface.AsnNumberFormatRegExpressList2();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnNumberFormatRegExpression2_Converter.fromBER(se, errors, newContext, "AsnNumberFormatRegExpression2", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressList2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNumberFormatRegExpressions2_Converter {
	public static toJSON(s: ENetROSEInterface.AsnNumberFormatRegExpressions2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnNumberFormatRegExpressions2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressions2");

		const t = {} as ENetROSEInterface.AsnNumberFormatRegExpressions2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNumberFormatRegExpressions2";
		TSConverter.fillJSONParam(s, t, "bIsReadOnlyFromFile", "boolean", errors, newContext);
		const _formatRules = AsnNumberFormatRegExpressList2_Converter.toJSON(s.formatRules, errors, newContext, "formatRules");
		if (_formatRules)
			t.formatRules = _formatRules;

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressions2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnNumberFormatRegExpressions2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressions2");

		let t: ENetROSEInterface.AsnNumberFormatRegExpressions2 | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnNumberFormatRegExpressions2>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnNumberFormatRegExpressions2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bIsReadOnlyFromFile", "boolean", errors, newContext, false);
			const _formatrules = AsnNumberFormatRegExpressList2_Converter.fromJSON(s.formatRules, errors, newContext, "formatRules", false);
			if (_formatrules)
				t.formatRules = _formatrules;
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressions2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnNumberFormatRegExpressions2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNumberFormatRegExpressions2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressions2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bIsReadOnlyFromFile", "boolean", errors, newContext);
		const _formatRules = AsnNumberFormatRegExpressList2_Converter.toBER(s.formatRules, errors, newContext, "formatRules");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bIsReadOnlyFromFile, name: "bIsReadOnlyFromFile" }));
			if (_formatRules)
				t.push(_formatRules);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressions2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnNumberFormatRegExpressions2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressions2");

		let t: ENetROSEInterface.AsnNumberFormatRegExpressions2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnNumberFormatRegExpressions2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnNumberFormatRegExpressions2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bIsReadOnlyFromFile", "Boolean", errors, newContext);
			const _formatrules = AsnNumberFormatRegExpressList2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "formatRules"), errors, newContext, "formatRules");
			if (_formatrules)
				t.formatRules = _formatrules;
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressions2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLocationInformation2_Converter {
	public static toJSON(s: ENetROSEInterface.AsnLocationInformation2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnLocationInformation2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLocationInformation2");

		const t = {} as ENetROSEInterface.AsnLocationInformation2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLocationInformation2";
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocationCheckSum", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseVanity", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bShowExtendedSettings", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseTkSystem", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseAdvancedLCR", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bFixedNumberLenExtensionDTMFDialing", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMultiLocationSupport", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoCreateOtherLocationRules", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAllowNumberSearchOtherLocations", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bShortenOtherLocationSCNumbersForDialing", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCountryID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCountryCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNationalPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sInternationalPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalDialingRule", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNationalDialingRule", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sInternationalDialingRule", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCityCodeNoPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sVanityNumbers", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKLocalAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKLongDistanceAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKInternationalAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKPrivateAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKForwardingAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKAnschlussNr", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTKMinLenInternalNumbers", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTKMaxLenInternalNumbers", "number", errors, newContext);
		const _numberFormatInternal = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatInternal, errors, newContext, "numberFormatInternal");
		if (_numberFormatInternal)
			t.numberFormatInternal = _numberFormatInternal;
		const _numberFormatExternal = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatExternal, errors, newContext, "numberFormatExternal");
		if (_numberFormatExternal)
			t.numberFormatExternal = _numberFormatExternal;
		const _numberFormatAutomaticOtherLocationsDDItoSC = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatAutomaticOtherLocationsDDItoSC, errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC");
		if (_numberFormatAutomaticOtherLocationsDDItoSC)
			t.numberFormatAutomaticOtherLocationsDDItoSC = _numberFormatAutomaticOtherLocationsDDItoSC;
		const _numberFormatAutomaticOtherLocationsSCtoDDI = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatAutomaticOtherLocationsSCtoDDI, errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI");
		if (_numberFormatAutomaticOtherLocationsSCtoDDI)
			t.numberFormatAutomaticOtherLocationsSCtoDDI = _numberFormatAutomaticOtherLocationsSCtoDDI;
		const _numberFormatRegExpressListIn = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatRegExpressListIn, errors, newContext, "numberFormatRegExpressListIn");
		if (_numberFormatRegExpressListIn)
			t.numberFormatRegExpressListIn = _numberFormatRegExpressListIn;
		const _numberFormatRegExpressListOut = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatRegExpressListOut, errors, newContext, "numberFormatRegExpressListOut");
		if (_numberFormatRegExpressListOut)
			t.numberFormatRegExpressListOut = _numberFormatRegExpressListOut;
		const _numberFormatRegExpressListDial = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatRegExpressListDial, errors, newContext, "numberFormatRegExpressListDial");
		if (_numberFormatRegExpressListDial)
			t.numberFormatRegExpressListDial = _numberFormatRegExpressListDial;
		const _numberFormatRegExpressListFinalDial = AsnNumberFormatRegExpressions2_Converter.toJSON(s.numberFormatRegExpressListFinalDial, errors, newContext, "numberFormatRegExpressListFinalDial");
		if (_numberFormatRegExpressListFinalDial)
			t.numberFormatRegExpressListFinalDial = _numberFormatRegExpressListFinalDial;
		const _projectPINRules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.toJSON(s.projectPINRules, errors, newContext, "projectPINRules");
		if (_projectPINRules)
			t.projectPINRules = _projectPINRules;
		TSConverter.fillJSONParam(s, t, "u8sDDIRangeBegin", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDDIRangeEnd", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDialingNumberFormat", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNoLocalDialing", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnLocationInformation2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnLocationInformation2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLocationInformation2");

		let t: ENetROSEInterface.AsnLocationInformation2 | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnLocationInformation2>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnLocationInformation2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocationCheckSum", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseVanity", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bShowExtendedSettings", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseTkSystem", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseAdvancedLCR", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bFixedNumberLenExtensionDTMFDialing", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMultiLocationSupport", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoCreateOtherLocationRules", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAllowNumberSearchOtherLocations", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bShortenOtherLocationSCNumbersForDialing", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCountryID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCountryCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNationalPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sInternationalPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalDialingRule", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNationalDialingRule", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sInternationalDialingRule", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCityCodeNoPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sVanityNumbers", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKLocalAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKLongDistanceAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKInternationalAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKPrivateAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKForwardingAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKAnschlussNr", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTKMinLenInternalNumbers", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTKMaxLenInternalNumbers", "number", errors, newContext, false);
			const _numberformatinternal = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatInternal, errors, newContext, "numberFormatInternal", false);
			if (_numberformatinternal)
				t.numberFormatInternal = _numberformatinternal;
			const _numberformatexternal = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatExternal, errors, newContext, "numberFormatExternal", false);
			if (_numberformatexternal)
				t.numberFormatExternal = _numberformatexternal;
			const _numberformatautomaticotherlocationsdditosc = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatAutomaticOtherLocationsDDItoSC, errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC", false);
			if (_numberformatautomaticotherlocationsdditosc)
				t.numberFormatAutomaticOtherLocationsDDItoSC = _numberformatautomaticotherlocationsdditosc;
			const _numberformatautomaticotherlocationssctoddi = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatAutomaticOtherLocationsSCtoDDI, errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI", false);
			if (_numberformatautomaticotherlocationssctoddi)
				t.numberFormatAutomaticOtherLocationsSCtoDDI = _numberformatautomaticotherlocationssctoddi;
			const _numberformatregexpresslistin = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatRegExpressListIn, errors, newContext, "numberFormatRegExpressListIn", false);
			if (_numberformatregexpresslistin)
				t.numberFormatRegExpressListIn = _numberformatregexpresslistin;
			const _numberformatregexpresslistout = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatRegExpressListOut, errors, newContext, "numberFormatRegExpressListOut", false);
			if (_numberformatregexpresslistout)
				t.numberFormatRegExpressListOut = _numberformatregexpresslistout;
			const _numberformatregexpresslistdial = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatRegExpressListDial, errors, newContext, "numberFormatRegExpressListDial", false);
			if (_numberformatregexpresslistdial)
				t.numberFormatRegExpressListDial = _numberformatregexpresslistdial;
			const _numberformatregexpresslistfinaldial = AsnNumberFormatRegExpressions2_Converter.fromJSON(s.numberFormatRegExpressListFinalDial, errors, newContext, "numberFormatRegExpressListFinalDial", false);
			if (_numberformatregexpresslistfinaldial)
				t.numberFormatRegExpressListFinalDial = _numberformatregexpresslistfinaldial;
			const _projectpinrules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.fromJSON(s.projectPINRules, errors, newContext, "projectPINRules", false);
			if (_projectpinrules)
				t.projectPINRules = _projectpinrules;
			TSConverter.fillJSONParam(s, t, "u8sDDIRangeBegin", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDDIRangeEnd", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDialingNumberFormat", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNoLocalDialing", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnLocationInformation2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnLocationInformation2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLocationInformation2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLocationInformation2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocationCheckSum", "string", errors, newContext);
		TSConverter.validateParam(s, "bUseVanity", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bShowExtendedSettings", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bUseTkSystem", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bUseAdvancedLCR", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bFixedNumberLenExtensionDTMFDialing", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bMultiLocationSupport", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAutoCreateOtherLocationRules", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAllowNumberSearchOtherLocations", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bShortenOtherLocationSCNumbersForDialing", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iCountryID", "number", errors, newContext);
		TSConverter.validateParam(s, "iLanguage", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCountryCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNationalPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sInternationalPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalDialingRule", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNationalDialingRule", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sInternationalDialingRule", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCityCodeNoPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sVanityNumbers", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKLocalAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKLongDistanceAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKInternationalAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKPrivateAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKForwardingAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKAnschlussNr", "string", errors, newContext);
		TSConverter.validateParam(s, "iTKMinLenInternalNumbers", "number", errors, newContext);
		TSConverter.validateParam(s, "iTKMaxLenInternalNumbers", "number", errors, newContext);
		const _numberFormatInternal = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatInternal, errors, newContext, "numberFormatInternal");
		const _numberFormatExternal = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatExternal, errors, newContext, "numberFormatExternal");
		const _numberFormatAutomaticOtherLocationsDDItoSC = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatAutomaticOtherLocationsDDItoSC, errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC");
		const _numberFormatAutomaticOtherLocationsSCtoDDI = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatAutomaticOtherLocationsSCtoDDI, errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI");
		const _numberFormatRegExpressListIn = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatRegExpressListIn, errors, newContext, "numberFormatRegExpressListIn");
		const _numberFormatRegExpressListOut = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatRegExpressListOut, errors, newContext, "numberFormatRegExpressListOut");
		const _numberFormatRegExpressListDial = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatRegExpressListDial, errors, newContext, "numberFormatRegExpressListDial");
		const _numberFormatRegExpressListFinalDial = AsnNumberFormatRegExpressions2_Converter.toBER(s.numberFormatRegExpressListFinalDial, errors, newContext, "numberFormatRegExpressListFinalDial");
		const _projectPINRules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.toBER(s.projectPINRules, errors, newContext, "projectPINRules");
		TSConverter.validateParam(s, "u8sDDIRangeBegin", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDDIRangeEnd", "string", errors, newContext);
		TSConverter.validateParam(s, "iDialingNumberFormat", "number", errors, newContext);
		TSConverter.validateParam(s, "bNoLocalDialing", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationCheckSum, name: "u8sLocationCheckSum" }));
			t.push(new asn1ts.Boolean({ value: s.bUseVanity, name: "bUseVanity" }));
			t.push(new asn1ts.Boolean({ value: s.bShowExtendedSettings, name: "bShowExtendedSettings" }));
			t.push(new asn1ts.Boolean({ value: s.bUseTkSystem, name: "bUseTkSystem" }));
			t.push(new asn1ts.Boolean({ value: s.bUseAdvancedLCR, name: "bUseAdvancedLCR" }));
			t.push(new asn1ts.Boolean({ value: s.bFixedNumberLenExtensionDTMFDialing, name: "bFixedNumberLenExtensionDTMFDialing" }));
			t.push(new asn1ts.Boolean({ value: s.bMultiLocationSupport, name: "bMultiLocationSupport" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoCreateOtherLocationRules, name: "bAutoCreateOtherLocationRules" }));
			t.push(new asn1ts.Boolean({ value: s.bAllowNumberSearchOtherLocations, name: "bAllowNumberSearchOtherLocations" }));
			t.push(new asn1ts.Boolean({ value: s.bShortenOtherLocationSCNumbersForDialing, name: "bShortenOtherLocationSCNumbersForDialing" }));
			t.push(new asn1ts.Integer({ value: s.iCountryID, name: "iCountryID" }));
			t.push(new asn1ts.Integer({ value: s.iLanguage, name: "iLanguage" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCountryCode, name: "u8sCountryCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalPrefix, name: "u8sLocalPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNationalPrefix, name: "u8sNationalPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sInternationalPrefix, name: "u8sInternationalPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalDialingRule, name: "u8sLocalDialingRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNationalDialingRule, name: "u8sNationalDialingRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sInternationalDialingRule, name: "u8sInternationalDialingRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCityCodeNoPrefix, name: "u8sCityCodeNoPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sVanityNumbers, name: "u8sVanityNumbers" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKLocalAccessCode, name: "u8sTKLocalAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKLongDistanceAccessCode, name: "u8sTKLongDistanceAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKInternationalAccessCode, name: "u8sTKInternationalAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKPrivateAccessCode, name: "u8sTKPrivateAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKForwardingAccessCode, name: "u8sTKForwardingAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKAnschlussNr, name: "u8sTKAnschlussNr" }));
			t.push(new asn1ts.Integer({ value: s.iTKMinLenInternalNumbers, name: "iTKMinLenInternalNumbers" }));
			t.push(new asn1ts.Integer({ value: s.iTKMaxLenInternalNumbers, name: "iTKMaxLenInternalNumbers" }));
			if (_numberFormatInternal)
				t.push(_numberFormatInternal);
			if (_numberFormatExternal)
				t.push(_numberFormatExternal);
			if (_numberFormatAutomaticOtherLocationsDDItoSC)
				t.push(_numberFormatAutomaticOtherLocationsDDItoSC);
			if (_numberFormatAutomaticOtherLocationsSCtoDDI)
				t.push(_numberFormatAutomaticOtherLocationsSCtoDDI);
			if (_numberFormatRegExpressListIn)
				t.push(_numberFormatRegExpressListIn);
			if (_numberFormatRegExpressListOut)
				t.push(_numberFormatRegExpressListOut);
			if (_numberFormatRegExpressListDial)
				t.push(_numberFormatRegExpressListDial);
			if (_numberFormatRegExpressListFinalDial)
				t.push(_numberFormatRegExpressListFinalDial);
			if (_projectPINRules)
				t.push(_projectPINRules);
			t.push(new asn1ts.Utf8String({ value: s.u8sDDIRangeBegin, name: "u8sDDIRangeBegin" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDDIRangeEnd, name: "u8sDDIRangeEnd" }));
			t.push(new asn1ts.Integer({ value: s.iDialingNumberFormat, name: "iDialingNumberFormat" }));
			t.push(new asn1ts.Boolean({ value: s.bNoLocalDialing, name: "bNoLocalDialing" }));
		}

		if (errors.validateResult(newContext, "AsnLocationInformation2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnLocationInformation2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLocationInformation2");

		let t: ENetROSEInterface.AsnLocationInformation2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnLocationInformation2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnLocationInformation2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocationCheckSum", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseVanity", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bShowExtendedSettings", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseTkSystem", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseAdvancedLCR", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bFixedNumberLenExtensionDTMFDialing", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMultiLocationSupport", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoCreateOtherLocationRules", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAllowNumberSearchOtherLocations", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bShortenOtherLocationSCNumbersForDialing", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCountryID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLanguage", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCountryCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNationalPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sInternationalPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalDialingRule", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNationalDialingRule", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sInternationalDialingRule", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCityCodeNoPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sVanityNumbers", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKLocalAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKLongDistanceAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKInternationalAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKPrivateAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKForwardingAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKAnschlussNr", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTKMinLenInternalNumbers", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTKMaxLenInternalNumbers", "Integer", errors, newContext);
			const _numberformatinternal = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatInternal"), errors, newContext, "numberFormatInternal");
			if (_numberformatinternal)
				t.numberFormatInternal = _numberformatinternal;
			const _numberformatexternal = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatExternal"), errors, newContext, "numberFormatExternal");
			if (_numberformatexternal)
				t.numberFormatExternal = _numberformatexternal;
			const _numberformatautomaticotherlocationsdditosc = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatAutomaticOtherLocationsDDItoSC"), errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC");
			if (_numberformatautomaticotherlocationsdditosc)
				t.numberFormatAutomaticOtherLocationsDDItoSC = _numberformatautomaticotherlocationsdditosc;
			const _numberformatautomaticotherlocationssctoddi = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatAutomaticOtherLocationsSCtoDDI"), errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI");
			if (_numberformatautomaticotherlocationssctoddi)
				t.numberFormatAutomaticOtherLocationsSCtoDDI = _numberformatautomaticotherlocationssctoddi;
			const _numberformatregexpresslistin = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListIn"), errors, newContext, "numberFormatRegExpressListIn");
			if (_numberformatregexpresslistin)
				t.numberFormatRegExpressListIn = _numberformatregexpresslistin;
			const _numberformatregexpresslistout = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListOut"), errors, newContext, "numberFormatRegExpressListOut");
			if (_numberformatregexpresslistout)
				t.numberFormatRegExpressListOut = _numberformatregexpresslistout;
			const _numberformatregexpresslistdial = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListDial"), errors, newContext, "numberFormatRegExpressListDial");
			if (_numberformatregexpresslistdial)
				t.numberFormatRegExpressListDial = _numberformatregexpresslistdial;
			const _numberformatregexpresslistfinaldial = AsnNumberFormatRegExpressions2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListFinalDial"), errors, newContext, "numberFormatRegExpressListFinalDial");
			if (_numberformatregexpresslistfinaldial)
				t.numberFormatRegExpressListFinalDial = _numberformatregexpresslistfinaldial;
			const _projectpinrules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "projectPINRules"), errors, newContext, "projectPINRules");
			if (_projectpinrules)
				t.projectPINRules = _projectpinrules;
			TSConverter.fillASN1Param(s, t, "u8sDDIRangeBegin", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDDIRangeEnd", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDialingNumberFormat", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNoLocalDialing", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnLocationInformation2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetLocationInformation2Result_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetLocationInformation2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetLocationInformation2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationInformation2Result");

		const t = {} as ENetROSEInterface.AsnGetLocationInformation2Result & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetLocationInformation2Result";
		const _asnLocationData = AsnLocationInformation2_Converter.toJSON(s.asnLocationData, errors, newContext, "asnLocationData");
		if (_asnLocationData)
			t.asnLocationData = _asnLocationData;

		if (errors.validateResult(newContext, "AsnGetLocationInformation2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationInformation2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationInformation2Result");

		let t: ENetROSEInterface.AsnGetLocationInformation2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetLocationInformation2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetLocationInformation2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformation2_Converter.fromJSON(s.asnLocationData, errors, newContext, "asnLocationData", false);
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnGetLocationInformation2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetLocationInformation2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetLocationInformation2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetLocationInformation2Result");

		// [Print_BER_EncoderSeqDefCode]
		const _asnLocationData = AsnLocationInformation2_Converter.toBER(s.asnLocationData, errors, newContext, "asnLocationData");
		if (!errors.hasNewErrors()) {
			if (_asnLocationData)
				t.push(_asnLocationData);
		}

		if (errors.validateResult(newContext, "AsnGetLocationInformation2Result"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetLocationInformation2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetLocationInformation2Result");

		let t: ENetROSEInterface.AsnGetLocationInformation2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetLocationInformation2Result.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetLocationInformation2Result["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformation2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnLocationData"), errors, newContext, "asnLocationData");
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnGetLocationInformation2Result"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSetLocationInformation2Argument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSetLocationInformation2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSetLocationInformation2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetLocationInformation2Argument");

		const t = {} as ENetROSEInterface.AsnSetLocationInformation2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSetLocationInformation2Argument";
		const _asnLocationData = AsnLocationInformation2_Converter.toJSON(s.asnLocationData, errors, newContext, "asnLocationData");
		if (_asnLocationData)
			t.asnLocationData = _asnLocationData;

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetLocationInformation2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetLocationInformation2Argument");

		let t: ENetROSEInterface.AsnSetLocationInformation2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSetLocationInformation2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSetLocationInformation2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformation2_Converter.fromJSON(s.asnLocationData, errors, newContext, "asnLocationData", false);
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSetLocationInformation2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSetLocationInformation2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetLocationInformation2Argument");

		// [Print_BER_EncoderSeqDefCode]
		const _asnLocationData = AsnLocationInformation2_Converter.toBER(s.asnLocationData, errors, newContext, "asnLocationData");
		if (!errors.hasNewErrors()) {
			if (_asnLocationData)
				t.push(_asnLocationData);
		}

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetLocationInformation2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetLocationInformation2Argument");

		let t: ENetROSEInterface.AsnSetLocationInformation2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSetLocationInformation2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSetLocationInformation2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformation2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnLocationData"), errors, newContext, "asnLocationData");
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnSetLocationInformation2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetUserAbsentStateArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetUserAbsentStateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetUserAbsentStateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserAbsentStateArgument");

		const t = {} as ENetROSEInterface.AsnGetUserAbsentStateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetUserAbsentStateArgument";
		TSConverter.fillJSONParam(s, t, "contactId", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetUserAbsentStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserAbsentStateArgument");

		let t: ENetROSEInterface.AsnGetUserAbsentStateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetUserAbsentStateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetUserAbsentStateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "contactId", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetUserAbsentStateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetUserAbsentStateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetUserAbsentStateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "contactId", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.contactId, name: "contactId" }));
		}

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetUserAbsentStateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetUserAbsentStateArgument");

		let t: ENetROSEInterface.AsnGetUserAbsentStateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetUserAbsentStateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetUserAbsentStateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "contactId", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnGetUserAbsentStateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetMetaSettingsArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetMetaSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetMetaSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetMetaSettingsArgument");

		const t = {} as ENetROSEInterface.AsnGetMetaSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetMetaSettingsArgument";
		TSConverter.fillJSONParam(s, t, "eSendPlainPassword", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnGetMetaSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetMetaSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetMetaSettingsArgument");

		let t: ENetROSEInterface.AsnGetMetaSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetMetaSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetMetaSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eSendPlainPassword", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnGetMetaSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetMetaSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetMetaSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetMetaSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eSendPlainPassword", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Enumerated({ value: s.eSendPlainPassword, name: "eSendPlainPassword" }));
		}

		if (errors.validateResult(newContext, "AsnGetMetaSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetMetaSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetMetaSettingsArgument");

		let t: ENetROSEInterface.AsnGetMetaSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetMetaSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetMetaSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eSendPlainPassword", "Enumerated", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnGetMetaSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMetaDirectorySettings_Converter {
	public static toJSON(s: ENetROSEInterface.AsnMetaDirectorySettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnMetaDirectorySettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMetaDirectorySettings");

		const t = {} as ENetROSEInterface.AsnMetaDirectorySettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMetaDirectorySettings";
		TSConverter.fillJSONParam(s, t, "iMetaEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMetaPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMetaServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBaseDN", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMetaForceSSL", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMetaUseAccount", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMetaUser", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "ePasswordEncryption", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMetaPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMetaUseInServer", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMetaUseInClient", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMetaDirectorySettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnMetaDirectorySettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMetaDirectorySettings");

		let t: ENetROSEInterface.AsnMetaDirectorySettings | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnMetaDirectorySettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnMetaDirectorySettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iMetaEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMetaPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMetaServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBaseDN", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMetaForceSSL", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMetaUseAccount", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMetaUser", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "ePasswordEncryption", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMetaPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMetaUseInServer", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMetaUseInClient", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMetaDirectorySettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnMetaDirectorySettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMetaDirectorySettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMetaDirectorySettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iMetaEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iMetaPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sMetaServer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sBaseDN", "string", errors, newContext);
		TSConverter.validateParam(s, "iMetaForceSSL", "number", errors, newContext);
		TSConverter.validateParam(s, "iMetaUseAccount", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sMetaUser", "string", errors, newContext);
		TSConverter.validateParam(s, "ePasswordEncryption", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sMetaPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iMetaUseInServer", "number", errors, newContext);
		TSConverter.validateParam(s, "iMetaUseInClient", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iMetaEnabled, name: "iMetaEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iMetaPort, name: "iMetaPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMetaServer, name: "u8sMetaServer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBaseDN, name: "u8sBaseDN" }));
			t.push(new asn1ts.Integer({ value: s.iMetaForceSSL, name: "iMetaForceSSL" }));
			t.push(new asn1ts.Integer({ value: s.iMetaUseAccount, name: "iMetaUseAccount" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMetaUser, name: "u8sMetaUser" }));
			t.push(new asn1ts.Enumerated({ value: s.ePasswordEncryption, name: "ePasswordEncryption" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMetaPassword, name: "u8sMetaPassword" }));
			t.push(new asn1ts.Integer({ value: s.iMetaUseInServer, name: "iMetaUseInServer" }));
			t.push(new asn1ts.Integer({ value: s.iMetaUseInClient, name: "iMetaUseInClient" }));
		}

		if (errors.validateResult(newContext, "AsnMetaDirectorySettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnMetaDirectorySettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMetaDirectorySettings");

		let t: ENetROSEInterface.AsnMetaDirectorySettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnMetaDirectorySettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnMetaDirectorySettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iMetaEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMetaPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMetaServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBaseDN", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMetaForceSSL", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMetaUseAccount", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMetaUser", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "ePasswordEncryption", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMetaPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMetaUseInServer", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMetaUseInClient", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMetaDirectorySettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSetMetaSettingsArgument_Converter {
	public static toJSON(s: ENetROSEInterface.AsnSetMetaSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnSetMetaSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetMetaSettingsArgument");

		const t = {} as ENetROSEInterface.AsnSetMetaSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSetMetaSettingsArgument";
		TSConverter.fillJSONParam(s, t, "eSendPlainPassword", "number", errors, newContext);
		const _metasettings = AsnMetaDirectorySettings_Converter.toJSON(s.metasettings, errors, newContext, "metasettings");
		if (_metasettings)
			t.metasettings = _metasettings;

		if (errors.validateResult(newContext, "AsnSetMetaSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetMetaSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetMetaSettingsArgument");

		let t: ENetROSEInterface.AsnSetMetaSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnSetMetaSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnSetMetaSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eSendPlainPassword", "number", errors, newContext, false);
			const _metasettings = AsnMetaDirectorySettings_Converter.fromJSON(s.metasettings, errors, newContext, "metasettings", false);
			if (_metasettings)
				t.metasettings = _metasettings;
		}

		if (errors.validateResult(newContext, "AsnSetMetaSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnSetMetaSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSetMetaSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSetMetaSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eSendPlainPassword", "number", errors, newContext);
		const _metasettings = AsnMetaDirectorySettings_Converter.toBER(s.metasettings, errors, newContext, "metasettings");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Enumerated({ value: s.eSendPlainPassword, name: "eSendPlainPassword" }));
			if (_metasettings)
				t.push(_metasettings);
		}

		if (errors.validateResult(newContext, "AsnSetMetaSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnSetMetaSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSetMetaSettingsArgument");

		let t: ENetROSEInterface.AsnSetMetaSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnSetMetaSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnSetMetaSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eSendPlainPassword", "Enumerated", errors, newContext);
			const _metasettings = AsnMetaDirectorySettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "metasettings"), errors, newContext, "metasettings");
			if (_metasettings)
				t.metasettings = _metasettings;
		}

		if (errors.validateResult(newContext, "AsnSetMetaSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetMetaSettingsResult_Converter {
	public static toJSON(s: ENetROSEInterface.AsnGetMetaSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnGetMetaSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetMetaSettingsResult");

		const t = {} as ENetROSEInterface.AsnGetMetaSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetMetaSettingsResult";
		const _metasettings = AsnMetaDirectorySettings_Converter.toJSON(s.metasettings, errors, newContext, "metasettings");
		if (_metasettings)
			t.metasettings = _metasettings;

		if (errors.validateResult(newContext, "AsnGetMetaSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetMetaSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetMetaSettingsResult");

		let t: ENetROSEInterface.AsnGetMetaSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnGetMetaSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetROSEInterface.AsnGetMetaSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _metasettings = AsnMetaDirectorySettings_Converter.fromJSON(s.metasettings, errors, newContext, "metasettings", false);
			if (_metasettings)
				t.metasettings = _metasettings;
		}

		if (errors.validateResult(newContext, "AsnGetMetaSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnGetMetaSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetMetaSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetMetaSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _metasettings = AsnMetaDirectorySettings_Converter.toBER(s.metasettings, errors, newContext, "metasettings");
		if (!errors.hasNewErrors()) {
			if (_metasettings)
				t.push(_metasettings);
		}

		if (errors.validateResult(newContext, "AsnGetMetaSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnGetMetaSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetMetaSettingsResult");

		let t: ENetROSEInterface.AsnGetMetaSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnGetMetaSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetROSEInterface.AsnGetMetaSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _metasettings = AsnMetaDirectorySettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "metasettings"), errors, newContext, "metasettings");
			if (_metasettings)
				t.metasettings = _metasettings;
		}

		if (errors.validateResult(newContext, "AsnGetMetaSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactIDs_Converter {
	public static toJSON(s: ENetROSEInterface.AsnContactIDs, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetROSEInterface.AsnContactIDs | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactIDs");

		const t = [] as ENetROSEInterface.AsnContactIDs;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const se of s) {
			if (TSConverter.validateParamType(se, "AsnContactIDs", "string", errors, newContext, false))
				t.push(se);
		}

		if (errors.validateResult(newContext, "AsnContactIDs"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnContactIDs | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactIDs");

		let t: ENetROSEInterface.AsnContactIDs | undefined;
		const s = TSConverter.prepareJSONData<ENetROSEInterface.AsnContactIDs>(data, errors, newContext, optional);
		if (s) {
			t = new ENetROSEInterface.AsnContactIDs();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const se of s) {
				if (TSConverter.validateParamType(se, "AsnContactIDs", "string", errors, newContext, false))
					t.push(se);
			}
		}

		if (errors.validateResult(newContext, "AsnContactIDs"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetROSEInterface.AsnContactIDs | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactIDs";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactIDs");

		// [Print_BER_EncoderSetOfDefCode]
		for (const se of s) {
			if (TSConverter.validateParamType(se, "AsnContactIDs", "string", errors, newContext, false))
				t.push(new asn1ts.Utf8String({ value: se }));
		}

		if (errors.validateResult(newContext, "AsnContactIDs"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetROSEInterface.AsnContactIDs | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactIDs");

		let t: ENetROSEInterface.AsnContactIDs | undefined;
		const s = TSConverter.prepareASN1BERData(ENetROSEInterface.AsnContactIDs.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetROSEInterface.AsnContactIDs();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Utf8String.typeGuard(se)) {
					const value = se.getValue();
					if (TSConverter.validateParamType(value, "AsnContactIDs", "string", errors, newContext, false))
						t.push(value);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnContactIDs"))
			return t;

		return undefined;
	}
}
