// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Common_AsnContact_Converter.ts
 * "UC-Server-Access-Protocol-AsnContactCommon" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_Appointments from "./ENetUC_Common_Appointments";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
import * as ENetUC_Common_Appointments_Converter from "./ENetUC_Common_Appointments_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Common_AsnContact_Converter";
export const MODULE_LASTCHANGE = "2024-09-13T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240913;
export const MODULE_VERSION = "8.0.20240913";

// [PrintTSEncoderDecoderCode]
export class AsnUserDynamicRights_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnUserDynamicRights, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnUserDynamicRights & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUserDynamicRights");

		const t = {} as ENetUC_Common_AsnContact.AsnUserDynamicRights & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnUserDynamicRights";
		TSConverter.fillJSONParam(s, t, "u8sObjectID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPresenceRights", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPhoneControlRightsPrimary", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPhoneControlRightsSecondary", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnUserDynamicRights"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnUserDynamicRights | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUserDynamicRights");

		let t: ENetUC_Common_AsnContact.AsnUserDynamicRights | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnUserDynamicRights>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnUserDynamicRights["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sObjectID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPresenceRights", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPhoneControlRightsPrimary", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPhoneControlRightsSecondary", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnUserDynamicRights"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnUserDynamicRights | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnUserDynamicRights";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUserDynamicRights");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sObjectID", "string", errors, newContext);
		TSConverter.validateParam(s, "iPresenceRights", "number", errors, newContext);
		TSConverter.validateParam(s, "iPhoneControlRightsPrimary", "number", errors, newContext);
		TSConverter.validateParam(s, "iPhoneControlRightsSecondary", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sObjectID, name: "u8sObjectID" }));
			t.push(new asn1ts.Integer({ value: s.iPresenceRights, name: "iPresenceRights" }));
			t.push(new asn1ts.Integer({ value: s.iPhoneControlRightsPrimary, name: "iPhoneControlRightsPrimary" }));
			t.push(new asn1ts.Integer({ value: s.iPhoneControlRightsSecondary, name: "iPhoneControlRightsSecondary" }));
		}

		if (errors.validateResult(newContext, "AsnUserDynamicRights"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnUserDynamicRights | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUserDynamicRights");

		let t: ENetUC_Common_AsnContact.AsnUserDynamicRights | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnUserDynamicRights.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnUserDynamicRights["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sObjectID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPresenceRights", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPhoneControlRightsPrimary", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPhoneControlRightsSecondary", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnUserDynamicRights"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactCallInformationV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnContactCallInformationV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnContactCallInformationV2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactCallInformationV2");

		const t = {} as ENetUC_Common_AsnContact.AsnContactCallInformationV2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnContactCallInformationV2";
		TSConverter.fillJSONParam(s, t, "u8sContactChangedId", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPresenceState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConnectionID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLinePhoneNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCallState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDisconnectedReason", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iFeatures", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bOutbound", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bInternal", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bPrivate", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCallRecordingState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bConferenceCtlr", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCurrentNumberSC", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTrackerID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalCurrentNumberSC", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sRedirectingNumber", "string", errors, newContext, true);
		if (s.remoteContact) {
			const _remoteContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toJSON(s.remoteContact, errors, newContext, "remoteContact");
			if (_remoteContact)
				t.remoteContact = _remoteContact;
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactCallInformationV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactCallInformationV2");

		let t: ENetUC_Common_AsnContact.AsnContactCallInformationV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnContactCallInformationV2>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnContactCallInformationV2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactChangedId", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPresenceState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConnectionID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLinePhoneNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCallState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDisconnectedReason", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iFeatures", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bOutbound", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bInternal", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bPrivate", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCallRecordingState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bConferenceCtlr", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCurrentNumberSC", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTrackerID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalCurrentNumberSC", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sRedirectingNumber", "string", errors, newContext, true);
			const _remotecontact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromJSON(s.remoteContact, errors, newContext, "remoteContact", true);
			if (_remotecontact)
				t.remoteContact = _remotecontact;
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnContactCallInformationV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactCallInformationV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactCallInformationV2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactChangedId", "string", errors, newContext);
		TSConverter.validateParam(s, "iPresenceState", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConnectionID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLinePhoneNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "iCallState", "number", errors, newContext);
		TSConverter.validateParam(s, "iDisconnectedReason", "number", errors, newContext);
		TSConverter.validateParam(s, "iFeatures", "number", errors, newContext);
		TSConverter.validateParam(s, "bOutbound", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bInternal", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bPrivate", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iCallRecordingState", "number", errors, newContext);
		TSConverter.validateParam(s, "bConferenceCtlr", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sCurrentNumberSC", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTrackerID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalCurrentNumberSC", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sRedirectingNumber", "string", errors, newContext, true);
		const _remoteContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toBER(s.remoteContact, errors, newContext, "remoteContact", 1);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactChangedId, name: "u8sContactChangedId" }));
			t.push(new asn1ts.Integer({ value: s.iPresenceState, name: "iPresenceState" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConnectionID, name: "u8sConnectionID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLinePhoneNumber, name: "u8sLinePhoneNumber" }));
			t.push(new asn1ts.Integer({ value: s.iCallState, name: "iCallState" }));
			t.push(new asn1ts.Integer({ value: s.iDisconnectedReason, name: "iDisconnectedReason" }));
			t.push(new asn1ts.Integer({ value: s.iFeatures, name: "iFeatures" }));
			t.push(new asn1ts.Boolean({ value: s.bOutbound, name: "bOutbound" }));
			t.push(new asn1ts.Boolean({ value: s.bInternal, name: "bInternal" }));
			t.push(new asn1ts.Boolean({ value: s.bPrivate, name: "bPrivate" }));
			t.push(new asn1ts.Integer({ value: s.iCallRecordingState, name: "iCallRecordingState" }));
			t.push(new asn1ts.Boolean({ value: s.bConferenceCtlr, name: "bConferenceCtlr" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCurrentNumberSC, name: "u8sCurrentNumberSC" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTrackerID, name: "u8sTrackerID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalCurrentNumberSC, name: "u8sLocalCurrentNumberSC" }));
			if (s.u8sRedirectingNumber !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sRedirectingNumber, name: "u8sRedirectingNumber", idBlock: { optionalID: 0 } }));
			if (_remoteContact)
				t.push(_remoteContact);
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactCallInformationV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactCallInformationV2");

		let t: ENetUC_Common_AsnContact.AsnContactCallInformationV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnContactCallInformationV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnContactCallInformationV2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactChangedId", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPresenceState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConnectionID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLinePhoneNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCallState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDisconnectedReason", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iFeatures", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bOutbound", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bInternal", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bPrivate", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCallRecordingState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bConferenceCtlr", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCurrentNumberSC", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTrackerID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalCurrentNumberSC", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sRedirectingNumber", "Utf8String", errors, newContext, true);
			t.remoteContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "remoteContact"), errors, newContext, "remoteContact", true);
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSIPLineDetails_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnSIPLineDetails, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnSIPLineDetails & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPLineDetails");

		const t = {} as ENetUC_Common_AsnContact.AsnSIPLineDetails & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSIPLineDetails";
		TSConverter.fillJSONParam(s, t, "iSIPAVMediaMode", "number", errors, newContext);
		const _iSIPAVAudioCodecs = ENetUC_Common_Converter.SEQInteger_Converter.toJSON(s.iSIPAVAudioCodecs, errors, newContext, "iSIPAVAudioCodecs");
		if (_iSIPAVAudioCodecs)
			t.iSIPAVAudioCodecs = _iSIPAVAudioCodecs;
		TSConverter.fillJSONParam(s, t, "iMinPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxPort", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnSIPLineDetails"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnSIPLineDetails | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPLineDetails");

		let t: ENetUC_Common_AsnContact.AsnSIPLineDetails | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnSIPLineDetails>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnSIPLineDetails["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iSIPAVMediaMode", "number", errors, newContext, false);
			const _isipavaudiocodecs = ENetUC_Common_Converter.SEQInteger_Converter.fromJSON(s.iSIPAVAudioCodecs, errors, newContext, "iSIPAVAudioCodecs", false);
			if (_isipavaudiocodecs)
				t.iSIPAVAudioCodecs = _isipavaudiocodecs;
			TSConverter.fillJSONParam(s, t, "iMinPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxPort", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnSIPLineDetails"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnSIPLineDetails | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSIPLineDetails";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPLineDetails");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iSIPAVMediaMode", "number", errors, newContext);
		const _iSIPAVAudioCodecs = ENetUC_Common_Converter.SEQInteger_Converter.toBER(s.iSIPAVAudioCodecs, errors, newContext, "iSIPAVAudioCodecs");
		TSConverter.validateParam(s, "iMinPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxPort", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iSIPAVMediaMode, name: "iSIPAVMediaMode" }));
			if (_iSIPAVAudioCodecs)
				t.push(_iSIPAVAudioCodecs);
			t.push(new asn1ts.Integer({ value: s.iMinPort, name: "iMinPort" }));
			t.push(new asn1ts.Integer({ value: s.iMaxPort, name: "iMaxPort" }));
		}

		if (errors.validateResult(newContext, "AsnSIPLineDetails"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnSIPLineDetails | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPLineDetails");

		let t: ENetUC_Common_AsnContact.AsnSIPLineDetails | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnSIPLineDetails.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnSIPLineDetails["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iSIPAVMediaMode", "Integer", errors, newContext);
			const _isipavaudiocodecs = ENetUC_Common_Converter.SEQInteger_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "iSIPAVAudioCodecs"), errors, newContext, "iSIPAVAudioCodecs");
			if (_isipavaudiocodecs)
				t.iSIPAVAudioCodecs = _isipavaudiocodecs;
			TSConverter.fillASN1Param(s, t, "iMinPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxPort", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnSIPLineDetails"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCustomNote_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnCustomNote, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnCustomNote & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCustomNote");

		const t = {} as ENetUC_Common_AsnContact.AsnCustomNote & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCustomNote";
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNote", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnCustomNote"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnCustomNote | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCustomNote");

		let t: ENetUC_Common_AsnContact.AsnCustomNote | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnCustomNote>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnCustomNote["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNote", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnCustomNote"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnCustomNote | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCustomNote";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCustomNote");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNote", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNote, name: "u8sNote" }));
		}

		if (errors.validateResult(newContext, "AsnCustomNote"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnCustomNote | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCustomNote");

		let t: ENetUC_Common_AsnContact.AsnCustomNote | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnCustomNote.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnCustomNote["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNote", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnCustomNote"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactCallInformationsV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnContactCallInformationsV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnContactCallInformationsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactCallInformationsV2");

		const t = [] as ENetUC_Common_AsnContact.AsnContactCallInformationsV2;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnContactCallInformationV2_Converter.toJSON(se, errors, newContext, "AsnContactCallInformationV2");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationsV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactCallInformationsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactCallInformationsV2");

		let t: ENetUC_Common_AsnContact.AsnContactCallInformationsV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnContactCallInformationsV2>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Common_AsnContact.AsnContactCallInformationsV2();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnContactCallInformationV2_Converter.fromJSON(se, errors, newContext, "AsnContactCallInformationV2", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationsV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnContactCallInformationsV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactCallInformationsV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactCallInformationsV2");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnContactCallInformationV2_Converter.toBER(s[id], errors, newContext, "AsnContactCallInformationV2");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnContactCallInformationsV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactCallInformationsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactCallInformationsV2");

		let t: ENetUC_Common_AsnContact.AsnContactCallInformationsV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnContactCallInformationsV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Common_AsnContact.AsnContactCallInformationsV2();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnContactCallInformationV2_Converter.fromBER(se, errors, newContext, "AsnContactCallInformationV2", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnContactCallInformationsV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactPhoneLineV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnContactPhoneLineV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnContactPhoneLineV2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactPhoneLineV2");

		const t = {} as ENetUC_Common_AsnContact.AsnContactPhoneLineV2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnContactPhoneLineV2";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLinePhoneNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDescriptor", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNumber", "string", errors, newContext);
		const _seqCalls = AsnContactCallInformationsV2_Converter.toJSON(s.seqCalls, errors, newContext, "seqCalls");
		if (_seqCalls)
			t.seqCalls = _seqCalls;
		const _seqLineForwards = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toJSON(s.seqLineForwards, errors, newContext, "seqLineForwards");
		if (_seqLineForwards)
			t.seqLineForwards = _seqLineForwards;
		TSConverter.fillJSONParam(s, t, "iState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDoNotDisturb", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iForwardFeaturesPBX", "number", errors, newContext);
		const _u8sAddressNames = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sAddressNames, errors, newContext, "u8sAddressNames");
		if (_u8sAddressNames)
			t.u8sAddressNames = _u8sAddressNames;
		TSConverter.fillJSONParam(s, t, "u8sAddressCaps", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCTIFeatureCodes", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsPrivateLine", "boolean", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "bIsVoiceServicesLine", "boolean", errors, newContext, true);
		if (s.sipLineDetails) {
			const _sipLineDetails = AsnSIPLineDetails_Converter.toJSON(s.sipLineDetails, errors, newContext, "sipLineDetails");
			if (_sipLineDetails)
				t.sipLineDetails = _sipLineDetails;
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLineV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactPhoneLineV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactPhoneLineV2");

		let t: ENetUC_Common_AsnContact.AsnContactPhoneLineV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnContactPhoneLineV2>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnContactPhoneLineV2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLinePhoneNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDescriptor", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNumber", "string", errors, newContext, false);
			const _seqcalls = AsnContactCallInformationsV2_Converter.fromJSON(s.seqCalls, errors, newContext, "seqCalls", false);
			if (_seqcalls)
				t.seqCalls = _seqcalls;
			const _seqlineforwards = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromJSON(s.seqLineForwards, errors, newContext, "seqLineForwards", false);
			if (_seqlineforwards)
				t.seqLineForwards = _seqlineforwards;
			TSConverter.fillJSONParam(s, t, "iState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDoNotDisturb", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iForwardFeaturesPBX", "number", errors, newContext, false);
			const _u8saddressnames = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sAddressNames, errors, newContext, "u8sAddressNames", false);
			if (_u8saddressnames)
				t.u8sAddressNames = _u8saddressnames;
			TSConverter.fillJSONParam(s, t, "u8sAddressCaps", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCTIFeatureCodes", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsPrivateLine", "boolean", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "bIsVoiceServicesLine", "boolean", errors, newContext, true);
			const _siplinedetails = AsnSIPLineDetails_Converter.fromJSON(s.sipLineDetails, errors, newContext, "sipLineDetails", true);
			if (_siplinedetails)
				t.sipLineDetails = _siplinedetails;
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLineV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnContactPhoneLineV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactPhoneLineV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactPhoneLineV2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLinePhoneNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDescriptor", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNumber", "string", errors, newContext);
		const _seqCalls = AsnContactCallInformationsV2_Converter.toBER(s.seqCalls, errors, newContext, "seqCalls");
		const _seqLineForwards = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toBER(s.seqLineForwards, errors, newContext, "seqLineForwards");
		TSConverter.validateParam(s, "iState", "number", errors, newContext);
		TSConverter.validateParam(s, "bDoNotDisturb", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iForwardFeaturesPBX", "number", errors, newContext);
		const _u8sAddressNames = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sAddressNames, errors, newContext, "u8sAddressNames");
		TSConverter.validateParam(s, "u8sAddressCaps", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCTIFeatureCodes", "string", errors, newContext);
		TSConverter.validateParam(s, "bIsPrivateLine", "boolean", errors, newContext, true);
		TSConverter.validateParam(s, "bIsVoiceServicesLine", "boolean", errors, newContext, true);
		const _sipLineDetails = AsnSIPLineDetails_Converter.toBER(s.sipLineDetails, errors, newContext, "sipLineDetails", 2);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLinePhoneNumber, name: "u8sLinePhoneNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDescriptor, name: "u8sDescriptor" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNumber, name: "u8sNumber" }));
			if (_seqCalls)
				t.push(_seqCalls);
			if (_seqLineForwards)
				t.push(_seqLineForwards);
			t.push(new asn1ts.Enumerated({ value: s.iState, name: "iState" }));
			t.push(new asn1ts.Boolean({ value: s.bDoNotDisturb, name: "bDoNotDisturb" }));
			t.push(new asn1ts.Integer({ value: s.iForwardFeaturesPBX, name: "iForwardFeaturesPBX" }));
			if (_u8sAddressNames)
				t.push(_u8sAddressNames);
			t.push(new asn1ts.Utf8String({ value: s.u8sAddressCaps, name: "u8sAddressCaps" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCTIFeatureCodes, name: "u8sCTIFeatureCodes" }));
			if (s.bIsPrivateLine !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bIsPrivateLine, name: "bIsPrivateLine", idBlock: { optionalID: 0 } }));
			if (s.bIsVoiceServicesLine !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bIsVoiceServicesLine, name: "bIsVoiceServicesLine", idBlock: { optionalID: 1 } }));
			if (_sipLineDetails)
				t.push(_sipLineDetails);
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLineV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactPhoneLineV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactPhoneLineV2");

		let t: ENetUC_Common_AsnContact.AsnContactPhoneLineV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnContactPhoneLineV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnContactPhoneLineV2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLinePhoneNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDescriptor", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNumber", "Utf8String", errors, newContext);
			const _seqcalls = AsnContactCallInformationsV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "seqCalls"), errors, newContext, "seqCalls");
			if (_seqcalls)
				t.seqCalls = _seqcalls;
			const _seqlineforwards = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "seqLineForwards"), errors, newContext, "seqLineForwards");
			if (_seqlineforwards)
				t.seqLineForwards = _seqlineforwards;
			TSConverter.fillASN1Param(s, t, "iState", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDoNotDisturb", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iForwardFeaturesPBX", "Integer", errors, newContext);
			const _u8saddressnames = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sAddressNames"), errors, newContext, "u8sAddressNames");
			if (_u8saddressnames)
				t.u8sAddressNames = _u8saddressnames;
			TSConverter.fillASN1Param(s, t, "u8sAddressCaps", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCTIFeatureCodes", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsPrivateLine", "Boolean", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "bIsVoiceServicesLine", "Boolean", errors, newContext, true);
			t.sipLineDetails = AsnSIPLineDetails_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "sipLineDetails"), errors, newContext, "sipLineDetails", true);
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLineV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactPhoneLinesV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnContactPhoneLinesV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnContactPhoneLinesV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactPhoneLinesV2");

		const t = [] as ENetUC_Common_AsnContact.AsnContactPhoneLinesV2;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnContactPhoneLineV2_Converter.toJSON(se, errors, newContext, "AsnContactPhoneLineV2");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLinesV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactPhoneLinesV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactPhoneLinesV2");

		let t: ENetUC_Common_AsnContact.AsnContactPhoneLinesV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnContactPhoneLinesV2>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Common_AsnContact.AsnContactPhoneLinesV2();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnContactPhoneLineV2_Converter.fromJSON(se, errors, newContext, "AsnContactPhoneLineV2", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLinesV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnContactPhoneLinesV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactPhoneLinesV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactPhoneLinesV2");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnContactPhoneLineV2_Converter.toBER(s[id], errors, newContext, "AsnContactPhoneLineV2");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnContactPhoneLinesV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactPhoneLinesV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactPhoneLinesV2");

		let t: ENetUC_Common_AsnContact.AsnContactPhoneLinesV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnContactPhoneLinesV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Common_AsnContact.AsnContactPhoneLinesV2();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnContactPhoneLineV2_Converter.fromBER(se, errors, newContext, "AsnContactPhoneLineV2", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnContactPhoneLinesV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnExternalPresenceState_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnExternalPresenceState, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnExternalPresenceState & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnExternalPresenceState");

		const t = {} as ENetUC_Common_AsnContact.AsnExternalPresenceState & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnExternalPresenceState";
		TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnExternalPresenceState"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnExternalPresenceState | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnExternalPresenceState");

		let t: ENetUC_Common_AsnContact.AsnExternalPresenceState | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnExternalPresenceState>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnExternalPresenceState["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "eType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnExternalPresenceState"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnExternalPresenceState | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnExternalPresenceState";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnExternalPresenceState");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "iState", "number", errors, newContext);
		TSConverter.validateParam(s, "eType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUserName, name: "u8sUserName" }));
			t.push(new asn1ts.Integer({ value: s.iState, name: "iState" }));
			t.push(new asn1ts.Enumerated({ value: s.eType, name: "eType" }));
		}

		if (errors.validateResult(newContext, "AsnExternalPresenceState"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnExternalPresenceState | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnExternalPresenceState");

		let t: ENetUC_Common_AsnContact.AsnExternalPresenceState | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnExternalPresenceState.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnExternalPresenceState["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eType", "Enumerated", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnExternalPresenceState"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnExternalPresenceStates_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnExternalPresenceStates, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnExternalPresenceStates | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnExternalPresenceStates");

		const t = [] as ENetUC_Common_AsnContact.AsnExternalPresenceStates;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnExternalPresenceState_Converter.toJSON(se, errors, newContext, "AsnExternalPresenceState");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnExternalPresenceStates"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnExternalPresenceStates | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnExternalPresenceStates");

		let t: ENetUC_Common_AsnContact.AsnExternalPresenceStates | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnExternalPresenceStates>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Common_AsnContact.AsnExternalPresenceStates();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnExternalPresenceState_Converter.fromJSON(se, errors, newContext, "AsnExternalPresenceState", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnExternalPresenceStates"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnExternalPresenceStates | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnExternalPresenceStates";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnExternalPresenceStates");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnExternalPresenceState_Converter.toBER(s[id], errors, newContext, "AsnExternalPresenceState");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnExternalPresenceStates"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnExternalPresenceStates | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnExternalPresenceStates");

		let t: ENetUC_Common_AsnContact.AsnExternalPresenceStates | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnExternalPresenceStates.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Common_AsnContact.AsnExternalPresenceStates();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnExternalPresenceState_Converter.fromBER(se, errors, newContext, "AsnExternalPresenceState", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnExternalPresenceStates"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAbsentStateV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnAbsentStateV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnAbsentStateV2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAbsentStateV2");

		const t = {} as ENetUC_Common_AsnContact.AsnAbsentStateV2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAbsentStateV2";
		TSConverter.fillJSONParam(s, t, "u8sContactId", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eAbsentState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPresenceState", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "stTimeFrom", "Date", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "stTimeTo", "Date", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "eReachability", "number", errors, newContext, true);
		if (s.externalPresenceStates) {
			const _externalPresenceStates = AsnExternalPresenceStates_Converter.toJSON(s.externalPresenceStates, errors, newContext, "externalPresenceStates");
			if (_externalPresenceStates)
				t.externalPresenceStates = _externalPresenceStates;
		}

		if (errors.validateResult(newContext, "AsnAbsentStateV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnAbsentStateV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAbsentStateV2");

		let t: ENetUC_Common_AsnContact.AsnAbsentStateV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnAbsentStateV2>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnAbsentStateV2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactId", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "eAbsentState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPresenceState", "number", errors, newContext, true);
			if (TSConverter.validateParam(s, "stTimeFrom", "string", errors, newContext, true) && s.stTimeFrom)
				t.stTimeFrom = new Date(s.stTimeFrom);
			if (TSConverter.validateParam(s, "stTimeTo", "string", errors, newContext, true) && s.stTimeTo)
				t.stTimeTo = new Date(s.stTimeTo);
			TSConverter.fillJSONParam(s, t, "eReachability", "number", errors, newContext, true);
			const _externalpresencestates = AsnExternalPresenceStates_Converter.fromJSON(s.externalPresenceStates, errors, newContext, "externalPresenceStates", true);
			if (_externalpresencestates)
				t.externalPresenceStates = _externalpresencestates;
		}

		if (errors.validateResult(newContext, "AsnAbsentStateV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnAbsentStateV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAbsentStateV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAbsentStateV2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactId", "string", errors, newContext);
		TSConverter.validateParam(s, "eAbsentState", "number", errors, newContext);
		TSConverter.validateParam(s, "iPresenceState", "number", errors, newContext, true);
		TSConverter.validateParam(s, "stTimeFrom", "Date", errors, newContext, true);
		TSConverter.validateParam(s, "stTimeTo", "Date", errors, newContext, true);
		TSConverter.validateParam(s, "eReachability", "number", errors, newContext, true);
		const _externalPresenceStates = AsnExternalPresenceStates_Converter.toBER(s.externalPresenceStates, errors, newContext, "externalPresenceStates", 4);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactId, name: "u8sContactId" }));
			t.push(new asn1ts.Enumerated({ value: s.eAbsentState, name: "eAbsentState" }));
			if (s.iPresenceState !== undefined)
				t.push(new asn1ts.Integer({ value: s.iPresenceState, name: "iPresenceState", idBlock: { optionalID: 0 } }));
			if (s.stTimeFrom !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stTimeFrom), name: "stTimeFrom", idBlock: { optionalID: 1 } }));
			if (s.stTimeTo !== undefined)
				t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stTimeTo), name: "stTimeTo", idBlock: { optionalID: 2 } }));
			if (s.eReachability !== undefined)
				t.push(new asn1ts.Enumerated({ value: s.eReachability, name: "eReachability", idBlock: { optionalID: 3 } }));
			if (_externalPresenceStates)
				t.push(_externalPresenceStates);
		}

		if (errors.validateResult(newContext, "AsnAbsentStateV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnAbsentStateV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAbsentStateV2");

		let t: ENetUC_Common_AsnContact.AsnAbsentStateV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnAbsentStateV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnAbsentStateV2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactId", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eAbsentState", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPresenceState", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "stTimeFrom", "AsnSystemTime", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "stTimeTo", "AsnSystemTime", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "eReachability", "Enumerated", errors, newContext, true);
			t.externalPresenceStates = AsnExternalPresenceStates_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "externalPresenceStates"), errors, newContext, "externalPresenceStates", true);
		}

		if (errors.validateResult(newContext, "AsnAbsentStateV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnContactV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnContactV2 & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactV2");

		const t = {} as ENetUC_Common_AsnContact.AsnContactV2 & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnContactV2";
		TSConverter.fillJSONParam(s, t, "u8sContactId", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iContactFeatureSet", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPresenceState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStaticRights", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStaticRights2", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMonitorAccessRights", "number", errors, newContext);
		const _asnRemoteContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toJSON(s.asnRemoteContact, errors, newContext, "asnRemoteContact");
		if (_asnRemoteContact)
			t.asnRemoteContact = _asnRemoteContact;
		const _seqPhoneLines = AsnContactPhoneLinesV2_Converter.toJSON(s.seqPhoneLines, errors, newContext, "seqPhoneLines");
		if (_seqPhoneLines)
			t.seqPhoneLines = _seqPhoneLines;
		const _asnAbsentState = AsnAbsentStateV2_Converter.toJSON(s.asnAbsentState, errors, newContext, "asnAbsentState");
		if (_asnAbsentState)
			t.asnAbsentState = _asnAbsentState;
		const _asnCustomNote = AsnCustomNote_Converter.toJSON(s.asnCustomNote, errors, newContext, "asnCustomNote");
		if (_asnCustomNote)
			t.asnCustomNote = _asnCustomNote;
		const _seqActualAppointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toJSON(s.seqActualAppointments, errors, newContext, "seqActualAppointments");
		if (_seqActualAppointments)
			t.seqActualAppointments = _seqActualAppointments;
		const _asnNextAppointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.toJSON(s.asnNextAppointment, errors, newContext, "asnNextAppointment");
		if (_asnNextAppointment)
			t.asnNextAppointment = _asnNextAppointment;
		const _asnUserPropertyBag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.toJSON(s.asnUserPropertyBag, errors, newContext, "asnUserPropertyBag");
		if (_asnUserPropertyBag)
			t.asnUserPropertyBag = _asnUserPropertyBag;

		if (errors.validateResult(newContext, "AsnContactV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactV2");

		let t: ENetUC_Common_AsnContact.AsnContactV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnContactV2>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Common_AsnContact.AsnContactV2["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactId", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iContactFeatureSet", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPresenceState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStaticRights", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStaticRights2", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMonitorAccessRights", "number", errors, newContext, false);
			const _asnremotecontact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromJSON(s.asnRemoteContact, errors, newContext, "asnRemoteContact", false);
			if (_asnremotecontact)
				t.asnRemoteContact = _asnremotecontact;
			const _seqphonelines = AsnContactPhoneLinesV2_Converter.fromJSON(s.seqPhoneLines, errors, newContext, "seqPhoneLines", false);
			if (_seqphonelines)
				t.seqPhoneLines = _seqphonelines;
			const _asnabsentstate = AsnAbsentStateV2_Converter.fromJSON(s.asnAbsentState, errors, newContext, "asnAbsentState", false);
			if (_asnabsentstate)
				t.asnAbsentState = _asnabsentstate;
			const _asncustomnote = AsnCustomNote_Converter.fromJSON(s.asnCustomNote, errors, newContext, "asnCustomNote", false);
			if (_asncustomnote)
				t.asnCustomNote = _asncustomnote;
			const _seqactualappointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromJSON(s.seqActualAppointments, errors, newContext, "seqActualAppointments", false);
			if (_seqactualappointments)
				t.seqActualAppointments = _seqactualappointments;
			const _asnnextappointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.fromJSON(s.asnNextAppointment, errors, newContext, "asnNextAppointment", false);
			if (_asnnextappointment)
				t.asnNextAppointment = _asnnextappointment;
			const _asnuserpropertybag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.fromJSON(s.asnUserPropertyBag, errors, newContext, "asnUserPropertyBag", false);
			if (_asnuserpropertybag)
				t.asnUserPropertyBag = _asnuserpropertybag;
		}

		if (errors.validateResult(newContext, "AsnContactV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnContactV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactV2");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactId", "string", errors, newContext);
		TSConverter.validateParam(s, "iContactFeatureSet", "number", errors, newContext);
		TSConverter.validateParam(s, "iPresenceState", "number", errors, newContext);
		TSConverter.validateParam(s, "iStaticRights", "number", errors, newContext);
		TSConverter.validateParam(s, "iStaticRights2", "number", errors, newContext);
		TSConverter.validateParam(s, "iMonitorAccessRights", "number", errors, newContext);
		const _asnRemoteContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toBER(s.asnRemoteContact, errors, newContext, "asnRemoteContact");
		const _seqPhoneLines = AsnContactPhoneLinesV2_Converter.toBER(s.seqPhoneLines, errors, newContext, "seqPhoneLines");
		const _asnAbsentState = AsnAbsentStateV2_Converter.toBER(s.asnAbsentState, errors, newContext, "asnAbsentState");
		const _asnCustomNote = AsnCustomNote_Converter.toBER(s.asnCustomNote, errors, newContext, "asnCustomNote");
		const _seqActualAppointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.toBER(s.seqActualAppointments, errors, newContext, "seqActualAppointments");
		const _asnNextAppointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.toBER(s.asnNextAppointment, errors, newContext, "asnNextAppointment");
		const _asnUserPropertyBag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.toBER(s.asnUserPropertyBag, errors, newContext, "asnUserPropertyBag");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactId, name: "u8sContactId" }));
			t.push(new asn1ts.Integer({ value: s.iContactFeatureSet, name: "iContactFeatureSet" }));
			t.push(new asn1ts.Integer({ value: s.iPresenceState, name: "iPresenceState" }));
			t.push(new asn1ts.Integer({ value: s.iStaticRights, name: "iStaticRights" }));
			t.push(new asn1ts.Integer({ value: s.iStaticRights2, name: "iStaticRights2" }));
			t.push(new asn1ts.Integer({ value: s.iMonitorAccessRights, name: "iMonitorAccessRights" }));
			if (_asnRemoteContact)
				t.push(_asnRemoteContact);
			if (_seqPhoneLines)
				t.push(_seqPhoneLines);
			if (_asnAbsentState)
				t.push(_asnAbsentState);
			if (_asnCustomNote)
				t.push(_asnCustomNote);
			if (_seqActualAppointments)
				t.push(_seqActualAppointments);
			if (_asnNextAppointment)
				t.push(_asnNextAppointment);
			if (_asnUserPropertyBag)
				t.push(_asnUserPropertyBag);
		}

		if (errors.validateResult(newContext, "AsnContactV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactV2");

		let t: ENetUC_Common_AsnContact.AsnContactV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnContactV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Common_AsnContact.AsnContactV2["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactId", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iContactFeatureSet", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPresenceState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStaticRights", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStaticRights2", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMonitorAccessRights", "Integer", errors, newContext);
			const _asnremotecontact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnRemoteContact"), errors, newContext, "asnRemoteContact");
			if (_asnremotecontact)
				t.asnRemoteContact = _asnremotecontact;
			const _seqphonelines = AsnContactPhoneLinesV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "seqPhoneLines"), errors, newContext, "seqPhoneLines");
			if (_seqphonelines)
				t.seqPhoneLines = _seqphonelines;
			const _asnabsentstate = AsnAbsentStateV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnAbsentState"), errors, newContext, "asnAbsentState");
			if (_asnabsentstate)
				t.asnAbsentState = _asnabsentstate;
			const _asncustomnote = AsnCustomNote_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnCustomNote"), errors, newContext, "asnCustomNote");
			if (_asncustomnote)
				t.asnCustomNote = _asncustomnote;
			const _seqactualappointments = ENetUC_Common_Appointments_Converter.SEQAppointmentList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "seqActualAppointments"), errors, newContext, "seqActualAppointments");
			if (_seqactualappointments)
				t.seqActualAppointments = _seqactualappointments;
			const _asnnextappointment = ENetUC_Common_Appointments_Converter.AsnAppointmentEntry_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnNextAppointment"), errors, newContext, "asnNextAppointment");
			if (_asnnextappointment)
				t.asnNextAppointment = _asnnextappointment;
			const _asnuserpropertybag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnUserPropertyBag"), errors, newContext, "asnUserPropertyBag");
			if (_asnuserpropertybag)
				t.asnUserPropertyBag = _asnuserpropertybag;
		}

		if (errors.validateResult(newContext, "AsnContactV2"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnUserDynamicRightsList_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnUserDynamicRightsList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnUserDynamicRightsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUserDynamicRightsList");

		const t = [] as ENetUC_Common_AsnContact.AsnUserDynamicRightsList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnUserDynamicRights_Converter.toJSON(se, errors, newContext, "AsnUserDynamicRights");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnUserDynamicRightsList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnUserDynamicRightsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUserDynamicRightsList");

		let t: ENetUC_Common_AsnContact.AsnUserDynamicRightsList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnUserDynamicRightsList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Common_AsnContact.AsnUserDynamicRightsList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnUserDynamicRights_Converter.fromJSON(se, errors, newContext, "AsnUserDynamicRights", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnUserDynamicRightsList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnUserDynamicRightsList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnUserDynamicRightsList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUserDynamicRightsList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnUserDynamicRights_Converter.toBER(s[id], errors, newContext, "AsnUserDynamicRights");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnUserDynamicRightsList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnUserDynamicRightsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUserDynamicRightsList");

		let t: ENetUC_Common_AsnContact.AsnUserDynamicRightsList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnUserDynamicRightsList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Common_AsnContact.AsnUserDynamicRightsList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnUserDynamicRights_Converter.fromBER(se, errors, newContext, "AsnUserDynamicRights", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnUserDynamicRightsList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnContactsV2_Converter {
	public static toJSON(s: ENetUC_Common_AsnContact.AsnContactsV2, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Common_AsnContact.AsnContactsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactsV2");

		const t = [] as ENetUC_Common_AsnContact.AsnContactsV2;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnContactV2_Converter.toJSON(se, errors, newContext, "AsnContactV2");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnContactsV2"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactsV2");

		let t: ENetUC_Common_AsnContact.AsnContactsV2 | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Common_AsnContact.AsnContactsV2>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Common_AsnContact.AsnContactsV2();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnContactV2_Converter.fromJSON(se, errors, newContext, "AsnContactV2", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnContactsV2"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Common_AsnContact.AsnContactsV2 | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnContactsV2";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnContactsV2");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnContactV2_Converter.toBER(s[id], errors, newContext, "AsnContactV2");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnContactsV2"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Common_AsnContact.AsnContactsV2 | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnContactsV2");

		let t: ENetUC_Common_AsnContact.AsnContactsV2 | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Common_AsnContact.AsnContactsV2.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Common_AsnContact.AsnContactsV2();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnContactV2_Converter.fromBER(se, errors, newContext, "AsnContactV2", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnContactsV2"))
			return t;

		return undefined;
	}
}
