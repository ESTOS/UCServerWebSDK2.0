// [PrintTSCodeOne]
// [PrintTSComments]
/*
 * ENetROSEInterface.ts
 * "UC-Server-Access-Protocol-Main" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
/**
 * General interface
 * ## Module description
 * General interfacefunctions not included in any other module.
 */
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
import * as ENetUC_Common_Appointments from "./ENetUC_Common_Appointments";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetROSEInterface";
export const MODULE_LASTCHANGE = "2024-08-22T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240822;
export const MODULE_VERSION = "8.0.20240822";

// [PrintTSTypeDefCode]
// [PrintTSimpleDefCode]
export type AsnContactID = string;

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnETAPIDialNumberFormat {
	/** Normal formatting, all rules apply */
	eTAPIDIALNUMBERFORMATNORMAL = 0,
	/** Make all numbers upercanoncal (e.g. +49815136856177) */
	eTAPIDIALNUMBERFORMATSUPERCANONIC = 1,
	/** No rules apply, numbers will be dialed like they were entered; only special character will be removed */
	eTAPIDIALNUMBERFORMATPLAIN = 2,
	/** Plain numbers will be dialed like they were entered, supercanonical numbers will be formatted. The PBX will always get dialable numbers. */
	eTAPIDIALNUMBERFORMATDIALABLEPLAIN = 3
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnERemoteTapiNumberFormat {
	/** Plain, wie von PBX */
	eREMOTETAPINUMBERFORMATPLAIN = 0,
	/** Vorformatiert, aber nicht Superkanonisch */
	eREMOTETAPINUMBERFORMATPREFORMAT = 1,
	/** Superkanonisch */
	eREMOTETAPINUMBERFORMATSUPERCANONIC = 2
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnERemoteTapiDialFormat {
	/** Plain wählen, nur PC Wahl Final anwenden */
	eREMOTETAPIDIALFORMATPLAIN = 0,
	/** Komplett Formatieren */
	eREMOTETAPIDIALFORMATALL = 1
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnERemoteTapiLineNames {
	/** Wie vom TAPI-Treiber gemeldet */
	eREMOTETAPILINENAMESORIGINAL = 0,
	/** Mit Standortinformationen erweitert */
	eREMOTETAPILINENAMESLINENUMBER = 1
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnForwardMode {
	/** Forward unknown */
	iCTIFORWARDUNKNOWN = 0,
	/** Forward Immediate */
	iCTIFORWARDIMMEDIATE = 1,
	/** Forward on Busy */
	iCTIFORWARDBUSY = 2,
	/** Forward on No Answer */
	iCTIFORWARDNOANSW = 3,
	/** Forward on Busy for internal */
	iCTIFORWARDBUSYINT = 4,
	/** Forward on Busy for external */
	iCTIFORWARDBUSYEXT = 5,
	/** Forward on No answer for int */
	iCTIFORWARDNOANSINT = 6,
	/** Forward on No answer for ext */
	iCTIFORWARDNOANSEXT = 7,
	/** Forward immediate for intern */
	iCTIFORWARDIMMINT = 8,
	/** Forward immediate for extern */
	iCTIFORWARDIMMEXT = 9,
	/** Backend specific forwarding */
	iCTIBACKENDSPECIFIC = 10
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPresenceStateEnum {
	/** Presence is not available, contact is unknown. */
	eUNCONTROLLED = 0,
	/** Contact is available. */
	eAVAILABLE = 1,
	/** Contact is busy. */
	eBUSY = 2,
	/** Contact is absent. */
	eABSENT = 3,
	/** Contact wished to not being disturbed. */
	eDONOTDISTURB = 4,
	/** Something does not work, line is not connected, device is broken etc. Contact may not get into this state. */
	eOUTOFORDER = 7
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPresenceStateFlags {
	/** 0x00010000 - The contact is doing work after a call and should be treated as \"busy\". (added after PCE 5.1) */
	eWORKINGAFTERCALL = 65536,
	/** 0x00020000 - The contact is participating a conference with our conferencing product (added with PCE 7.1) */
	eCONFERENCING = 131072,
	/** 0x01000000 - The contact has a call ringing on one of his phone or A\/V lines. */
	eRINGING = 16777216,
	/** 0x02000000 - The contavct has currently an active appointment in \"absent\", \"busy\" or \"free\" state. */
	eAPPOINTMENT = 33554432,
	/** 0x04000000 - The contact is in a call. */
	eCALL = 67108864,
	/** 0x08000000 - The contact is offline. */
	eOFFLINE = 134217728,
	/** 0x10000000 - The contact has set a note. */
	eNOTESET = 268435456,
	/** 0x20000000 - The contact does not used his mouse or keyboard for a time or is only logged in with a mobile device. */
	eIDLE = 536870912,
	/** 0x40000000 - The contact is most likely reachable on his mobile device. */
	eMOBILEAVAILABLITY = 1073741824
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPresenceStateMasks {
	/** 0x000000ff - Currently the lower byte contains the presence state */
	ePresenceStateMask = 255,
	/** 0x00ff0000 - Additional flags introduced later in the development process of ProCall after Version 5.1. */
	ePresenceStateFlagsMaskAdd = 16711680,
	/** 0x7f000000 - Currently the top most byte of the DWORD contains the presence state flags. Addendum: a technical constraint in the c# library prevents the usage of the top most bit. */
	ePresenceStateFlagsMask = 2130706432
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum EnumCallState {
	/** Call is in an unknown state. */
	eCALLSTATEUNKNOWN = 0,
	/** Call was destroyed by dropping it. */
	eCALLSTATEDESTROYED = 1,
	/** Call is ringing inbound. */
	eCALLSTATEOFFERING = 2,
	/** User is dialing. */
	eCALLSTATEDIALING = 4,
	/** Call is ringing outbound (call number is complete) */
	eCALLSTATERINGBACK = 8,
	/** Call outbound is busy. */
	eCALLSTATEBUSY = 16,
	/** Call is connected (same for in- and outbound) */
	eCALLSTATECONNECTED = 32,
	/** Call is part of a call conference. */
	eCALLSTATECONFERENCED = 64,
	/** Call is on hold. */
	eCALLSTATEHOLD = 128,
	/** Call is disconnected by the call partner. The user should drop the call too, then it will get destroyed too. */
	eCALLSTATEDISCONNECTED = 256,
	/** Call is in a prepare state (special for procall, this is not a normal PBX state). */
	eCALLSTATEPREPARECALL = 512
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum EnumCallDisconnectedReason {
	/** Disconnect reason unknown, even if the call was successful connected and one of the participants has dropped the call. */
	eDISCONNECTEDREASONUNKNOWN = 0,
	/** The call partner did not answer the call. */
	eDISCONNECTEDREASONUNCONNECTED = 1,
	/** The call partner is busy. */
	eDISCONNECTEDREASONBUSY = 2,
	/**
	 * Anruf wurde aus einem ECALLSTATE_OFFERING heraus mit redirect oder Pickup weggeholt
	 * The call was redirected or picked in the state offering (eCALLSTATEOFFERING) by an unkown line or participant.
	 */
	eDISCONNECTEDREASONREDIRECTEDUNKNOWN = 3,
	/** The call was redirected or picked in the state offering (eCALLSTATEOFFERING) by the line owner. */
	eDISCONNECTEDREASONREDIRECTEDBYLINEOWNER = 4
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum EnumRemoteContactSource {
	/** Data source is unknown\/not set */
	eUNKNOWN = 0,
	/** Server provided the contact data */
	eSERVERPROVIDED = 1,
	/** The client provided the contact data */
	eCLIENTPROVIDED = 2,
	/** Another client provided the contact data (if the same user has more than one client running) */
	eOTHERCLIENTPROVIDED = 3
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum EAsnCallType {
	/** Just a normal call. */
	eCALLTYPENORMAL = 0,
	/** Consultation call. */
	eCALLTYPECONSULT = 1,
	/** Conference controller call. */
	eCALLTYPECONFERENCECONTROLER = 2,
	/** Callback call (callback while busy or callback was not answered) */
	eCALLTYPECALLBACK = 3,
	/** Conference member call. */
	eCALLTYPECONFERENCEMEMBER = 4,
	/** Conference controller while building up the conference (US conference model) */
	eCALLTYPECONFERENCECONTROLERPENDING = 5,
	/** Conference member while building up the conference (US conference model) */
	eCALLTYPECONFERENCEMEMBERPENDING = 6
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum EnumCallRecordingState {
	/** Call recording not active. */
	eNOCALLRECODRING = 0,
	/** This is the call recording call to the ISDN\/CAPI device usewd to record the call. */
	eCALLRECORDERCALL = 1,
	/** Call which will be recorded. */
	eCALLRECORDINGMEMBER = 2,
	/** Call which was the **recorder** call. */
	eWASCALLRECORDERCALL = 3,
	/** Call which was the **recorded** call. */
	eWASCALLRECORDINGMEMBER = 4
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPresenceRightsFlags {
	eVisible = 1,
	eChangeable = 2,
	/** 0x0000 0010 */
	eAppointmentPrivate = 16,
	/** 0x0000 0020 */
	eAppointmentPublic = 32,
	/** 0x0000 8000 */
	ePatternUsed = 32768,
	eBlocked = 0,
	/** 0x0001 0000 */
	ePublic = 65536,
	/** 0x0002 0000 */
	eCompany = 131072,
	/** 0x0004 0000 */
	eTeam = 262144,
	/** 0x0008 0000 */
	ePersonal = 524288
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPresenceRightsMasks {
	/** 0x0000 00F0 */
	eAppointmentMask = 240,
	/** 0x000F 0000 */
	ePatternFlagsMask = 983040
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPhoneControlRightsFlags {
	eBlocked = 0,
	/** 0x0000 0001 */
	eNumbersOutbound = 1,
	/** 0x0000 0002 */
	eNumbersInbound = 2,
	/** 0x0000 0004 */
	eNumbersRedirected = 4,
	/** 0x0000 0100 */
	eSetForwards = 256,
	/** 0x0000 0200 */
	eSetPickupCalls = 512
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPresenceCommonRights {
	/** 0x0000 0000      Blocked \/ not set */
	eBlocked = 0,
	/** 0x0001 8001      UR_PRESENCE_PUBLIC  | UR_PRESENCE_PATTERN_USED                                                                                                  | UR_PRESENCE_VISIBLE */
	ePublic = 98305,
	/** 0x0002 8021      UR_PRESENCE_COMPANY | UR_PRESENCE_PATTERN_USED | UR_PRESENCE_APPOINTMENT_PUBLIC                                                                 | UR_PRESENCE_VISIBLE */
	eCompany = 163873,
	/** 0x0004 8023      UR_PRESENCE_TEAM    | UR_PRESENCE_PATTERN_USED | UR_PRESENCE_APPOINTMENT_PUBLIC                                     | UR_PRESENCE_CHANGEABLE    | UR_PRESENCE_VISIBLE */
	eTeam = 294947,
	/** 0x0008 8033      UR_PRESENCE_PERSONAL| UR_PRESENCE_PATTERN_USED | UR_PRESENCE_APPOINTMENT_PUBLIC | UR_PRESENCE_APPOINTMENT_PRIVATE   | UR_PRESENCE_CHANGEABLE    | UR_PRESENCE_VISIBLE */
	ePersonal = 557107
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPhoneControlPrimaryCommonRights {
	/** 0x0000	Blocked \/ not set */
	eBlocked = 0,
	/** 0x0007  UR_PHONE_NUMBERS_OUTBOUND   | UR_PHONE_NUMBERS_INBOUND    | UR_PHONE_NUMBERS_REDIRECTED */
	eCompany = 7,
	/** 0x0207  UR_PHONE_NUMBERS_OUTBOUND   | UR_PHONE_NUMBERS_INBOUND    | UR_PHONE_NUMBERS_REDIRECTED    | UR_PHONE_PICKUP_CALLS */
	eTeam = 519,
	/** 0x0307  UR_PHONE_NUMBERS_OUTBOUND   | UR_PHONE_NUMBERS_INBOUND    | UR_PHONE_NUMBERS_REDIRECTED    | UR_PHONE_PICKUP_CALLS | UR_PHONE_SET_FORWARDS */
	ePersonal = 775
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnPhoneControlSecondaryCommonRights {
	/** 0x0000	Blocked \/ not set */
	eBlocked = 0,
	/** 0x0007  UR_PHONE_NUMBERS_OUTBOUND   | UR_PHONE_NUMBERS_INBOUND    | UR_PHONE_NUMBERS_REDIRECTED */
	eTeam = 7,
	/** 0x0307  UR_PHONE_NUMBERS_OUTBOUND   | UR_PHONE_NUMBERS_INBOUND    | UR_PHONE_NUMBERS_REDIRECTED    | UR_PHONE_PICKUP_CALLS | UR_PHONE_SET_FORWARDS */
	ePersonal = 775
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnContactFeatureSetEnum {
	/** Nothing is alllowed on this contact. */
	eCONTACTFEATURENONE = 0,
	/** Dial on the primary line of the other contact. */
	eCONTACTFEATUREDIAL = 1,
	/** Set forward on the first line of the other contact. */
	eCONTACTFEATURESETFORWARDL1 = 2,
	/** Set forward on the second line of the other contact. */
	eCONTACTFEATURESETFORWARDL2 = 4,
	/** Swap Call. */
	eCONTACTFEATURESWAP = 8,
	/** Answer call. */
	eCONTACTFEATUREANSWER = 16,
	/** Hang up. */
	eCONTACTFEATUREHANGUP = 32,
	/** Pickup a ringing call on the first line of the contact. */
	eCONTACTFEATUREPICKUPL1 = 64,
	/** Pickup a ringing call on the second line of the contact. */
	eCONTACTFEATUREPICKUPL2 = 128,
	/** Hold the active call. */
	eCONTACTFEATUREHOLD = 256,
	/** Send a message. */
	eCONTACTFEATUREMESSAGE = 512,
	/** Redirect a ringing call. */
	eCONTACTFEATUREREDIRECT = 1024,
	/** Set absent state of the contact. */
	eCONTACTFEATURESETABSENT = 2048
}

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnMetaDirectoryPasswordEncryption {
	/** Passwort verschlüsselt übertragen */
	iEncrypted = 0,
	/** Passwort als Klartext übermitteln */
	iPlain = 1
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Regular expression to reformat a phone number. Replaces AsnNumberFormatRegExpression.
 */
export class AsnNumberFormatRegExpression2 {
	public constructor(that: AsnNumberFormatRegExpression2) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNumberFormatRegExpression2 {
		return new AsnNumberFormatRegExpression2({
			u8sSearch: "",
			u8sReplace: "",
			bMatchReplace: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sSearch",
			"u8sReplace",
			"bMatchReplace"
		];
		return p;
	}

	public static type = "AsnNumberFormatRegExpression2";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNumberFormatRegExpression2",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sSearch" }),
				new asn1ts.Utf8String({ name: "u8sReplace" }),
				new asn1ts.Boolean({ name: "bMatchReplace" }),
				new asn1ts.Extension()
			]
		});
	}

	public u8sSearch!: string;
	public u8sReplace!: string;
	public bMatchReplace!: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argunment for asnKeepAlive.
 */
export class AsnKeepAliveArgument {
	public constructor(that: AsnKeepAliveArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnKeepAliveArgument {
		return new AsnKeepAliveArgument({
			dummy: null
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"dummy"
		];
		return p;
	}

	public static type = "AsnKeepAliveArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnKeepAliveArgument",
			...params,
			value: [
				new asn1ts.Null({ name: "dummy" }),
				new asn1ts.Extension()
			]
		});
	}

	/** no parameter */
	public dummy!: null;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argument for asnGetLocationInformation and asnGetLocationInformation2.
 */
export class AsnGetLocationInformationArgument {
	public constructor(that: AsnGetLocationInformationArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetLocationInformationArgument {
		return new AsnGetLocationInformationArgument({
			u8sLocationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sLocationID"
		];
		return p;
	}

	public static type = "AsnGetLocationInformationArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetLocationInformationArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sLocationID" }),
				new asn1ts.Extension()
			]
		});
	}

	/** The identifier of a location information. See asnGetLocationIDs as an example how to get a location id. */
	public u8sLocationID!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnSetLocationInformation2Result {
	public constructor(that?: AsnSetLocationInformation2Result) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSetLocationInformation2Result {
		return new AsnSetLocationInformation2Result();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnSetLocationInformation2Result";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSetLocationInformation2Result",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Liefert die LocationIDs mit passender MD5 Prüfsumme.
 * Wird vom Client verwendet um zu Prüfen ob seine Location Settings noch aktuell sind
 */
export class AsnGetLocationIDsArgument {
	public constructor(that?: AsnGetLocationIDsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetLocationIDsArgument {
		return new AsnGetLocationIDsArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals)
			p.push("locationIDs");
		return p;
	}

	public static type = "AsnGetLocationIDsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetLocationIDsArgument",
			...params,
			value: [
				ENetUC_Common.UTF8StringList.getASN1Schema({ name: "locationIDs", idBlock: { optionalID: 0 } }),
				new asn1ts.Extension()
			]
		});
	}

	public locationIDs?: ENetUC_Common.UTF8StringList;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnGetLocationIDsResult {
	public constructor(that: AsnGetLocationIDsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetLocationIDsResult {
		return new AsnGetLocationIDsResult({
			locationIDMD5ChecksumList: new ENetUC_Common.AsnStringPairList()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"locationIDMD5ChecksumList"
		];
		return p;
	}

	public static type = "AsnGetLocationIDsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetLocationIDsResult",
			...params,
			value: [
				ENetUC_Common.AsnStringPairList.getASN1Schema({ name: "locationIDMD5ChecksumList" }),
				new asn1ts.Extension()
			]
		});
	}

	/** first LocationID, last MD5 Checksum */
	public locationIDMD5ChecksumList!: ENetUC_Common.AsnStringPairList;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnLocationInformationChangedArgument {
	public constructor(that: AsnLocationInformationChangedArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLocationInformationChangedArgument {
		return new AsnLocationInformationChangedArgument({
			u8sLocationID: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sLocationID"
		];
		if (bIncludeOptionals)
			p.push("optionalParams");
		return p;
	}

	public static type = "AsnLocationInformationChangedArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLocationInformationChangedArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sLocationID" }),
				ENetUC_Common.AsnOptionalParameters.getASN1Schema({ name: "optionalParams", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	public u8sLocationID!: string;
	/** optionalParams Name \"MD5CheckSum\" Value UTF8String MD5 Prüfsumme über den Standort */
	public optionalParams?: ENetUC_Common.AsnOptionalParameters;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * The changed contact details for the asnUpdateMyContactConfigurationV2 operation
 */
export class AsnUpdateMyContactConfigurationV2Argument {
	public constructor(that: AsnUpdateMyContactConfigurationV2Argument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnUpdateMyContactConfigurationV2Argument {
		return new AsnUpdateMyContactConfigurationV2Argument({
			contactChanged: ENetUC_Common_AsnContact.AsnContactV2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"contactChanged"
		];
		return p;
	}

	public static type = "AsnUpdateMyContactConfigurationV2Argument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnUpdateMyContactConfigurationV2Argument",
			...params,
			value: [
				ENetUC_Common_AsnContact.AsnContactV2.getASN1Schema({ name: "contactChanged" }),
				new asn1ts.Extension()
			]
		});
	}

	public contactChanged!: ENetUC_Common_AsnContact.AsnContactV2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argument for asnSetUserAbsentState
 * Set change the manual presence of a user, a AsnAbsentState struct has to be sent to the ucserver.
 */
export class AsnSetUserAbsentStateArgument {
	public constructor(that: AsnSetUserAbsentStateArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSetUserAbsentStateArgument {
		return new AsnSetUserAbsentStateArgument({
			absentstate: ENetUC_Common_AsnContact.AsnAbsentStateV2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"absentstate"
		];
		return p;
	}

	public static type = "AsnSetUserAbsentStateArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSetUserAbsentStateArgument",
			...params,
			value: [
				ENetUC_Common_AsnContact.AsnAbsentStateV2.getASN1Schema({ name: "absentstate" }),
				new asn1ts.Extension()
			]
		});
	}

	/** The AsnAbsentState data to change the manual presence of the user. */
	public absentstate!: ENetUC_Common_AsnContact.AsnAbsentStateV2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Result of asnSetUserAbsentState if the operation executes successfully.
 * Result of asnAbsentStateSetUser if the operation executes successfully.
 */
export class AsnSetUserAbsentStateResult {
	public constructor(that: AsnSetUserAbsentStateResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSetUserAbsentStateResult {
		return new AsnSetUserAbsentStateResult({
			bSuccess: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"bSuccess"
		];
		return p;
	}

	public static type = "AsnSetUserAbsentStateResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSetUserAbsentStateResult",
			...params,
			value: [
				new asn1ts.Boolean({ name: "bSuccess" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Should always be true. */
	public bSuccess!: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * @added 21.08.2024
 */
export class AsnGetUserAbsentStateResult {
	public constructor(that: AsnGetUserAbsentStateResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetUserAbsentStateResult {
		return new AsnGetUserAbsentStateResult({
			absentstate: ENetUC_Common_AsnContact.AsnAbsentStateV2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"absentstate"
		];
		return p;
	}

	public static type = "AsnGetUserAbsentStateResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetUserAbsentStateResult",
			...params,
			value: [
				ENetUC_Common_AsnContact.AsnAbsentStateV2.getASN1Schema({ name: "absentstate" }),
				new asn1ts.Extension()
			]
		});
	}

	public absentstate!: ENetUC_Common_AsnContact.AsnAbsentStateV2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Argument for asnResetUserAbsentState
 * The argument for asnResetUserAbsentState conatins the ContactID for the contact to reset its absent state to 'none'.
 *
 * @added 22.08.2024
 */
export class AsnResetUserAbsentStateArgument {
	public constructor(that: AsnResetUserAbsentStateArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnResetUserAbsentStateArgument {
		return new AsnResetUserAbsentStateArgument({
			u8sContactId: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sContactId"
		];
		return p;
	}

	public static type = "AsnResetUserAbsentStateArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnResetUserAbsentStateArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sContactId" }),
				new asn1ts.Extension()
			]
		});
	}

	public u8sContactId!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Result of asnResetUserAbsentState that indicates, that the oepration was successful.
 *
 * @added 22.08.2024
 */
export class AsnResetUserAbsentStateResult {
	public constructor(that?: AsnResetUserAbsentStateResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnResetUserAbsentStateResult {
		return new AsnResetUserAbsentStateResult();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnResetUserAbsentStateResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnResetUserAbsentStateResult",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnUpdateMyAbsentStateV2Argument {
	public constructor(that: AsnUpdateMyAbsentStateV2Argument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnUpdateMyAbsentStateV2Argument {
		return new AsnUpdateMyAbsentStateV2Argument({
			absentstate: ENetUC_Common_AsnContact.AsnAbsentStateV2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"absentstate"
		];
		return p;
	}

	public static type = "AsnUpdateMyAbsentStateV2Argument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnUpdateMyAbsentStateV2Argument",
			...params,
			value: [
				ENetUC_Common_AsnContact.AsnAbsentStateV2.getASN1Schema({ name: "absentstate" }),
				new asn1ts.Extension()
			]
		});
	}

	public absentstate!: ENetUC_Common_AsnContact.AsnAbsentStateV2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnCustomNoteSetArgument {
	public constructor(that: AsnCustomNoteSetArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnCustomNoteSetArgument {
		return new AsnCustomNoteSetArgument({
			customnote: ENetUC_Common_AsnContact.AsnCustomNote["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"customnote"
		];
		return p;
	}

	public static type = "AsnCustomNoteSetArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnCustomNoteSetArgument",
			...params,
			value: [
				ENetUC_Common_AsnContact.AsnCustomNote.getASN1Schema({ name: "customnote" }),
				new asn1ts.Extension()
			]
		});
	}

	public customnote!: ENetUC_Common_AsnContact.AsnCustomNote;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnCustomNoteSetResult {
	public constructor(that?: AsnCustomNoteSetResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnCustomNoteSetResult {
		return new AsnCustomNoteSetResult();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals)
			p.push("optionalParams");
		return p;
	}

	public static type = "AsnCustomNoteSetResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnCustomNoteSetResult",
			...params,
			value: [
				ENetUC_Common.AsnOptionalParameters.getASN1Schema({ name: "optionalParams", optional: true }),
				new asn1ts.Extension()
			]
		});
	}

	/** optionalParams Name \"RemoteInvokeID\" Value String */
	public optionalParams?: ENetUC_Common.AsnOptionalParameters;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnUpdateMyCustomNoteArgument {
	public constructor(that: AsnUpdateMyCustomNoteArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnUpdateMyCustomNoteArgument {
		return new AsnUpdateMyCustomNoteArgument({
			customnote: ENetUC_Common_AsnContact.AsnCustomNote["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"customnote"
		];
		return p;
	}

	public static type = "AsnUpdateMyCustomNoteArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnUpdateMyCustomNoteArgument",
			...params,
			value: [
				ENetUC_Common_AsnContact.AsnCustomNote.getASN1Schema({ name: "customnote" }),
				new asn1ts.Extension()
			]
		});
	}

	public customnote!: ENetUC_Common_AsnContact.AsnCustomNote;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnSetMetaSettingsResult {
	public constructor(that?: AsnSetMetaSettingsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSetMetaSettingsResult {
		return new AsnSetMetaSettingsResult();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnSetMetaSettingsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSetMetaSettingsResult",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Temporay helper object for the asnSubscribeServices
 */
export class AsnSubscribeServicesArgument {
	public constructor(that?: AsnSubscribeServicesArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSubscribeServicesArgument {
		return new AsnSubscribeServicesArgument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnSubscribeServicesArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSubscribeServicesArgument",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Temporay helper object for the asnSubscribeServices
 */
export class AsnSubscribeServicesResult {
	public constructor(that?: AsnSubscribeServicesResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSubscribeServicesResult {
		return new AsnSubscribeServicesResult();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		return p;
	}

	public static type = "AsnSubscribeServicesResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSubscribeServicesResult",
			...params,
			value: [
				new asn1ts.Extension()
			]
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnNumberFormatRegExpressList2 extends Array<AsnNumberFormatRegExpression2> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: AsnNumberFormatRegExpression2.getASN1Schema()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Encapsulates AsnNumberFormatRegExpressList2 together with a readonly flag.
 */
export class AsnNumberFormatRegExpressions2 {
	public constructor(that: AsnNumberFormatRegExpressions2) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnNumberFormatRegExpressions2 {
		return new AsnNumberFormatRegExpressions2({
			bIsReadOnlyFromFile: false,
			formatRules: new AsnNumberFormatRegExpressList2()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"bIsReadOnlyFromFile",
			"formatRules"
		];
		return p;
	}

	public static type = "AsnNumberFormatRegExpressions2";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnNumberFormatRegExpressions2",
			...params,
			value: [
				new asn1ts.Boolean({ name: "bIsReadOnlyFromFile" }),
				AsnNumberFormatRegExpressList2.getASN1Schema({ name: "formatRules" }),
				new asn1ts.Extension()
			]
		});
	}

	public bIsReadOnlyFromFile!: boolean;
	public formatRules!: AsnNumberFormatRegExpressList2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Description of formatting and dialing rules for phone numbers.
 * Each PBX is connected to a phone network which defines the rules to apply if number should be dialed or how
 * phone numbers are routed and transmitted.
 *
 * The AsnLocationInformation contains information how to handle
 * phone numbers to allow comfort functions for the user like formatting phone numbers to display them in a readable manner
 * or to enable the user to enter numbers in a short format etc.
 *
 * Replaces AsnLocationInformation.
 */
export class AsnLocationInformation2 {
	public constructor(that: AsnLocationInformation2) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLocationInformation2 {
		return new AsnLocationInformation2({
			u8sLocationID: "",
			u8sLocationCheckSum: "",
			bUseVanity: false,
			bShowExtendedSettings: false,
			bUseTkSystem: false,
			bUseAdvancedLCR: false,
			bFixedNumberLenExtensionDTMFDialing: false,
			bMultiLocationSupport: false,
			bAutoCreateOtherLocationRules: false,
			bAllowNumberSearchOtherLocations: false,
			bShortenOtherLocationSCNumbersForDialing: false,
			iCountryID: 0,
			iLanguage: 0,
			u8sCountryCode: "",
			u8sLocalPrefix: "",
			u8sNationalPrefix: "",
			u8sInternationalPrefix: "",
			u8sLocalDialingRule: "",
			u8sNationalDialingRule: "",
			u8sInternationalDialingRule: "",
			u8sCityCodeNoPrefix: "",
			u8sVanityNumbers: "",
			u8sTKLocalAccessCode: "",
			u8sTKLongDistanceAccessCode: "",
			u8sTKInternationalAccessCode: "",
			u8sTKPrivateAccessCode: "",
			u8sTKForwardingAccessCode: "",
			u8sTKAnschlussNr: "",
			iTKMinLenInternalNumbers: 0,
			iTKMaxLenInternalNumbers: 0,
			numberFormatInternal: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatExternal: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatAutomaticOtherLocationsDDItoSC: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatAutomaticOtherLocationsSCtoDDI: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatRegExpressListIn: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatRegExpressListOut: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatRegExpressListDial: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			numberFormatRegExpressListFinalDial: AsnNumberFormatRegExpressions2["initEmpty"].call(0),
			projectPINRules: new ENetUC_Common_SIPCTI.AsnProjectPinRuleList(),
			u8sDDIRangeBegin: "",
			u8sDDIRangeEnd: "",
			iDialingNumberFormat: 0,
			bNoLocalDialing: false
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sLocationID",
			"u8sLocationCheckSum",
			"bUseVanity",
			"bShowExtendedSettings",
			"bUseTkSystem",
			"bUseAdvancedLCR",
			"bFixedNumberLenExtensionDTMFDialing",
			"bMultiLocationSupport",
			"bAutoCreateOtherLocationRules",
			"bAllowNumberSearchOtherLocations",
			"bShortenOtherLocationSCNumbersForDialing",
			"iCountryID",
			"iLanguage",
			"u8sCountryCode",
			"u8sLocalPrefix",
			"u8sNationalPrefix",
			"u8sInternationalPrefix",
			"u8sLocalDialingRule",
			"u8sNationalDialingRule",
			"u8sInternationalDialingRule",
			"u8sCityCodeNoPrefix",
			"u8sVanityNumbers",
			"u8sTKLocalAccessCode",
			"u8sTKLongDistanceAccessCode",
			"u8sTKInternationalAccessCode",
			"u8sTKPrivateAccessCode",
			"u8sTKForwardingAccessCode",
			"u8sTKAnschlussNr",
			"iTKMinLenInternalNumbers",
			"iTKMaxLenInternalNumbers",
			"numberFormatInternal",
			"numberFormatExternal",
			"numberFormatAutomaticOtherLocationsDDItoSC",
			"numberFormatAutomaticOtherLocationsSCtoDDI",
			"numberFormatRegExpressListIn",
			"numberFormatRegExpressListOut",
			"numberFormatRegExpressListDial",
			"numberFormatRegExpressListFinalDial",
			"projectPINRules",
			"u8sDDIRangeBegin",
			"u8sDDIRangeEnd",
			"iDialingNumberFormat",
			"bNoLocalDialing"
		];
		return p;
	}

	public static type = "AsnLocationInformation2";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLocationInformation2",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sLocationID" }),
				new asn1ts.Utf8String({ name: "u8sLocationCheckSum" }),
				new asn1ts.Boolean({ name: "bUseVanity" }),
				new asn1ts.Boolean({ name: "bShowExtendedSettings" }),
				new asn1ts.Boolean({ name: "bUseTkSystem" }),
				new asn1ts.Boolean({ name: "bUseAdvancedLCR" }),
				new asn1ts.Boolean({ name: "bFixedNumberLenExtensionDTMFDialing" }),
				new asn1ts.Boolean({ name: "bMultiLocationSupport" }),
				new asn1ts.Boolean({ name: "bAutoCreateOtherLocationRules" }),
				new asn1ts.Boolean({ name: "bAllowNumberSearchOtherLocations" }),
				new asn1ts.Boolean({ name: "bShortenOtherLocationSCNumbersForDialing" }),
				new asn1ts.Integer({ name: "iCountryID" }),
				new asn1ts.Integer({ name: "iLanguage" }),
				new asn1ts.Utf8String({ name: "u8sCountryCode" }),
				new asn1ts.Utf8String({ name: "u8sLocalPrefix" }),
				new asn1ts.Utf8String({ name: "u8sNationalPrefix" }),
				new asn1ts.Utf8String({ name: "u8sInternationalPrefix" }),
				new asn1ts.Utf8String({ name: "u8sLocalDialingRule" }),
				new asn1ts.Utf8String({ name: "u8sNationalDialingRule" }),
				new asn1ts.Utf8String({ name: "u8sInternationalDialingRule" }),
				new asn1ts.Utf8String({ name: "u8sCityCodeNoPrefix" }),
				new asn1ts.Utf8String({ name: "u8sVanityNumbers" }),
				new asn1ts.Utf8String({ name: "u8sTKLocalAccessCode" }),
				new asn1ts.Utf8String({ name: "u8sTKLongDistanceAccessCode" }),
				new asn1ts.Utf8String({ name: "u8sTKInternationalAccessCode" }),
				new asn1ts.Utf8String({ name: "u8sTKPrivateAccessCode" }),
				new asn1ts.Utf8String({ name: "u8sTKForwardingAccessCode" }),
				new asn1ts.Utf8String({ name: "u8sTKAnschlussNr" }),
				new asn1ts.Integer({ name: "iTKMinLenInternalNumbers" }),
				new asn1ts.Integer({ name: "iTKMaxLenInternalNumbers" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatInternal" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatExternal" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatAutomaticOtherLocationsDDItoSC" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatAutomaticOtherLocationsSCtoDDI" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatRegExpressListIn" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatRegExpressListOut" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatRegExpressListDial" }),
				AsnNumberFormatRegExpressions2.getASN1Schema({ name: "numberFormatRegExpressListFinalDial" }),
				ENetUC_Common_SIPCTI.AsnProjectPinRuleList.getASN1Schema({ name: "projectPINRules" }),
				new asn1ts.Utf8String({ name: "u8sDDIRangeBegin" }),
				new asn1ts.Utf8String({ name: "u8sDDIRangeEnd" }),
				new asn1ts.Integer({ name: "iDialingNumberFormat" }),
				new asn1ts.Boolean({ name: "bNoLocalDialing" }),
				new asn1ts.Extension()
			]
		});
	}

	public u8sLocationID!: string;
	/** Checksum to detec changes in the AsnLocationInformation2. */
	public u8sLocationCheckSum!: string;
	public bUseVanity!: boolean;
	public bShowExtendedSettings!: boolean;
	public bUseTkSystem!: boolean;
	public bUseAdvancedLCR!: boolean;
	public bFixedNumberLenExtensionDTMFDialing!: boolean;
	public bMultiLocationSupport!: boolean;
	public bAutoCreateOtherLocationRules!: boolean;
	public bAllowNumberSearchOtherLocations!: boolean;
	public bShortenOtherLocationSCNumbersForDialing!: boolean;
	public iCountryID!: number;
	public iLanguage!: number;
	public u8sCountryCode!: string;
	public u8sLocalPrefix!: string;
	public u8sNationalPrefix!: string;
	public u8sInternationalPrefix!: string;
	public u8sLocalDialingRule!: string;
	public u8sNationalDialingRule!: string;
	public u8sInternationalDialingRule!: string;
	public u8sCityCodeNoPrefix!: string;
	public u8sVanityNumbers!: string;
	public u8sTKLocalAccessCode!: string;
	public u8sTKLongDistanceAccessCode!: string;
	public u8sTKInternationalAccessCode!: string;
	public u8sTKPrivateAccessCode!: string;
	public u8sTKForwardingAccessCode!: string;
	public u8sTKAnschlussNr!: string;
	public iTKMinLenInternalNumbers!: number;
	public iTKMaxLenInternalNumbers!: number;
	public numberFormatInternal!: AsnNumberFormatRegExpressions2;
	public numberFormatExternal!: AsnNumberFormatRegExpressions2;
	public numberFormatAutomaticOtherLocationsDDItoSC!: AsnNumberFormatRegExpressions2;
	public numberFormatAutomaticOtherLocationsSCtoDDI!: AsnNumberFormatRegExpressions2;
	public numberFormatRegExpressListIn!: AsnNumberFormatRegExpressions2;
	public numberFormatRegExpressListOut!: AsnNumberFormatRegExpressions2;
	public numberFormatRegExpressListDial!: AsnNumberFormatRegExpressions2;
	public numberFormatRegExpressListFinalDial!: AsnNumberFormatRegExpressions2;
	public projectPINRules!: ENetUC_Common_SIPCTI.AsnProjectPinRuleList;
	public u8sDDIRangeBegin!: string;
	public u8sDDIRangeEnd!: string;
	/** Dialing Number Format. See AsnETAPIDialNumberFormat for details. */
	/** (see AsnETAPIDialNumberFormat) */
	public iDialingNumberFormat!: number;
	public bNoLocalDialing!: boolean;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Result of asnGetLocationInformation2.
 */
export class AsnGetLocationInformation2Result {
	public constructor(that: AsnGetLocationInformation2Result) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetLocationInformation2Result {
		return new AsnGetLocationInformation2Result({
			asnLocationData: AsnLocationInformation2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"asnLocationData"
		];
		return p;
	}

	public static type = "AsnGetLocationInformation2Result";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetLocationInformation2Result",
			...params,
			value: [
				AsnLocationInformation2.getASN1Schema({ name: "asnLocationData" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Location information (v2) about the phone number rules on the line. */
	public asnLocationData!: AsnLocationInformation2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnSetLocationInformation2Argument {
	public constructor(that: AsnSetLocationInformation2Argument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSetLocationInformation2Argument {
		return new AsnSetLocationInformation2Argument({
			asnLocationData: AsnLocationInformation2["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"asnLocationData"
		];
		return p;
	}

	public static type = "AsnSetLocationInformation2Argument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSetLocationInformation2Argument",
			...params,
			value: [
				AsnLocationInformation2.getASN1Schema({ name: "asnLocationData" }),
				new asn1ts.Extension()
			]
		});
	}

	public asnLocationData!: AsnLocationInformation2;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * @added 21.08.2024
 */
export class AsnGetUserAbsentStateArgument {
	public constructor(that: AsnGetUserAbsentStateArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetUserAbsentStateArgument {
		return new AsnGetUserAbsentStateArgument({
			contactId: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"contactId"
		];
		return p;
	}

	public static type = "AsnGetUserAbsentStateArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetUserAbsentStateArgument",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "contactId" }),
				new asn1ts.Extension()
			]
		});
	}

	public contactId!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnGetMetaSettingsArgument {
	public constructor(that: AsnGetMetaSettingsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetMetaSettingsArgument {
		return new AsnGetMetaSettingsArgument({
			eSendPlainPassword: AsnMetaDirectoryPasswordEncryption.iEncrypted
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"eSendPlainPassword"
		];
		return p;
	}

	public static type = "AsnGetMetaSettingsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetMetaSettingsArgument",
			...params,
			value: [
				new asn1ts.Enumerated({ name: "eSendPlainPassword" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Soll das Passwort für das MetaDirectory verschlüsselt übermittelt werden 1: ja, 0(default): nein */
	public eSendPlainPassword!: AsnMetaDirectoryPasswordEncryption;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnMetaDirectorySettings {
	public constructor(that: AsnMetaDirectorySettings) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnMetaDirectorySettings {
		return new AsnMetaDirectorySettings({
			iMetaEnabled: 0,
			iMetaPort: 0,
			u8sMetaServer: "",
			u8sBaseDN: "",
			iMetaForceSSL: 0,
			iMetaUseAccount: 0,
			u8sMetaUser: "",
			ePasswordEncryption: AsnMetaDirectoryPasswordEncryption.iEncrypted,
			u8sMetaPassword: "",
			iMetaUseInServer: 0,
			iMetaUseInClient: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iMetaEnabled",
			"iMetaPort",
			"u8sMetaServer",
			"u8sBaseDN",
			"iMetaForceSSL",
			"iMetaUseAccount",
			"u8sMetaUser",
			"ePasswordEncryption",
			"u8sMetaPassword",
			"iMetaUseInServer",
			"iMetaUseInClient"
		];
		return p;
	}

	public static type = "AsnMetaDirectorySettings";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnMetaDirectorySettings",
			...params,
			value: [
				new asn1ts.Integer({ name: "iMetaEnabled" }),
				new asn1ts.Integer({ name: "iMetaPort" }),
				new asn1ts.Utf8String({ name: "u8sMetaServer" }),
				new asn1ts.Utf8String({ name: "u8sBaseDN" }),
				new asn1ts.Integer({ name: "iMetaForceSSL" }),
				new asn1ts.Integer({ name: "iMetaUseAccount" }),
				new asn1ts.Utf8String({ name: "u8sMetaUser" }),
				new asn1ts.Enumerated({ name: "ePasswordEncryption" }),
				new asn1ts.Utf8String({ name: "u8sMetaPassword" }),
				new asn1ts.Integer({ name: "iMetaUseInServer" }),
				new asn1ts.Integer({ name: "iMetaUseInClient" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Meta interface enabled? */
	public iMetaEnabled!: number;
	/** TCP Port */
	public iMetaPort!: number;
	/** Servername */
	public u8sMetaServer!: string;
	/** BaseDN */
	public u8sBaseDN!: string;
	/** Soll eine LDAPS-Verbindung aufgebaut werden */
	public iMetaForceSSL!: number;
	/** Soll User und Passwort für die Metaverbindung verwendet werden */
	public iMetaUseAccount!: number;
	/** Username am MetaDirectory */
	public u8sMetaUser!: string;
	/** Passwort ist verschlüsselt (0) oder Plaintext (1) */
	public ePasswordEncryption!: AsnMetaDirectoryPasswordEncryption;
	/** Passwort des Users am MetaDirectory */
	public u8sMetaPassword!: string;
	/** Use the meta with the CTI Server */
	public iMetaUseInServer!: number;
	/** Use the meta with the ProCall Client */
	public iMetaUseInClient!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnSetMetaSettingsArgument {
	public constructor(that: AsnSetMetaSettingsArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnSetMetaSettingsArgument {
		return new AsnSetMetaSettingsArgument({
			eSendPlainPassword: AsnMetaDirectoryPasswordEncryption.iEncrypted,
			metasettings: AsnMetaDirectorySettings["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"eSendPlainPassword",
			"metasettings"
		];
		return p;
	}

	public static type = "AsnSetMetaSettingsArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnSetMetaSettingsArgument",
			...params,
			value: [
				new asn1ts.Enumerated({ name: "eSendPlainPassword" }),
				AsnMetaDirectorySettings.getASN1Schema({ name: "metasettings" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Soll das Passwort für das MetaDirectory verschlüsselt übermittelt werden 1: ja, 0(default): nein */
	public eSendPlainPassword!: AsnMetaDirectoryPasswordEncryption;
	public metasettings!: AsnMetaDirectorySettings;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnGetMetaSettingsResult {
	public constructor(that: AsnGetMetaSettingsResult) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnGetMetaSettingsResult {
		return new AsnGetMetaSettingsResult({
			metasettings: AsnMetaDirectorySettings["initEmpty"].call(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"metasettings"
		];
		return p;
	}

	public static type = "AsnGetMetaSettingsResult";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnGetMetaSettingsResult",
			...params,
			value: [
				AsnMetaDirectorySettings.getASN1Schema({ name: "metasettings" }),
				new asn1ts.Extension()
			]
		});
	}

	public metasettings!: AsnMetaDirectorySettings;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnContactIDs extends Array<AsnContactID> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: new asn1ts.Utf8String()
		});
	}
}
