// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Mgmt_Converter.ts
 * "UC-Server-Access-Protocol-Management" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Mgmt from "./ENetUC_Mgmt";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_AsnContact from "./ENetUC_Common_AsnContact";
import * as ENetUC_ClientCapabilities from "./ENetUC_ClientCapabilities";
import * as ENetUC_BinaryTransfer from "./ENetUC_BinaryTransfer";
import * as ENetUC_Admin from "./ENetUC_Admin";
import * as ENetUC_CTI from "./ENetUC_CTI";
import * as ENetUC_Common_Auth from "./ENetUC_Common_Auth";
import * as ENetUC_Transport from "./ENetUC_Transport";
import * as ENetROSEInterface from "./ENetROSEInterface";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
import * as ENetUC_Common_AsnContact_Converter from "./ENetUC_Common_AsnContact_Converter";
import * as ENetUC_ClientCapabilities_Converter from "./ENetUC_ClientCapabilities_Converter";
import * as ENetUC_BinaryTransfer_Converter from "./ENetUC_BinaryTransfer_Converter";
import * as ENetUC_Admin_Converter from "./ENetUC_Admin_Converter";
import * as ENetUC_CTI_Converter from "./ENetUC_CTI_Converter";
import * as ENetUC_Common_Auth_Converter from "./ENetUC_Common_Auth_Converter";
import * as ENetUC_Transport_Converter from "./ENetUC_Transport_Converter";
import * as ENetROSEInterface_Converter from "./ENetROSEInterface_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Mgmt_Converter";
export const MODULE_LASTCHANGE = "2024-07-15T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240715;
export const MODULE_VERSION = "8.0.20240715";

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEmpty_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEmpty, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEmpty & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEmpty");

		const t = {} as ENetUC_Mgmt.AsnMgmtEmpty & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEmpty";

		if (errors.validateResult(newContext, "AsnMgmtEmpty"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEmpty | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEmpty");

		let t: ENetUC_Mgmt.AsnMgmtEmpty | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEmpty>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEmpty["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtEmpty"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEmpty | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEmpty";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEmpty");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtEmpty"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEmpty | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEmpty");

		let t: ENetUC_Mgmt.AsnMgmtEmpty | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEmpty.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEmpty["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtEmpty"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserProfilesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserProfilesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserProfilesArgument";
		TSConverter.fillJSONParam(s, t, "iActiveUsersOnly", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iFilterOnlineState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCrossRefId", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserProfilesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iActiveUsersOnly", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iFilterOnlineState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCrossRefId", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserProfilesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserProfilesArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iActiveUsersOnly", "number", errors, newContext);
		TSConverter.validateParam(s, "iFilterOnlineState", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCrossRefId", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iActiveUsersOnly, name: "iActiveUsersOnly" }));
			t.push(new asn1ts.Integer({ value: s.iFilterOnlineState, name: "iFilterOnlineState" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCrossRefId, name: "u8sCrossRefId" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserProfilesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserProfilesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iActiveUsersOnly", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iFilterOnlineState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCrossRefId", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserProfilesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserProfilesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserProfilesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserProfilesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserProfilesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserProfilesResult";
		const _userProfiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.toJSON(s.userProfiles, errors, newContext, "userProfiles");
		if (_userProfiles)
			t.userProfiles = _userProfiles;

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserProfilesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserProfilesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserProfilesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserProfilesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserProfilesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _userprofiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.fromJSON(s.userProfiles, errors, newContext, "userProfiles", false);
			if (_userprofiles)
				t.userProfiles = _userprofiles;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserProfilesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserProfilesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserProfilesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _userProfiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.toBER(s.userProfiles, errors, newContext, "userProfiles");
		if (!errors.hasNewErrors()) {
			if (_userProfiles)
				t.push(_userProfiles);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserProfilesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserProfilesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserProfilesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserProfilesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserProfilesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _userprofiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "userProfiles"), errors, newContext, "userProfiles");
			if (_userprofiles)
				t.userProfiles = _userprofiles;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserProfilesResultArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserProfilesResultArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserProfilesResultArgument";
		const _listUserProfiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.toJSON(s.listUserProfiles, errors, newContext, "listUserProfiles");
		if (_listUserProfiles)
			t.listUserProfiles = _listUserProfiles;
		TSConverter.fillJSONParam(s, t, "u8sCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bLastSegment", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResultArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserProfilesResultArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listuserprofiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.fromJSON(s.listUserProfiles, errors, newContext, "listUserProfiles", false);
			if (_listuserprofiles)
				t.listUserProfiles = _listuserprofiles;
			TSConverter.fillJSONParam(s, t, "u8sCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bLastSegment", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResultArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserProfilesResultArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserProfilesResultArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listUserProfiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.toBER(s.listUserProfiles, errors, newContext, "listUserProfiles");
		TSConverter.validateParam(s, "u8sCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "bLastSegment", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_listUserProfiles)
				t.push(_listUserProfiles);
			t.push(new asn1ts.Utf8String({ value: s.u8sCrossRefID, name: "u8sCrossRefID" }));
			t.push(new asn1ts.Boolean({ value: s.bLastSegment, name: "bLastSegment" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResultArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserProfilesResultArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserProfilesResultArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listuserprofiles = ENetUC_Admin_Converter.AsnUserProfileList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listUserProfiles"), errors, newContext, "listUserProfiles");
			if (_listuserprofiles)
				t.listUserProfiles = _listuserprofiles;
			TSConverter.fillASN1Param(s, t, "u8sCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bLastSegment", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserProfilesResultArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUsersArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUsersArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUsersArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUsersArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUsersArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUsersArgument";
		TSConverter.fillJSONParam(s, t, "bResultAsList", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtGetUsersArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUsersArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUsersArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUsersArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUsersArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUsersArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bResultAsList", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUsersArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUsersArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUsersArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bResultAsList", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (s.bResultAsList !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bResultAsList, name: "bResultAsList", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUsersArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUsersArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUsersArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUsersArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUsersArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bResultAsList", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUsersResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUsersResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUsersResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUsersResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUsersResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUsersResult";
		TSConverter.fillJSONParam(s, t, "iNumberOfUsers", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUsersResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUsersResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUsersResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUsersResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUsersResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUsersResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNumberOfUsers", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUsersResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUsersResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUsersResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNumberOfUsers", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNumberOfUsers, name: "iNumberOfUsers" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUsersResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUsersResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUsersResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUsersResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUsersResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNumberOfUsers", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnClientConnectionDescription_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnClientConnectionDescription, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnClientConnectionDescription & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnClientConnectionDescription");

		const t = {} as ENetUC_Mgmt.AsnClientConnectionDescription & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnClientConnectionDescription";
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAnonymousUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sHintData", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConnectionGUID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDeviceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDeviceID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iClientAppID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsIdle", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnClientConnectionDescription"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnClientConnectionDescription | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnClientConnectionDescription");

		let t: ENetUC_Mgmt.AsnClientConnectionDescription | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnClientConnectionDescription>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnClientConnectionDescription["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAnonymousUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sHintData", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConnectionGUID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDeviceName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDeviceID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iClientAppID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsIdle", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnClientConnectionDescription"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnClientConnectionDescription | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnClientConnectionDescription";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnClientConnectionDescription");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAnonymousUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sHintData", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConnectionGUID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDeviceName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDeviceID", "string", errors, newContext);
		TSConverter.validateParam(s, "iClientAppID", "number", errors, newContext);
		TSConverter.validateParam(s, "bIsIdle", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAnonymousUserName, name: "u8sAnonymousUserName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sHintData, name: "u8sHintData" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConnectionGUID, name: "u8sConnectionGUID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDeviceName, name: "u8sDeviceName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDeviceID, name: "u8sDeviceID" }));
			t.push(new asn1ts.Integer({ value: s.iClientAppID, name: "iClientAppID" }));
			t.push(new asn1ts.Boolean({ value: s.bIsIdle, name: "bIsIdle" }));
		}

		if (errors.validateResult(newContext, "AsnClientConnectionDescription"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnClientConnectionDescription | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnClientConnectionDescription");

		let t: ENetUC_Mgmt.AsnClientConnectionDescription | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnClientConnectionDescription.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnClientConnectionDescription["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAnonymousUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sHintData", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConnectionGUID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDeviceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDeviceID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iClientAppID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsIdle", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnClientConnectionDescription"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUMModeResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUMModeResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUMModeResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMModeResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUMModeResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUMModeResult";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUMModeResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMModeResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMModeResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUMModeResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUMModeResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUMModeResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMModeResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUMModeResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUMModeResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMModeResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMModeResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMModeResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMModeResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUMModeResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUMModeResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUMModeResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMModeResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetUMModeArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetUMModeArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetUMModeArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUMModeArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetUMModeArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetUMModeArgument";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetUMModeArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUMModeArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUMModeArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUMModeArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetUMModeArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetUMModeArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMModeArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetUMModeArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetUMModeArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUMModeArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMModeArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUMModeArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUMModeArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUMModeArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetUMModeArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetUMModeArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMModeArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTestUMInterfaceArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTestUMInterfaceArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTestUMInterfaceArgument";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtTestUMInterfaceArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTestUMInterfaceArgument");

		let t: ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtTestUMInterfaceArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTestUMInterfaceArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTestUMInterfaceArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtTestUMInterfaceArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTestUMInterfaceArgument");

		let t: ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTestUMInterfaceArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtTestUMInterfaceArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserProfileGetLargeImageArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileGetLargeImageArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserProfileGetLargeImageArgument";
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sImgHash", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileGetLargeImageArgument");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sImgHash", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserProfileGetLargeImageArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileGetLargeImageArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sImgHash", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sImgHash, name: "u8sImgHash" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileGetLargeImageArgument");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sImgHash", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserProfileGetLargeImageResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileGetLargeImageResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserProfileGetLargeImageResult";
		TSConverter.fillJSONParam(s, t, "binImageData", "Uint8Array", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sImgHash", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileGetLargeImageResult");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "binImageData", "string", errors, newContext, false))
				t.binImageData = TSConverter.decode64(s.binImageData as unknown as string);
			TSConverter.fillJSONParam(s, t, "u8sImgHash", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserProfileGetLargeImageResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileGetLargeImageResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "binImageData", "Uint8Array", errors, newContext);
		TSConverter.validateParam(s, "u8sImgHash", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.binImageData, name: "binImageData" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sImgHash, name: "u8sImgHash" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileGetLargeImageResult");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserProfileGetLargeImageResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "binImageData", "OctetString", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sImgHash", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileGetLargeImageResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetGroupsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetGroupsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetGroupsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetGroupsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetGroupsResult";
		TSConverter.fillJSONParam(s, t, "iNumberOfGroups", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetGroupsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNumberOfGroups", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetGroupsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetGroupsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNumberOfGroups", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNumberOfGroups, name: "iNumberOfGroups" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetGroupsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNumberOfGroups", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRemoveGroupArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRemoveGroupArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRemoveGroupArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveGroupArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRemoveGroupArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRemoveGroupArgument";
		TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveGroupArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveGroupArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveGroupArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRemoveGroupArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRemoveGroupArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRemoveGroupArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRemoveGroupArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveGroupArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sGroupName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupName, name: "u8sGroupName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveGroupArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveGroupArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveGroupArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRemoveGroupArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRemoveGroupArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sGroupName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetGroupsEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupsEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetGroupsEventArgument";
		const _groupProfile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.toJSON(s.groupProfile, errors, newContext, "groupProfile");
		if (_groupProfile)
			t.groupProfile = _groupProfile;

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupsEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _groupprofile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.fromJSON(s.groupProfile, errors, newContext, "groupProfile", false);
			if (_groupprofile)
				t.groupProfile = _groupprofile;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetGroupsEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupsEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _groupProfile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.toBER(s.groupProfile, errors, newContext, "groupProfile");
		if (!errors.hasNewErrors()) {
			if (_groupProfile)
				t.push(_groupProfile);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupsEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupsEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _groupprofile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "groupProfile"), errors, newContext, "groupProfile");
			if (_groupprofile)
				t.groupProfile = _groupprofile;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupsEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAgentPublicPresenceItem_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAgentPublicPresenceItem");

		const t = {} as ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAgentPublicPresenceItem";
		TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPublicAgentPresence", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItem"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAgentPublicPresenceItem");

		let t: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAgentURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPublicAgentPresence", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItem"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAgentPublicPresenceItem";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAgentPublicPresenceItem");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAgentURI", "string", errors, newContext);
		TSConverter.validateParam(s, "iPublicAgentPresence", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAgentURI, name: "u8sAgentURI" }));
			t.push(new asn1ts.Integer({ value: s.iPublicAgentPresence, name: "iPublicAgentPresence" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItem"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAgentPublicPresenceItem");

		let t: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItem["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAgentURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPublicAgentPresence", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItem"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetGroupAgentPublicPresenceArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetGroupAgentPublicPresenceArgument";
		TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetGroupAgentPublicPresenceArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sGroupName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupName, name: "u8sGroupName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sGroupName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetComputersResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetComputersResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetComputersResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetComputersResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetComputersResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetComputersResult";
		TSConverter.fillJSONParam(s, t, "iNumberOfComputers", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetComputersResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetComputersResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetComputersResult");

		let t: ENetUC_Mgmt.AsnMgmtGetComputersResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetComputersResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetComputersResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNumberOfComputers", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetComputersResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetComputersResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetComputersResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetComputersResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNumberOfComputers", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNumberOfComputers, name: "iNumberOfComputers" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetComputersResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetComputersResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetComputersResult");

		let t: ENetUC_Mgmt.AsnMgmtGetComputersResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetComputersResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetComputersResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNumberOfComputers", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetComputersResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRefreshComputerStatusArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRefreshComputerStatusArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRefreshComputerStatusArgument";
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (_u8slistComputers)
			t.u8slistComputers = _u8slistComputers;

		if (errors.validateResult(newContext, "AsnMgmtRefreshComputerStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRefreshComputerStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistComputers, errors, newContext, "u8slistComputers", false);
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtRefreshComputerStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRefreshComputerStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRefreshComputerStatusArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (!errors.hasNewErrors()) {
			if (_u8slistComputers)
				t.push(_u8slistComputers);
		}

		if (errors.validateResult(newContext, "AsnMgmtRefreshComputerStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRefreshComputerStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRefreshComputerStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistComputers"), errors, newContext, "u8slistComputers");
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtRefreshComputerStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClearComputerStatusArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClearComputerStatusArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClearComputerStatusArgument";
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (_u8slistComputers)
			t.u8slistComputers = _u8slistComputers;

		if (errors.validateResult(newContext, "AsnMgmtClearComputerStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClearComputerStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistComputers, errors, newContext, "u8slistComputers", false);
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtClearComputerStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClearComputerStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClearComputerStatusArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (!errors.hasNewErrors()) {
			if (_u8slistComputers)
				t.push(_u8slistComputers);
		}

		if (errors.validateResult(newContext, "AsnMgmtClearComputerStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClearComputerStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClearComputerStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistComputers"), errors, newContext, "u8slistComputers");
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtClearComputerStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRemoveComputerArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRemoveComputerArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRemoveComputerArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveComputerArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRemoveComputerArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRemoveComputerArgument";
		TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveComputerArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveComputerArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveComputerArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRemoveComputerArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRemoveComputerArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRemoveComputerArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRemoveComputerArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveComputerArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sComputerName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerName, name: "u8sComputerName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveComputerArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveComputerArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveComputerArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRemoveComputerArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRemoveComputerArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sComputerName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSMSManagerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSMSManagerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSMSManagerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSMSManagerSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtSMSManagerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSMSManagerSettings";
		TSConverter.fillJSONParam(s, t, "bIsActivated", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConfiguredProvider", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLoginName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLoginPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServerSenderAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSenderAddressType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConfiguredService", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSMSManagerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSMSManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSMSManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtSMSManagerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSMSManagerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSMSManagerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bIsActivated", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConfiguredProvider", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLoginName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLoginPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServerSenderAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSenderAddressType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConfiguredService", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSMSManagerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSMSManagerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSMSManagerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSMSManagerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bIsActivated", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sConfiguredProvider", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLoginName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLoginPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sServerSenderAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iSenderAddressType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sConfiguredService", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bIsActivated, name: "bIsActivated" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConfiguredProvider, name: "u8sConfiguredProvider" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLoginName, name: "u8sLoginName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLoginPassword, name: "u8sLoginPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServerSenderAddress, name: "u8sServerSenderAddress" }));
			t.push(new asn1ts.Integer({ value: s.iSenderAddressType, name: "iSenderAddressType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConfiguredService, name: "u8sConfiguredService" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSMSManagerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSMSManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSMSManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtSMSManagerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSMSManagerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSMSManagerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bIsActivated", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConfiguredProvider", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLoginName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLoginPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServerSenderAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSenderAddressType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConfiguredService", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSMSManagerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtWebSMSProviderList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtWebSMSProviderList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtWebSMSProviderList & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtWebSMSProviderList");

		const t = {} as ENetUC_Mgmt.AsnMgmtWebSMSProviderList & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtWebSMSProviderList";
		TSConverter.fillJSONParam(s, t, "u8sProviderListAsXML", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtWebSMSProviderList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtWebSMSProviderList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtWebSMSProviderList");

		let t: ENetUC_Mgmt.AsnMgmtWebSMSProviderList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtWebSMSProviderList>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtWebSMSProviderList["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sProviderListAsXML", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtWebSMSProviderList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtWebSMSProviderList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtWebSMSProviderList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtWebSMSProviderList");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sProviderListAsXML", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sProviderListAsXML, name: "u8sProviderListAsXML" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtWebSMSProviderList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtWebSMSProviderList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtWebSMSProviderList");

		let t: ENetUC_Mgmt.AsnMgmtWebSMSProviderList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtWebSMSProviderList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtWebSMSProviderList["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sProviderListAsXML", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtWebSMSProviderList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSendSMSArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSendSMSArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSendSMSArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendSMSArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSendSMSArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSendSMSArgument";
		TSConverter.fillJSONParam(s, t, "u8sFrom", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTo", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBody", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSendSMSArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendSMSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendSMSArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendSMSArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSendSMSArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSendSMSArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sFrom", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTo", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBody", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendSMSArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSendSMSArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSendSMSArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendSMSArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sFrom", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTo", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sBody", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sFrom, name: "u8sFrom" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTo, name: "u8sTo" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBody, name: "u8sBody" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSendSMSArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendSMSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendSMSArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendSMSArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSendSMSArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSendSMSArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sFrom", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTo", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBody", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendSMSArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSendSMSResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSendSMSResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSendSMSResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendSMSResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSendSMSResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSendSMSResult";
		TSConverter.fillJSONParam(s, t, "u8sResultInfo", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bResultWasError", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSendSMSResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendSMSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendSMSResult");

		let t: ENetUC_Mgmt.AsnMgmtSendSMSResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSendSMSResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSendSMSResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sResultInfo", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bResultWasError", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendSMSResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSendSMSResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSendSMSResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendSMSResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sResultInfo", "string", errors, newContext);
		TSConverter.validateParam(s, "bResultWasError", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sResultInfo, name: "u8sResultInfo" }));
			t.push(new asn1ts.Boolean({ value: s.bResultWasError, name: "bResultWasError" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSendSMSResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendSMSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendSMSResult");

		let t: ENetUC_Mgmt.AsnMgmtSendSMSResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSendSMSResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSendSMSResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sResultInfo", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bResultWasError", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendSMSResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGoogleClientID_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGoogleClientID, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGoogleClientID & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGoogleClientID");

		const t = {} as ENetUC_Mgmt.AsnMgmtGoogleClientID & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGoogleClientID";
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientSecret", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGoogleClientID"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGoogleClientID | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGoogleClientID");

		let t: ENetUC_Mgmt.AsnMgmtGoogleClientID | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGoogleClientID>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGoogleClientID["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientSecret", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGoogleClientID"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGoogleClientID | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGoogleClientID";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGoogleClientID");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sClientID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sClientSecret", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientID, name: "u8sClientID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientSecret, name: "u8sClientSecret" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGoogleClientID"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGoogleClientID | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGoogleClientID");

		let t: ENetUC_Mgmt.AsnMgmtGoogleClientID | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGoogleClientID.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGoogleClientID["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientSecret", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGoogleClientID"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetClientInstallProfileComputerNamesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetClientInstallProfileComputerNamesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetClientInstallProfileComputerNamesResult";
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (_u8slistComputers)
			t.u8slistComputers = _u8slistComputers;

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileComputerNamesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetClientInstallProfileComputerNamesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistComputers, errors, newContext, "u8slistComputers", false);
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileComputerNamesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetClientInstallProfileComputerNamesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetClientInstallProfileComputerNamesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (!errors.hasNewErrors()) {
			if (_u8slistComputers)
				t.push(_u8slistComputers);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileComputerNamesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetClientInstallProfileComputerNamesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetClientInstallProfileComputerNamesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistComputers"), errors, newContext, "u8slistComputers");
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileComputerNamesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSendBroadcastArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSendBroadcastArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSendBroadcastArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendBroadcastArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSendBroadcastArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSendBroadcastArgument";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (_u8slistComputers)
			t.u8slistComputers = _u8slistComputers;

		if (errors.validateResult(newContext, "AsnMgmtSendBroadcastArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendBroadcastArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendBroadcastArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendBroadcastArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSendBroadcastArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSendBroadcastArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistComputers, errors, newContext, "u8slistComputers", false);
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtSendBroadcastArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSendBroadcastArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSendBroadcastArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendBroadcastArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
			if (_u8slistComputers)
				t.push(_u8slistComputers);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendBroadcastArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendBroadcastArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendBroadcastArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendBroadcastArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSendBroadcastArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSendBroadcastArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistComputers"), errors, newContext, "u8slistComputers");
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtSendBroadcastArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientInstallProfileAction_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientInstallProfileAction, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientInstallProfileAction & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfileAction");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientInstallProfileAction & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientInstallProfileAction";
		TSConverter.fillJSONParam(s, t, "u8sPacketIdentifier", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAction", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iClientTspInstallOption", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileAction"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfileAction | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfileAction");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfileAction | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientInstallProfileAction>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientInstallProfileAction["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sPacketIdentifier", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAction", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iClientTspInstallOption", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileAction"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientInstallProfileAction | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientInstallProfileAction";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfileAction");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sPacketIdentifier", "string", errors, newContext);
		TSConverter.validateParam(s, "iAction", "number", errors, newContext);
		TSConverter.validateParam(s, "iClientTspInstallOption", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sPacketIdentifier, name: "u8sPacketIdentifier" }));
			t.push(new asn1ts.Integer({ value: s.iAction, name: "iAction" }));
			t.push(new asn1ts.Integer({ value: s.iClientTspInstallOption, name: "iClientTspInstallOption" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileAction"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfileAction | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfileAction");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfileAction | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientInstallProfileAction.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientInstallProfileAction["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sPacketIdentifier", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAction", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iClientTspInstallOption", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileAction"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtACUFileForUpdateDescription_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtACUFileForUpdateDescription");

		const t = {} as ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtACUFileForUpdateDescription";
		TSConverter.fillJSONParam(s, t, "iFileID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIdentifier", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDescription", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProduct", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sFileName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iExecuteType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sExecuteCommand", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMSIUpgradeCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sValidationCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iFileLanguage", "number", errors, newContext);
		const _iLCIDsEmbedded = ENetUC_Common_Converter.SEQInteger_Converter.toJSON(s.iLCIDsEmbedded, errors, newContext, "iLCIDsEmbedded");
		if (_iLCIDsEmbedded)
			t.iLCIDsEmbedded = _iLCIDsEmbedded;
		TSConverter.fillJSONParam(s, t, "u8sPlatform", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sKeyInstalled", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sKeyVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sRegPathLanguage", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAllowUpdate", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAllowInstall", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sFilePath", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescription"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtACUFileForUpdateDescription");

		let t: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iFileID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIdentifier", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDescription", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProduct", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sFileName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iExecuteType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sExecuteCommand", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMSIUpgradeCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sValidationCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iFileLanguage", "number", errors, newContext, false);
			const _ilcidsembedded = ENetUC_Common_Converter.SEQInteger_Converter.fromJSON(s.iLCIDsEmbedded, errors, newContext, "iLCIDsEmbedded", false);
			if (_ilcidsembedded)
				t.iLCIDsEmbedded = _ilcidsembedded;
			TSConverter.fillJSONParam(s, t, "u8sPlatform", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sKeyInstalled", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sKeyVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sRegPathLanguage", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAllowUpdate", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAllowInstall", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sFilePath", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescription"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtACUFileForUpdateDescription";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtACUFileForUpdateDescription");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iFileID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sIdentifier", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDescription", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProduct", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sFileName", "string", errors, newContext);
		TSConverter.validateParam(s, "iExecuteType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sExecuteCommand", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMSIUpgradeCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sValidationCode", "string", errors, newContext);
		TSConverter.validateParam(s, "iFileLanguage", "number", errors, newContext);
		const _iLCIDsEmbedded = ENetUC_Common_Converter.SEQInteger_Converter.toBER(s.iLCIDsEmbedded, errors, newContext, "iLCIDsEmbedded");
		TSConverter.validateParam(s, "u8sPlatform", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sKeyInstalled", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sKeyVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sRegPathLanguage", "string", errors, newContext);
		TSConverter.validateParam(s, "iAllowUpdate", "number", errors, newContext);
		TSConverter.validateParam(s, "iAllowInstall", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sFilePath", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iFileID, name: "iFileID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIdentifier, name: "u8sIdentifier" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDescription, name: "u8sDescription" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProduct, name: "u8sProduct" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sFileName, name: "u8sFileName" }));
			t.push(new asn1ts.Integer({ value: s.iExecuteType, name: "iExecuteType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sExecuteCommand, name: "u8sExecuteCommand" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sVersion, name: "u8sVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMSIUpgradeCode, name: "u8sMSIUpgradeCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sValidationCode, name: "u8sValidationCode" }));
			t.push(new asn1ts.Integer({ value: s.iFileLanguage, name: "iFileLanguage" }));
			if (_iLCIDsEmbedded)
				t.push(_iLCIDsEmbedded);
			t.push(new asn1ts.Utf8String({ value: s.u8sPlatform, name: "u8sPlatform" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sKeyInstalled, name: "u8sKeyInstalled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sKeyVersion, name: "u8sKeyVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sRegPathLanguage, name: "u8sRegPathLanguage" }));
			t.push(new asn1ts.Integer({ value: s.iAllowUpdate, name: "iAllowUpdate" }));
			t.push(new asn1ts.Integer({ value: s.iAllowInstall, name: "iAllowInstall" }));
			if (s.u8sFilePath !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sFilePath, name: "u8sFilePath", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescription"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtACUFileForUpdateDescription");

		let t: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescription["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iFileID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIdentifier", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDescription", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProduct", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sFileName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iExecuteType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sExecuteCommand", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMSIUpgradeCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sValidationCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iFileLanguage", "Integer", errors, newContext);
			const _ilcidsembedded = ENetUC_Common_Converter.SEQInteger_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "iLCIDsEmbedded"), errors, newContext, "iLCIDsEmbedded");
			if (_ilcidsembedded)
				t.iLCIDsEmbedded = _ilcidsembedded;
			TSConverter.fillASN1Param(s, t, "u8sPlatform", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sKeyInstalled", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sKeyVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sRegPathLanguage", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAllowUpdate", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAllowInstall", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sFilePath", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescription"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetClientInstallProfileArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetClientInstallProfileArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetClientInstallProfileArgument";
		TSConverter.fillJSONParam(s, t, "u8sComputer", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetClientInstallProfileArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sComputer", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetClientInstallProfileArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetClientInstallProfileArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sComputer", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sComputer, name: "u8sComputer" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetClientInstallProfileArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetClientInstallProfileArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sComputer", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUpdateServiceSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUpdateServiceSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUpdateServiceSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpdateServiceSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtUpdateServiceSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUpdateServiceSettings";
		TSConverter.fillJSONParam(s, t, "iStatusUpdateService", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEACUServiceActive", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEACUServiceTimeLimited", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAllowVersionDowngrade", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAVBehaviour", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxWaitTimeForIdleMinutes", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "dtTimeFrom", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "dtTimeTo", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sRemoteLocation", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtUpdateServiceSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpdateServiceSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpdateServiceSettings");

		let t: ENetUC_Mgmt.AsnMgmtUpdateServiceSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUpdateServiceSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUpdateServiceSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iStatusUpdateService", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEACUServiceActive", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEACUServiceTimeLimited", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAllowVersionDowngrade", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAVBehaviour", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxWaitTimeForIdleMinutes", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "dtTimeFrom", "string", errors, newContext, false))
				t.dtTimeFrom = new Date(s.dtTimeFrom);
			if (TSConverter.validateParam(s, "dtTimeTo", "string", errors, newContext, false))
				t.dtTimeTo = new Date(s.dtTimeTo);
			TSConverter.fillJSONParam(s, t, "u8sRemoteLocation", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpdateServiceSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUpdateServiceSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUpdateServiceSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpdateServiceSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iStatusUpdateService", "number", errors, newContext);
		TSConverter.validateParam(s, "iEACUServiceActive", "number", errors, newContext);
		TSConverter.validateParam(s, "iEACUServiceTimeLimited", "number", errors, newContext);
		TSConverter.validateParam(s, "iAllowVersionDowngrade", "number", errors, newContext);
		TSConverter.validateParam(s, "iAVBehaviour", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxWaitTimeForIdleMinutes", "number", errors, newContext);
		TSConverter.validateParam(s, "dtTimeFrom", "Date", errors, newContext);
		TSConverter.validateParam(s, "dtTimeTo", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sRemoteLocation", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iStatusUpdateService, name: "iStatusUpdateService" }));
			t.push(new asn1ts.Integer({ value: s.iEACUServiceActive, name: "iEACUServiceActive" }));
			t.push(new asn1ts.Integer({ value: s.iEACUServiceTimeLimited, name: "iEACUServiceTimeLimited" }));
			t.push(new asn1ts.Integer({ value: s.iAllowVersionDowngrade, name: "iAllowVersionDowngrade" }));
			t.push(new asn1ts.Integer({ value: s.iAVBehaviour, name: "iAVBehaviour" }));
			t.push(new asn1ts.Integer({ value: s.iMaxWaitTimeForIdleMinutes, name: "iMaxWaitTimeForIdleMinutes" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.dtTimeFrom), name: "dtTimeFrom" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.dtTimeTo), name: "dtTimeTo" }));
			if (s.u8sRemoteLocation !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sRemoteLocation, name: "u8sRemoteLocation", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUpdateServiceSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpdateServiceSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpdateServiceSettings");

		let t: ENetUC_Mgmt.AsnMgmtUpdateServiceSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUpdateServiceSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUpdateServiceSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iStatusUpdateService", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEACUServiceActive", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEACUServiceTimeLimited", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAllowVersionDowngrade", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAVBehaviour", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxWaitTimeForIdleMinutes", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "dtTimeFrom", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "dtTimeTo", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sRemoteLocation", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpdateServiceSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientInstallProfilePacket_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfilePacket");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientInstallProfilePacket";
		TSConverter.fillJSONParam(s, t, "u8sPacketIdentifier", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sVersion", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacket"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfilePacket");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sPacketIdentifier", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sVersion", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacket"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientInstallProfilePacket";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfilePacket");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sPacketIdentifier", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sVersion", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sPacketIdentifier, name: "u8sPacketIdentifier" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sVersion, name: "u8sVersion" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacket"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfilePacket");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientInstallProfilePacket["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sPacketIdentifier", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sVersion", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacket"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConResetLineArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConResetLineArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConResetLineArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConResetLineArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtConResetLineArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConResetLineArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtConResetLineArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConResetLineArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConResetLineArgument");

		let t: ENetUC_Mgmt.AsnMgmtConResetLineArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConResetLineArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConResetLineArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtConResetLineArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConResetLineArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConResetLineArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConResetLineArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtConResetLineArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConResetLineArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConResetLineArgument");

		let t: ENetUC_Mgmt.AsnMgmtConResetLineArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConResetLineArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConResetLineArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtConResetLineArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineSourcesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineSourcesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineSourcesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineSourcesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineSourcesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineSourcesResult";
		const _u8slistSources = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistSources, errors, newContext, "u8slistSources");
		if (_u8slistSources)
			t.u8slistSources = _u8slistSources;

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourcesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineSourcesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineSourcesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineSourcesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineSourcesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineSourcesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistsources = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistSources, errors, newContext, "u8slistSources", false);
			if (_u8slistsources)
				t.u8slistSources = _u8slistsources;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourcesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineSourcesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineSourcesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineSourcesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistSources = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistSources, errors, newContext, "u8slistSources");
		if (!errors.hasNewErrors()) {
			if (_u8slistSources)
				t.push(_u8slistSources);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourcesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineSourcesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineSourcesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineSourcesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineSourcesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineSourcesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistsources = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistSources"), errors, newContext, "u8slistSources");
			if (_u8slistsources)
				t.u8slistSources = _u8slistsources;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourcesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLineStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLineStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLineStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineStatus");

		const t = {} as ENetUC_Mgmt.AsnMgmtLineStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLineStatus";
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "eOpenState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNumCalls", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSipResponseCode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sReasonPhrase", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAffectedServer", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtLineStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineStatus");

		let t: ENetUC_Mgmt.AsnMgmtLineStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLineStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLineStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "eOpenState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNumCalls", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSipResponseCode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sReasonPhrase", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAffectedServer", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLineStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLineStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		TSConverter.validateParam(s, "eOpenState", "number", errors, newContext);
		TSConverter.validateParam(s, "iNumCalls", "number", errors, newContext);
		TSConverter.validateParam(s, "iSipResponseCode", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sReasonPhrase", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAffectedServer", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
			t.push(new asn1ts.Enumerated({ value: s.eOpenState, name: "eOpenState" }));
			t.push(new asn1ts.Integer({ value: s.iNumCalls, name: "iNumCalls" }));
			t.push(new asn1ts.Integer({ value: s.iSipResponseCode, name: "iSipResponseCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sReasonPhrase, name: "u8sReasonPhrase" }));
			if (s.u8sAffectedServer !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sAffectedServer, name: "u8sAffectedServer", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineStatus");

		let t: ENetUC_Mgmt.AsnMgmtLineStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLineStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLineStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "eOpenState", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNumCalls", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSipResponseCode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sReasonPhrase", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAffectedServer", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineSourceDeviceIDsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineSourceDeviceIDsArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineSourceDeviceIDsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSource", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSource, name: "u8sLineSource" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSource", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineSourceDeviceIDsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineSourceDeviceIDsResult";
		const _iListDeviceIDs = ENetUC_Common_Converter.SEQInteger_Converter.toJSON(s.iListDeviceIDs, errors, newContext, "iListDeviceIDs");
		if (_iListDeviceIDs)
			t.iListDeviceIDs = _iListDeviceIDs;

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _ilistdeviceids = ENetUC_Common_Converter.SEQInteger_Converter.fromJSON(s.iListDeviceIDs, errors, newContext, "iListDeviceIDs", false);
			if (_ilistdeviceids)
				t.iListDeviceIDs = _ilistdeviceids;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineSourceDeviceIDsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _iListDeviceIDs = ENetUC_Common_Converter.SEQInteger_Converter.toBER(s.iListDeviceIDs, errors, newContext, "iListDeviceIDs");
		if (!errors.hasNewErrors()) {
			if (_iListDeviceIDs)
				t.push(_iListDeviceIDs);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineSourceDeviceIDsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineSourceDeviceIDsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _ilistdeviceids = ENetUC_Common_Converter.SEQInteger_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "iListDeviceIDs"), errors, newContext, "iListDeviceIDs");
			if (_ilistdeviceids)
				t.iListDeviceIDs = _ilistdeviceids;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineSourceDeviceIDsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLinesForSourceArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLinesForSourceArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLinesForSourceArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLinesForSourceArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLinesForSourceArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLinesForSourceArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLinesForSourceArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLinesForSourceArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSource", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSource, name: "u8sLineSource" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLinesForSourceArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLinesForSourceArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLinesForSourceArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSource", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLinesForSourceArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineStatesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineStatesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineStatesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineStatesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineStatesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineStatesArgument";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineStatesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineStatesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineStatesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineStatesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineStatesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineStatesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineStatesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineStatesArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineStatesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineStatesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineStatesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineStatesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineStatesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTapiLineConfiguration_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTapiLineConfiguration, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTapiLineConfiguration & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiLineConfiguration");

		const t = {} as ENetUC_Mgmt.AsnMgmtTapiLineConfiguration & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTapiLineConfiguration";
		TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iJournal", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDummyWirelessPhone", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseAutomaticPhoneNumber", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sManualPhoneNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseTapiLineName", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPrivatePhone", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTrunk", "number", errors, newContext);
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.customProps, errors, newContext, "customProps");
		if (_customProps)
			t.customProps = _customProps;
		TSConverter.fillJSONParam(s, t, "iSignalCallsOnAddress", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sHomeServer", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfiguration"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiLineConfiguration | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiLineConfiguration");

		let t: ENetUC_Mgmt.AsnMgmtTapiLineConfiguration | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTapiLineConfiguration>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTapiLineConfiguration["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iJournal", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDummyWirelessPhone", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseAutomaticPhoneNumber", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sManualPhoneNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseTapiLineName", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPrivatePhone", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTrunk", "number", errors, newContext, false);
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.customProps, errors, newContext, "customProps", false);
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillJSONParam(s, t, "iSignalCallsOnAddress", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sHomeServer", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfiguration"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTapiLineConfiguration | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTapiLineConfiguration";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiLineConfiguration");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iJournal", "number", errors, newContext);
		TSConverter.validateParam(s, "iDummyWirelessPhone", "number", errors, newContext);
		TSConverter.validateParam(s, "iUseAutomaticPhoneNumber", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sManualPhoneNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "iUseTapiLineName", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iPrivatePhone", "number", errors, newContext);
		TSConverter.validateParam(s, "iTrunk", "number", errors, newContext);
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.customProps, errors, newContext, "customProps");
		TSConverter.validateParam(s, "iSignalCallsOnAddress", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sHomeServer", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iEnabled, name: "iEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iJournal, name: "iJournal" }));
			t.push(new asn1ts.Integer({ value: s.iDummyWirelessPhone, name: "iDummyWirelessPhone" }));
			t.push(new asn1ts.Integer({ value: s.iUseAutomaticPhoneNumber, name: "iUseAutomaticPhoneNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sManualPhoneNumber, name: "u8sManualPhoneNumber" }));
			t.push(new asn1ts.Integer({ value: s.iUseTapiLineName, name: "iUseTapiLineName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Integer({ value: s.iPrivatePhone, name: "iPrivatePhone" }));
			t.push(new asn1ts.Integer({ value: s.iTrunk, name: "iTrunk" }));
			if (_customProps)
				t.push(_customProps);
			t.push(new asn1ts.Integer({ value: s.iSignalCallsOnAddress, name: "iSignalCallsOnAddress" }));
			if (s.u8sHomeServer !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sHomeServer, name: "u8sHomeServer", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfiguration"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiLineConfiguration | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiLineConfiguration");

		let t: ENetUC_Mgmt.AsnMgmtTapiLineConfiguration | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTapiLineConfiguration.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTapiLineConfiguration["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iJournal", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDummyWirelessPhone", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseAutomaticPhoneNumber", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sManualPhoneNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseTapiLineName", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPrivatePhone", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTrunk", "Integer", errors, newContext);
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "customProps"), errors, newContext, "customProps");
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillASN1Param(s, t, "iSignalCallsOnAddress", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sHomeServer", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfiguration"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTapiLineConfig4Admin_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiLineConfig4Admin");

		const t = {} as ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTapiLineConfig4Admin";
		TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iJournal", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDummyWirelessPhone", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseAutomaticPhoneNumber", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sManualPhoneNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseTapiLineName", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTapiDeviceID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAutomaticPhoneNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTapiLineName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPBXGroupName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAdminForwardingEnabled", "number", errors, newContext);
		const _adminForwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toJSON(s.adminForwarding, errors, newContext, "adminForwarding");
		if (_adminForwarding)
			t.adminForwarding = _adminForwarding;
		TSConverter.fillJSONParam(s, t, "iUserForwardingEnabled", "number", errors, newContext);
		const _userForwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toJSON(s.userForwarding, errors, newContext, "userForwarding");
		if (_userForwarding)
			t.userForwarding = _userForwarding;
		TSConverter.fillJSONParam(s, t, "iPrivatePhone", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext);
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.customProps, errors, newContext, "customProps");
		if (_customProps)
			t.customProps = _customProps;
		TSConverter.fillJSONParam(s, t, "iAutoActivate", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPhysicalDeviceID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTrunk", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSignalCallsOnAddress", "number", errors, newContext);
		const _u8slistAddressNames = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistAddressNames, errors, newContext, "u8slistAddressNames");
		if (_u8slistAddressNames)
			t.u8slistAddressNames = _u8slistAddressNames;
		TSConverter.fillJSONParam(s, t, "u8sLineConfigIdentifier", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sHomeServer", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfig4Admin"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiLineConfig4Admin");

		let t: ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iJournal", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDummyWirelessPhone", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseAutomaticPhoneNumber", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sManualPhoneNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseTapiLineName", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTapiDeviceID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAutomaticPhoneNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTapiLineName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPBXGroupName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAdminForwardingEnabled", "number", errors, newContext, false);
			const _adminforwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromJSON(s.adminForwarding, errors, newContext, "adminForwarding", false);
			if (_adminforwarding)
				t.adminForwarding = _adminforwarding;
			TSConverter.fillJSONParam(s, t, "iUserForwardingEnabled", "number", errors, newContext, false);
			const _userforwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromJSON(s.userForwarding, errors, newContext, "userForwarding", false);
			if (_userforwarding)
				t.userForwarding = _userforwarding;
			TSConverter.fillJSONParam(s, t, "iPrivatePhone", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext, false);
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.customProps, errors, newContext, "customProps", false);
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillJSONParam(s, t, "iAutoActivate", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPhysicalDeviceID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTrunk", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSignalCallsOnAddress", "number", errors, newContext, false);
			const _u8slistaddressnames = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistAddressNames, errors, newContext, "u8slistAddressNames", false);
			if (_u8slistaddressnames)
				t.u8slistAddressNames = _u8slistaddressnames;
			TSConverter.fillJSONParam(s, t, "u8sLineConfigIdentifier", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sHomeServer", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfig4Admin"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTapiLineConfig4Admin";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiLineConfig4Admin");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iJournal", "number", errors, newContext);
		TSConverter.validateParam(s, "iDummyWirelessPhone", "number", errors, newContext);
		TSConverter.validateParam(s, "iUseAutomaticPhoneNumber", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sManualPhoneNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "iUseTapiLineName", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iTapiDeviceID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAutomaticPhoneNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTapiLineName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPBXGroupName", "string", errors, newContext);
		TSConverter.validateParam(s, "iAdminForwardingEnabled", "number", errors, newContext);
		const _adminForwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toBER(s.adminForwarding, errors, newContext, "adminForwarding");
		TSConverter.validateParam(s, "iUserForwardingEnabled", "number", errors, newContext);
		const _userForwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toBER(s.userForwarding, errors, newContext, "userForwarding");
		TSConverter.validateParam(s, "iPrivatePhone", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLineSourceName", "string", errors, newContext);
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.customProps, errors, newContext, "customProps");
		TSConverter.validateParam(s, "iAutoActivate", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sPhysicalDeviceID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLineURI", "string", errors, newContext);
		TSConverter.validateParam(s, "iTrunk", "number", errors, newContext);
		TSConverter.validateParam(s, "iSignalCallsOnAddress", "number", errors, newContext);
		const _u8slistAddressNames = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistAddressNames, errors, newContext, "u8slistAddressNames");
		TSConverter.validateParam(s, "u8sLineConfigIdentifier", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sHomeServer", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iEnabled, name: "iEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iJournal, name: "iJournal" }));
			t.push(new asn1ts.Integer({ value: s.iDummyWirelessPhone, name: "iDummyWirelessPhone" }));
			t.push(new asn1ts.Integer({ value: s.iUseAutomaticPhoneNumber, name: "iUseAutomaticPhoneNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sManualPhoneNumber, name: "u8sManualPhoneNumber" }));
			t.push(new asn1ts.Integer({ value: s.iUseTapiLineName, name: "iUseTapiLineName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Integer({ value: s.iTapiDeviceID, name: "iTapiDeviceID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAutomaticPhoneNumber, name: "u8sAutomaticPhoneNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTapiLineName, name: "u8sTapiLineName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPBXGroupName, name: "u8sPBXGroupName" }));
			t.push(new asn1ts.Integer({ value: s.iAdminForwardingEnabled, name: "iAdminForwardingEnabled" }));
			if (_adminForwarding)
				t.push(_adminForwarding);
			t.push(new asn1ts.Integer({ value: s.iUserForwardingEnabled, name: "iUserForwardingEnabled" }));
			if (_userForwarding)
				t.push(_userForwarding);
			t.push(new asn1ts.Integer({ value: s.iPrivatePhone, name: "iPrivatePhone" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSourceName, name: "u8sLineSourceName" }));
			if (_customProps)
				t.push(_customProps);
			t.push(new asn1ts.Integer({ value: s.iAutoActivate, name: "iAutoActivate" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPhysicalDeviceID, name: "u8sPhysicalDeviceID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineURI, name: "u8sLineURI" }));
			t.push(new asn1ts.Integer({ value: s.iTrunk, name: "iTrunk" }));
			t.push(new asn1ts.Integer({ value: s.iSignalCallsOnAddress, name: "iSignalCallsOnAddress" }));
			if (_u8slistAddressNames)
				t.push(_u8slistAddressNames);
			t.push(new asn1ts.Utf8String({ value: s.u8sLineConfigIdentifier, name: "u8sLineConfigIdentifier" }));
			if (s.u8sHomeServer !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sHomeServer, name: "u8sHomeServer", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfig4Admin"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiLineConfig4Admin");

		let t: ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTapiLineConfig4Admin["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iJournal", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDummyWirelessPhone", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseAutomaticPhoneNumber", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sManualPhoneNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseTapiLineName", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTapiDeviceID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAutomaticPhoneNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTapiLineName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPBXGroupName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAdminForwardingEnabled", "Integer", errors, newContext);
			const _adminforwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "adminForwarding"), errors, newContext, "adminForwarding");
			if (_adminforwarding)
				t.adminForwarding = _adminforwarding;
			TSConverter.fillASN1Param(s, t, "iUserForwardingEnabled", "Integer", errors, newContext);
			const _userforwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "userForwarding"), errors, newContext, "userForwarding");
			if (_userforwarding)
				t.userForwarding = _userforwarding;
			TSConverter.fillASN1Param(s, t, "iPrivatePhone", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineSourceName", "Utf8String", errors, newContext);
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "customProps"), errors, newContext, "customProps");
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillASN1Param(s, t, "iAutoActivate", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPhysicalDeviceID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTrunk", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSignalCallsOnAddress", "Integer", errors, newContext);
			const _u8slistaddressnames = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistAddressNames"), errors, newContext, "u8slistAddressNames");
			if (_u8slistaddressnames)
				t.u8slistAddressNames = _u8slistaddressnames;
			TSConverter.fillASN1Param(s, t, "u8sLineConfigIdentifier", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sHomeServer", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineConfig4Admin"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineGroupRemovedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineGroupRemovedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineGroupRemovedArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPBXGroupName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupRemovedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineGroupRemovedArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPBXGroupName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupRemovedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineGroupRemovedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineGroupRemovedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSourceName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPBXGroupName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSourceName, name: "u8sLineSourceName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPBXGroupName, name: "u8sPBXGroupName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupRemovedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineGroupRemovedArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineGroupRemovedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSourceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPBXGroupName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupRemovedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineGroupsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineGroupsArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineGroupsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSourceName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSourceName, name: "u8sLineSourceName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSourceName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineGroupsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineGroupsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineGroupsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineGroupsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineGroupsResult";
		const _u8slistLineGroups = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistLineGroups, errors, newContext, "u8slistLineGroups");
		if (_u8slistLineGroups)
			t.u8slistLineGroups = _u8slistLineGroups;

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineGroupsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistlinegroups = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistLineGroups, errors, newContext, "u8slistLineGroups", false);
			if (_u8slistlinegroups)
				t.u8slistLineGroups = _u8slistlinegroups;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineGroupsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineGroupsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistLineGroups = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistLineGroups, errors, newContext, "u8slistLineGroups");
		if (!errors.hasNewErrors()) {
			if (_u8slistLineGroups)
				t.push(_u8slistLineGroups);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineGroupsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistlinegroups = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistLineGroups"), errors, newContext, "u8slistLineGroups");
			if (_u8slistlinegroups)
				t.u8slistLineGroups = _u8slistlinegroups;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSubscribeLineEventsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSubscribeLineEventsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSubscribeLineEventsArgument";
		TSConverter.fillJSONParam(s, t, "u8sTAPILineID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSubscribeLineEventsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSubscribeLineEventsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTAPILineID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeLineEventsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSubscribeLineEventsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSubscribeLineEventsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTAPILineID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTAPILineID, name: "u8sTAPILineID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeLineEventsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSubscribeLineEventsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSubscribeLineEventsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTAPILineID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeLineEventsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineConfigArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineConfigArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineConfigArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineConfigArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineConfigArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineConfigArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeviceID", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineConfigArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineConfigArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineConfigArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeviceID", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineConfigArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineConfigArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineConfigArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSource", "string", errors, newContext);
		TSConverter.validateParam(s, "iDeviceID", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSource, name: "u8sLineSource" }));
			t.push(new asn1ts.Integer({ value: s.iDeviceID, name: "iDeviceID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineConfigArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineConfigArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineConfigArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSource", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeviceID", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDeleteLineArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDeleteLineArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDeleteLineArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeleteLineArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtDeleteLineArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDeleteLineArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDeleteLineArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeleteLineArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeleteLineArgument");

		let t: ENetUC_Mgmt.AsnMgmtDeleteLineArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDeleteLineArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDeleteLineArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDeleteLineArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDeleteLineArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDeleteLineArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeleteLineArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSource", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSource, name: "u8sLineSource" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDeleteLineArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeleteLineArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeleteLineArgument");

		let t: ENetUC_Mgmt.AsnMgmtDeleteLineArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDeleteLineArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDeleteLineArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSource", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDeleteLineArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtETapiUIDllCallbackArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtETapiUIDllCallbackArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtETapiUIDllCallbackArgument";
		TSConverter.fillJSONParam(s, t, "binData", "Uint8Array", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtETapiUIDllCallbackArgument");

		let t: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "binData", "string", errors, newContext, false))
				t.binData = TSConverter.decode64(s.binData as unknown as string);
		}

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtETapiUIDllCallbackArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtETapiUIDllCallbackArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "binData", "Uint8Array", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.binData, name: "binData" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtETapiUIDllCallbackArgument");

		let t: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "binData", "OctetString", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtETapiUIDllCallbackResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtETapiUIDllCallbackResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtETapiUIDllCallbackResult";
		TSConverter.fillJSONParam(s, t, "binData", "Uint8Array", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtETapiUIDllCallbackResult");

		let t: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "binData", "string", errors, newContext, false))
				t.binData = TSConverter.decode64(s.binData as unknown as string);
		}

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtETapiUIDllCallbackResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtETapiUIDllCallbackResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "binData", "Uint8Array", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.binData, name: "binData" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtETapiUIDllCallbackResult");

		let t: ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtETapiUIDllCallbackResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "binData", "OctetString", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtETapiUIDllCallbackResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtCtiFeatureCode_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtCtiFeatureCode, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtCtiFeatureCode & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiFeatureCode");

		const t = {} as ENetUC_Mgmt.AsnMgmtCtiFeatureCode & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtCtiFeatureCode";
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sFeatureName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sFeatureCode", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCode"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiFeatureCode | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiFeatureCode");

		let t: ENetUC_Mgmt.AsnMgmtCtiFeatureCode | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtCtiFeatureCode>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtCtiFeatureCode["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sFeatureName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sFeatureCode", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCode"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtCtiFeatureCode | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtCtiFeatureCode";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiFeatureCode");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sFeatureName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sFeatureCode", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sFeatureName, name: "u8sFeatureName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sFeatureCode, name: "u8sFeatureCode" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCode"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiFeatureCode | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiFeatureCode");

		let t: ENetUC_Mgmt.AsnMgmtCtiFeatureCode | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtCtiFeatureCode.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtCtiFeatureCode["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sFeatureName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sFeatureCode", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCode"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineGroupConfigArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupConfigArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineGroupConfigArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineGroupConfigArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupConfigArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSourceName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sGroupName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSourceName, name: "u8sLineSourceName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupName, name: "u8sGroupName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupConfigArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSourceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGroupName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRequestPBXLineExistsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRequestPBXLineExistsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRequestPBXLineExistsArgument";
		TSConverter.fillJSONParam(s, t, "u8sPhoneNumber", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRequestPBXLineExistsArgument");

		let t: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sPhoneNumber", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRequestPBXLineExistsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRequestPBXLineExistsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sPhoneNumber", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sPhoneNumber, name: "u8sPhoneNumber" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRequestPBXLineExistsArgument");

		let t: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sPhoneNumber", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRequestPBXLineExistsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRequestPBXLineExistsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRequestPBXLineExistsResult";
		TSConverter.fillJSONParam(s, t, "u8sCorrectNumberSC", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRequestPBXLineExistsResult");

		let t: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sCorrectNumberSC", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRequestPBXLineExistsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRequestPBXLineExistsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sCorrectNumberSC", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sCorrectNumberSC, name: "u8sCorrectNumberSC" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRequestPBXLineExistsResult");

		let t: ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRequestPBXLineExistsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sCorrectNumberSC", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRequestPBXLineExistsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLineEventForAdmin_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLineEventForAdmin, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLineEventForAdmin & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineEventForAdmin");

		const t = {} as ENetUC_Mgmt.AsnMgmtLineEventForAdmin & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLineEventForAdmin";
		TSConverter.fillJSONParam(s, t, "u8sTAPILineID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCallerIDTAPI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCalledIDTAPI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConnectedIDTAPI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bOutBoundCall", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCallState", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtLineEventForAdmin"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineEventForAdmin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineEventForAdmin");

		let t: ENetUC_Mgmt.AsnMgmtLineEventForAdmin | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLineEventForAdmin>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLineEventForAdmin["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTAPILineID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCallerIDTAPI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCalledIDTAPI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConnectedIDTAPI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bOutBoundCall", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCallState", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineEventForAdmin"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLineEventForAdmin | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLineEventForAdmin";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineEventForAdmin");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTAPILineID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCallerIDTAPI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCalledIDTAPI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConnectedIDTAPI", "string", errors, newContext);
		TSConverter.validateParam(s, "bOutBoundCall", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iCallState", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTAPILineID, name: "u8sTAPILineID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCallerIDTAPI, name: "u8sCallerIDTAPI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCalledIDTAPI, name: "u8sCalledIDTAPI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConnectedIDTAPI, name: "u8sConnectedIDTAPI" }));
			t.push(new asn1ts.Boolean({ value: s.bOutBoundCall, name: "bOutBoundCall" }));
			t.push(new asn1ts.Integer({ value: s.iCallState, name: "iCallState" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtLineEventForAdmin"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineEventForAdmin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineEventForAdmin");

		let t: ENetUC_Mgmt.AsnMgmtLineEventForAdmin | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLineEventForAdmin.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLineEventForAdmin["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTAPILineID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCallerIDTAPI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCalledIDTAPI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConnectedIDTAPI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bOutBoundCall", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCallState", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineEventForAdmin"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserManagerLDAPAttribute_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerLDAPAttribute");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserManagerLDAPAttribute";
		TSConverter.fillJSONParam(s, t, "u8sCtiServerAttributeName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLDAPAttributeName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLDAPAttributeDefaultName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bThisFieldCanQueryaPhoneLine", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bQueryLinesForThisPhoneNumberField", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bQueryLinesForThisPhoneNumberFieldDefault", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bOptionalEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnabledDefault", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttribute"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerLDAPAttribute");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sCtiServerAttributeName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLDAPAttributeName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLDAPAttributeDefaultName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bThisFieldCanQueryaPhoneLine", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bQueryLinesForThisPhoneNumberField", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bQueryLinesForThisPhoneNumberFieldDefault", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bOptionalEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnabledDefault", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttribute"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserManagerLDAPAttribute";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerLDAPAttribute");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sCtiServerAttributeName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLDAPAttributeName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLDAPAttributeDefaultName", "string", errors, newContext);
		TSConverter.validateParam(s, "bThisFieldCanQueryaPhoneLine", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bQueryLinesForThisPhoneNumberField", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bQueryLinesForThisPhoneNumberFieldDefault", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bOptionalEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEnabledDefault", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sCtiServerAttributeName, name: "u8sCtiServerAttributeName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLDAPAttributeName, name: "u8sLDAPAttributeName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLDAPAttributeDefaultName, name: "u8sLDAPAttributeDefaultName" }));
			t.push(new asn1ts.Boolean({ value: s.bThisFieldCanQueryaPhoneLine, name: "bThisFieldCanQueryaPhoneLine" }));
			t.push(new asn1ts.Boolean({ value: s.bQueryLinesForThisPhoneNumberField, name: "bQueryLinesForThisPhoneNumberField" }));
			t.push(new asn1ts.Boolean({ value: s.bQueryLinesForThisPhoneNumberFieldDefault, name: "bQueryLinesForThisPhoneNumberFieldDefault" }));
			t.push(new asn1ts.Boolean({ value: s.bOptionalEnabled, name: "bOptionalEnabled" }));
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			t.push(new asn1ts.Boolean({ value: s.bEnabledDefault, name: "bEnabledDefault" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttribute"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerLDAPAttribute");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttribute["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sCtiServerAttributeName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLDAPAttributeName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLDAPAttributeDefaultName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bThisFieldCanQueryaPhoneLine", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bQueryLinesForThisPhoneNumberField", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bQueryLinesForThisPhoneNumberFieldDefault", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bOptionalEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnabledDefault", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttribute"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUMInterfaceSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUMInterfaceSettingsArgument";
		TSConverter.fillJSONParam(s, t, "iInterfaceType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iInterfaceType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUMInterfaceSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iInterfaceType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iInterfaceType, name: "iInterfaceType" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iInterfaceType", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAddLicenseArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAddLicenseArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAddLicenseArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAddLicenseArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtAddLicenseArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAddLicenseArgument";
		TSConverter.fillJSONParam(s, t, "u8sLicense", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtAddLicenseArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAddLicenseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAddLicenseArgument");

		let t: ENetUC_Mgmt.AsnMgmtAddLicenseArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAddLicenseArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAddLicenseArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLicense", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtAddLicenseArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAddLicenseArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAddLicenseArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAddLicenseArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLicense", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLicense, name: "u8sLicense" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtAddLicenseArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAddLicenseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAddLicenseArgument");

		let t: ENetUC_Mgmt.AsnMgmtAddLicenseArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAddLicenseArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAddLicenseArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLicense", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtAddLicenseArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRemoveLicenseArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveLicenseArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRemoveLicenseArgument";
		TSConverter.fillJSONParam(s, t, "u8sLicense", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRemoveLicenseArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveLicenseArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLicense", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveLicenseArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRemoveLicenseArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveLicenseArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLicense", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLicense, name: "u8sLicense" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveLicenseArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveLicenseArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRemoveLicenseArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLicense", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveLicenseArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtFeatureCount_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtFeatureCount, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtFeatureCount & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFeatureCount");

		const t = {} as ENetUC_Mgmt.AsnMgmtFeatureCount & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtFeatureCount";
		TSConverter.fillJSONParam(s, t, "feature", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCount", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtFeatureCount"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFeatureCount | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFeatureCount");

		let t: ENetUC_Mgmt.AsnMgmtFeatureCount | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtFeatureCount>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtFeatureCount["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "feature", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCount", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtFeatureCount"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtFeatureCount | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtFeatureCount";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFeatureCount");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "feature", "number", errors, newContext);
		TSConverter.validateParam(s, "iCount", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.feature, name: "feature" }));
			t.push(new asn1ts.Integer({ value: s.iCount, name: "iCount" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtFeatureCount"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFeatureCount | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFeatureCount");

		let t: ENetUC_Mgmt.AsnMgmtFeatureCount | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtFeatureCount.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtFeatureCount["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "feature", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCount", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtFeatureCount"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLicenseGenuineStatusArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLicenseGenuineStatusArgument";
		const _genuineInfos = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.genuineInfos, errors, newContext, "genuineInfos");
		if (_genuineInfos)
			t.genuineInfos = _genuineInfos;

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _genuineinfos = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.genuineInfos, errors, newContext, "genuineInfos", false);
			if (_genuineinfos)
				t.genuineInfos = _genuineinfos;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLicenseGenuineStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _genuineInfos = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.genuineInfos, errors, newContext, "genuineInfos");
		if (!errors.hasNewErrors()) {
			if (_genuineInfos)
				t.push(_genuineInfos);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _genuineinfos = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "genuineInfos"), errors, newContext, "genuineInfos");
			if (_genuineinfos)
				t.genuineInfos = _genuineinfos;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLicenseGenuineStatusResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLicenseGenuineStatusResult";
		const _u8slistUpdateLicenseCodes = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistUpdateLicenseCodes, errors, newContext, "u8slistUpdateLicenseCodes");
		if (_u8slistUpdateLicenseCodes)
			t.u8slistUpdateLicenseCodes = _u8slistUpdateLicenseCodes;

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusResult");

		let t: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistupdatelicensecodes = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistUpdateLicenseCodes, errors, newContext, "u8slistUpdateLicenseCodes", false);
			if (_u8slistupdatelicensecodes)
				t.u8slistUpdateLicenseCodes = _u8slistupdatelicensecodes;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLicenseGenuineStatusResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistUpdateLicenseCodes = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistUpdateLicenseCodes, errors, newContext, "u8slistUpdateLicenseCodes");
		if (!errors.hasNewErrors()) {
			if (_u8slistUpdateLicenseCodes)
				t.push(_u8slistUpdateLicenseCodes);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLicenseGenuineStatusResult");

		let t: ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLicenseGenuineStatusResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistupdatelicensecodes = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistUpdateLicenseCodes"), errors, newContext, "u8slistUpdateLicenseCodes");
			if (_u8slistupdatelicensecodes)
				t.u8slistUpdateLicenseCodes = _u8slistupdatelicensecodes;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLicenseGenuineStatusResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLicenseArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLicenseArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLicenseArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLicenseArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLicenseArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLicenseArgument";
		TSConverter.fillJSONParam(s, t, "iCount", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLicenseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLicenseArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLicenseArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLicenseArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLicenseArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iCount", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLicenseArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLicenseArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLicenseArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iCount", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iCount, name: "iCount" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLicenseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLicenseArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLicenseArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLicenseArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLicenseArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iCount", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetHasCurrentVersionLicensesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetHasCurrentVersionLicensesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetHasCurrentVersionLicensesResult";
		TSConverter.fillJSONParam(s, t, "iNumUsers", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetHasCurrentVersionLicensesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetHasCurrentVersionLicensesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNumUsers", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetHasCurrentVersionLicensesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetHasCurrentVersionLicensesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetHasCurrentVersionLicensesResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNumUsers", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNumUsers, name: "iNumUsers" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetHasCurrentVersionLicensesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetHasCurrentVersionLicensesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetHasCurrentVersionLicensesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNumUsers", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetHasCurrentVersionLicensesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetNumLicensesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetNumLicensesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetNumLicensesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetNumLicensesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetNumLicensesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetNumLicensesResult";
		TSConverter.fillJSONParam(s, t, "iNumLicenses", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetNumLicensesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetNumLicensesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetNumLicensesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetNumLicensesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetNumLicensesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetNumLicensesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNumLicenses", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetNumLicensesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetNumLicensesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetNumLicensesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetNumLicensesResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNumLicenses", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNumLicenses, name: "iNumLicenses" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetNumLicensesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetNumLicensesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetNumLicensesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetNumLicensesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetNumLicensesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetNumLicensesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNumLicenses", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetNumLicensesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetRemainingTrialDaysResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetRemainingTrialDaysResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetRemainingTrialDaysResult";
		TSConverter.fillJSONParam(s, t, "iRemainingTestDays", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetRemainingTrialDaysResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetRemainingTrialDaysResult");

		let t: ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iRemainingTestDays", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetRemainingTrialDaysResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetRemainingTrialDaysResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetRemainingTrialDaysResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iRemainingTestDays", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iRemainingTestDays, name: "iRemainingTestDays" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetRemainingTrialDaysResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetRemainingTrialDaysResult");

		let t: ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetRemainingTrialDaysResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iRemainingTestDays", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetRemainingTrialDaysResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetHWIDResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetHWIDResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetHWIDResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetHWIDResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetHWIDResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetHWIDResult";
		TSConverter.fillJSONParam(s, t, "u8sHWID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSystemIdentifier", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetHWIDResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetHWIDResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetHWIDResult");

		let t: ENetUC_Mgmt.AsnMgmtGetHWIDResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetHWIDResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetHWIDResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sHWID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSystemIdentifier", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetHWIDResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetHWIDResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetHWIDResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetHWIDResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sHWID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSystemIdentifier", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sHWID, name: "u8sHWID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSystemIdentifier, name: "u8sSystemIdentifier" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetHWIDResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetHWIDResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetHWIDResult");

		let t: ENetUC_Mgmt.AsnMgmtGetHWIDResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetHWIDResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetHWIDResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sHWID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSystemIdentifier", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetHWIDResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLicensesHaveChangedEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLicensesHaveChangedEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLicensesHaveChangedEventArgument";

		if (errors.validateResult(newContext, "AsnMgmtOnLicensesHaveChangedEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLicensesHaveChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLicensesHaveChangedEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLicensesHaveChangedEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLicensesHaveChangedEventArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtOnLicensesHaveChangedEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLicensesHaveChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLicensesHaveChangedEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLicensesHaveChangedEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWSCapabilities_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWSCapabilities, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWSCapabilities & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWSCapabilities");

		const t = {} as ENetUC_Mgmt.AsnMgmtEUCWSCapabilities & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEUCWSCapabilities";
		TSConverter.fillJSONParam(s, t, "iCapabilities", "number", errors, newContext);
		const _u8slistAliases = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistAliases, errors, newContext, "u8slistAliases");
		if (_u8slistAliases)
			t.u8slistAliases = _u8slistAliases;
		const _u8slistLicenses = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistLicenses, errors, newContext, "u8slistLicenses");
		if (_u8slistLicenses)
			t.u8slistLicenses = _u8slistLicenses;
		const _u8slistCERObject = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistCERObject, errors, newContext, "u8slistCERObject");
		if (_u8slistCERObject)
			t.u8slistCERObject = _u8slistCERObject;
		TSConverter.fillJSONParam(s, t, "u8sVserviceDomain", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sVserviceLastImageVersion", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtEUCWSCapabilities"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWSCapabilities | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWSCapabilities");

		let t: ENetUC_Mgmt.AsnMgmtEUCWSCapabilities | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWSCapabilities>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEUCWSCapabilities["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iCapabilities", "number", errors, newContext, false);
			const _u8slistaliases = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistAliases, errors, newContext, "u8slistAliases", false);
			if (_u8slistaliases)
				t.u8slistAliases = _u8slistaliases;
			const _u8slistlicenses = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistLicenses, errors, newContext, "u8slistLicenses", false);
			if (_u8slistlicenses)
				t.u8slistLicenses = _u8slistlicenses;
			const _u8slistcerobject = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistCERObject, errors, newContext, "u8slistCERObject", false);
			if (_u8slistcerobject)
				t.u8slistCERObject = _u8slistcerobject;
			TSConverter.fillJSONParam(s, t, "u8sVserviceDomain", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sVserviceLastImageVersion", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSCapabilities"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWSCapabilities | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWSCapabilities";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWSCapabilities");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iCapabilities", "number", errors, newContext);
		const _u8slistAliases = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistAliases, errors, newContext, "u8slistAliases");
		const _u8slistLicenses = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistLicenses, errors, newContext, "u8slistLicenses");
		const _u8slistCERObject = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistCERObject, errors, newContext, "u8slistCERObject");
		TSConverter.validateParam(s, "u8sVserviceDomain", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sVserviceLastImageVersion", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iCapabilities, name: "iCapabilities" }));
			if (_u8slistAliases)
				t.push(_u8slistAliases);
			if (_u8slistLicenses)
				t.push(_u8slistLicenses);
			if (_u8slistCERObject)
				t.push(_u8slistCERObject);
			if (s.u8sVserviceDomain !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sVserviceDomain, name: "u8sVserviceDomain", idBlock: { optionalID: 0 } }));
			if (s.u8sVserviceLastImageVersion !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sVserviceLastImageVersion, name: "u8sVserviceLastImageVersion", idBlock: { optionalID: 1 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSCapabilities"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWSCapabilities | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWSCapabilities");

		let t: ENetUC_Mgmt.AsnMgmtEUCWSCapabilities | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWSCapabilities.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEUCWSCapabilities["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iCapabilities", "Integer", errors, newContext);
			const _u8slistaliases = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistAliases"), errors, newContext, "u8slistAliases");
			if (_u8slistaliases)
				t.u8slistAliases = _u8slistaliases;
			const _u8slistlicenses = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistLicenses"), errors, newContext, "u8slistLicenses");
			if (_u8slistlicenses)
				t.u8slistLicenses = _u8slistlicenses;
			const _u8slistcerobject = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistCERObject"), errors, newContext, "u8slistCERObject");
			if (_u8slistcerobject)
				t.u8slistCERObject = _u8slistcerobject;
			TSConverter.fillASN1Param(s, t, "u8sVserviceDomain", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sVserviceLastImageVersion", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSCapabilities"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWebServiceConfig_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServiceConfig");

		const t = {} as ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEUCWebServiceConfig";
		TSConverter.fillJSONParam(s, t, "u8sWCSID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUCSPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServerAddress", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServiceConfig");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sWCSID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUCSPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServerAddress", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWebServiceConfig";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServiceConfig");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sWCSID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUCSID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUCSPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sServerAddress", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sWCSID, name: "u8sWCSID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSID, name: "u8sUCSID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSPassword, name: "u8sUCSPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServerAddress, name: "u8sServerAddress" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServiceConfig");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sWCSID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUCSID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUCSPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServerAddress", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtWebServiceAccessParams_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtWebServiceAccessParams, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtWebServiceAccessParams & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtWebServiceAccessParams");

		const t = {} as ENetUC_Mgmt.AsnMgmtWebServiceAccessParams & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtWebServiceAccessParams";
		TSConverter.fillJSONParam(s, t, "u8sHost", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSSL", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iController", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtWebServiceAccessParams"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtWebServiceAccessParams | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtWebServiceAccessParams");

		let t: ENetUC_Mgmt.AsnMgmtWebServiceAccessParams | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtWebServiceAccessParams>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtWebServiceAccessParams["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sHost", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSSL", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iController", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtWebServiceAccessParams"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtWebServiceAccessParams | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtWebServiceAccessParams";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtWebServiceAccessParams");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sHost", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iSSL", "number", errors, newContext);
		TSConverter.validateParam(s, "iController", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sUCSID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sHost, name: "u8sHost" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Integer({ value: s.iSSL, name: "iSSL" }));
			t.push(new asn1ts.Integer({ value: s.iController, name: "iController" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSID, name: "u8sUCSID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtWebServiceAccessParams"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtWebServiceAccessParams | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtWebServiceAccessParams");

		let t: ENetUC_Mgmt.AsnMgmtWebServiceAccessParams | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtWebServiceAccessParams.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtWebServiceAccessParams["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sHost", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSSL", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iController", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUCSID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtWebServiceAccessParams"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSendMailArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSendMailArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSendMailArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendMailArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSendMailArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSendMailArgument";
		TSConverter.fillJSONParam(s, t, "u8sFrom", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTo", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSubject", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSendMailArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendMailArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendMailArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendMailArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSendMailArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSendMailArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sFrom", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTo", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSubject", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendMailArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSendMailArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSendMailArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendMailArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sFrom", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTo", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSubject", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMessage", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sFrom, name: "u8sFrom" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTo, name: "u8sTo" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSubject, name: "u8sSubject" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMessage, name: "u8sMessage" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSendMailArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendMailArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendMailArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendMailArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSendMailArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSendMailArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sFrom", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTo", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSubject", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMessage", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendMailArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSendInviteMailArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSendInviteMailArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSendInviteMailArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendInviteMailArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSendInviteMailArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSendInviteMailArgument";
		const _u8slistAddresses = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistAddresses, errors, newContext, "u8slistAddresses");
		if (_u8slistAddresses)
			t.u8slistAddresses = _u8slistAddresses;
		TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUserURL", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAppConfigURL", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iWaitForSend", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSendInviteMailArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendInviteMailArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendInviteMailArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendInviteMailArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSendInviteMailArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSendInviteMailArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistaddresses = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistAddresses, errors, newContext, "u8slistAddresses", false);
			if (_u8slistaddresses)
				t.u8slistAddresses = _u8slistaddresses;
			TSConverter.fillJSONParam(s, t, "u8sMessage", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUserURL", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAppConfigURL", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iWaitForSend", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendInviteMailArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSendInviteMailArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSendInviteMailArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendInviteMailArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistAddresses = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistAddresses, errors, newContext, "u8slistAddresses");
		TSConverter.validateParam(s, "u8sMessage", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUserURL", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAppConfigURL", "string", errors, newContext);
		TSConverter.validateParam(s, "iWaitForSend", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_u8slistAddresses)
				t.push(_u8slistAddresses);
			t.push(new asn1ts.Utf8String({ value: s.u8sMessage, name: "u8sMessage" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUserURL, name: "u8sUserURL" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAppConfigURL, name: "u8sAppConfigURL" }));
			t.push(new asn1ts.Integer({ value: s.iWaitForSend, name: "iWaitForSend" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSendInviteMailArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendInviteMailArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendInviteMailArgument");

		let t: ENetUC_Mgmt.AsnMgmtSendInviteMailArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSendInviteMailArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSendInviteMailArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistaddresses = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistAddresses"), errors, newContext, "u8slistAddresses");
			if (_u8slistaddresses)
				t.u8slistAddresses = _u8slistaddresses;
			TSConverter.fillASN1Param(s, t, "u8sMessage", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUserURL", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAppConfigURL", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iWaitForSend", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendInviteMailArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEMailConnectorSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEMailConnectorSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEMailConnectorSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEMailConnectorSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtEMailConnectorSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEMailConnectorSettings";
		TSConverter.fillJSONParam(s, t, "u8sSMTPServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLoginName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLoginPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAdminMailAddr", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMailFromAddr", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMailFromName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSMTPPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAllowUTF8Encoding", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRequireTLS", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtEMailConnectorSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEMailConnectorSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEMailConnectorSettings");

		let t: ENetUC_Mgmt.AsnMgmtEMailConnectorSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEMailConnectorSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEMailConnectorSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sSMTPServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLoginName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLoginPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAdminMailAddr", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMailFromAddr", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMailFromName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSMTPPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAllowUTF8Encoding", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRequireTLS", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtEMailConnectorSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEMailConnectorSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEMailConnectorSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEMailConnectorSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sSMTPServer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLoginName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLoginPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAdminMailAddr", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMailFromAddr", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMailFromName", "string", errors, newContext);
		TSConverter.validateParam(s, "iSMTPPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iAllowUTF8Encoding", "number", errors, newContext);
		TSConverter.validateParam(s, "iRequireTLS", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sSMTPServer, name: "u8sSMTPServer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLoginName, name: "u8sLoginName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLoginPassword, name: "u8sLoginPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAdminMailAddr, name: "u8sAdminMailAddr" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMailFromAddr, name: "u8sMailFromAddr" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMailFromName, name: "u8sMailFromName" }));
			t.push(new asn1ts.Integer({ value: s.iSMTPPort, name: "iSMTPPort" }));
			t.push(new asn1ts.Integer({ value: s.iAllowUTF8Encoding, name: "iAllowUTF8Encoding" }));
			t.push(new asn1ts.Integer({ value: s.iRequireTLS, name: "iRequireTLS" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtEMailConnectorSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEMailConnectorSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEMailConnectorSettings");

		let t: ENetUC_Mgmt.AsnMgmtEMailConnectorSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEMailConnectorSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEMailConnectorSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sSMTPServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLoginName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLoginPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAdminMailAddr", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMailFromAddr", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMailFromName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSMTPPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAllowUTF8Encoding", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRequireTLS", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtEMailConnectorSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTapiProblemSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTapiProblemSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTapiProblemSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiProblemSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtTapiProblemSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTapiProblemSettings";
		TSConverter.fillJSONParam(s, t, "iReinitAutorestart", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLineOpenFailedAction", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLineOpenDelayTime", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtTapiProblemSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiProblemSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiProblemSettings");

		let t: ENetUC_Mgmt.AsnMgmtTapiProblemSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTapiProblemSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTapiProblemSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iReinitAutorestart", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLineOpenFailedAction", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLineOpenDelayTime", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiProblemSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTapiProblemSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTapiProblemSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiProblemSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iReinitAutorestart", "number", errors, newContext);
		TSConverter.validateParam(s, "iLineOpenFailedAction", "number", errors, newContext);
		TSConverter.validateParam(s, "iLineOpenDelayTime", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iReinitAutorestart, name: "iReinitAutorestart" }));
			t.push(new asn1ts.Integer({ value: s.iLineOpenFailedAction, name: "iLineOpenFailedAction" }));
			t.push(new asn1ts.Integer({ value: s.iLineOpenDelayTime, name: "iLineOpenDelayTime" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiProblemSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiProblemSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiProblemSettings");

		let t: ENetUC_Mgmt.AsnMgmtTapiProblemSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTapiProblemSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTapiProblemSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iReinitAutorestart", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLineOpenFailedAction", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLineOpenDelayTime", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiProblemSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDatabaseManagerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDatabaseManagerSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDatabaseManagerSettings";
		TSConverter.fillJSONParam(s, t, "iAuthMode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEngine", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sFilePath", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLoginName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDatabaseName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sOfflineTable", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sJournalTable", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTrackerTable", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConversationTable", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAppointmentTable", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTaskTable", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sODBCConfiguredDriver", "string", errors, newContext);
		if (s.u8sODBCAvailableDrivers) {
			const _u8sODBCAvailableDrivers = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.u8sODBCAvailableDrivers, errors, newContext, "u8sODBCAvailableDrivers");
			if (_u8sODBCAvailableDrivers)
				t.u8sODBCAvailableDrivers = _u8sODBCAvailableDrivers;
		}
		TSConverter.fillJSONParam(s, t, "bJetDBsExist", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtDatabaseManagerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDatabaseManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iAuthMode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEngine", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sFilePath", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLoginName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDatabaseName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sOfflineTable", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sJournalTable", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTrackerTable", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConversationTable", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAppointmentTable", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTaskTable", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sODBCConfiguredDriver", "string", errors, newContext, false);
			const _u8sodbcavailabledrivers = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.u8sODBCAvailableDrivers, errors, newContext, "u8sODBCAvailableDrivers", true);
			if (_u8sodbcavailabledrivers)
				t.u8sODBCAvailableDrivers = _u8sodbcavailabledrivers;
			TSConverter.fillJSONParam(s, t, "bJetDBsExist", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseManagerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDatabaseManagerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDatabaseManagerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iAuthMode", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sEngine", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sServer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sFilePath", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLoginName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDatabaseName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sOfflineTable", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sJournalTable", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTrackerTable", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConversationTable", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAppointmentTable", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTaskTable", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sODBCConfiguredDriver", "string", errors, newContext);
		const _u8sODBCAvailableDrivers = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.u8sODBCAvailableDrivers, errors, newContext, "u8sODBCAvailableDrivers", 0);
		TSConverter.validateParam(s, "bJetDBsExist", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iAuthMode, name: "iAuthMode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEngine, name: "u8sEngine" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServer, name: "u8sServer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sFilePath, name: "u8sFilePath" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLoginName, name: "u8sLoginName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPassword, name: "u8sPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDatabaseName, name: "u8sDatabaseName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sOfflineTable, name: "u8sOfflineTable" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sJournalTable, name: "u8sJournalTable" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTrackerTable, name: "u8sTrackerTable" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConversationTable, name: "u8sConversationTable" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAppointmentTable, name: "u8sAppointmentTable" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTaskTable, name: "u8sTaskTable" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sODBCConfiguredDriver, name: "u8sODBCConfiguredDriver" }));
			if (_u8sODBCAvailableDrivers)
				t.push(_u8sODBCAvailableDrivers);
			if (s.bJetDBsExist !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bJetDBsExist, name: "bJetDBsExist", idBlock: { optionalID: 1 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseManagerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDatabaseManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDatabaseManagerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iAuthMode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEngine", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sFilePath", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLoginName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDatabaseName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sOfflineTable", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sJournalTable", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTrackerTable", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConversationTable", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAppointmentTable", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTaskTable", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sODBCConfiguredDriver", "Utf8String", errors, newContext);
			t.u8sODBCAvailableDrivers = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sODBCAvailableDrivers"), errors, newContext, "u8sODBCAvailableDrivers", true);
			TSConverter.fillASN1Param(s, t, "bJetDBsExist", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseManagerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAvailableDatabasesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableDatabasesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAvailableDatabasesResult";
		const _u8slistDatabaseNames = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistDatabaseNames, errors, newContext, "u8slistDatabaseNames");
		if (_u8slistDatabaseNames)
			t.u8slistDatabaseNames = _u8slistDatabaseNames;

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableDatabasesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistdatabasenames = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistDatabaseNames, errors, newContext, "u8slistDatabaseNames", false);
			if (_u8slistdatabasenames)
				t.u8slistDatabaseNames = _u8slistdatabasenames;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAvailableDatabasesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableDatabasesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistDatabaseNames = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistDatabaseNames, errors, newContext, "u8slistDatabaseNames");
		if (!errors.hasNewErrors()) {
			if (_u8slistDatabaseNames)
				t.push(_u8slistDatabaseNames);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableDatabasesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistdatabasenames = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistDatabaseNames"), errors, newContext, "u8slistDatabaseNames");
			if (_u8slistdatabasenames)
				t.u8slistDatabaseNames = _u8slistdatabasenames;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnListeningInterface_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnListeningInterface, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnListeningInterface & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterface");

		const t = {} as ENetUC_Mgmt.AsnListeningInterface & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnListeningInterface";
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sInterfaceGUID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iInterfaceType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProtocol", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBindAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsDefault", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCertHash", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCertContainerFile", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCertContainerContent", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDNSName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnListeningInterface"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterface | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterface");

		let t: ENetUC_Mgmt.AsnListeningInterface | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnListeningInterface>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnListeningInterface["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sInterfaceGUID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iInterfaceType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProtocol", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBindAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsDefault", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCertHash", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCertContainerFile", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCertContainerContent", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDNSName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnListeningInterface"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnListeningInterface | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnListeningInterface";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterface");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sInterfaceGUID", "string", errors, newContext);
		TSConverter.validateParam(s, "iInterfaceType", "number", errors, newContext);
		TSConverter.validateParam(s, "iProtocol", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sBindAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "bIsDefault", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sCertHash", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCertContainerFile", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCertContainerContent", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDNSName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPublicIP", "string", errors, newContext);
		TSConverter.validateParam(s, "iPublicPort", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sInterfaceGUID, name: "u8sInterfaceGUID" }));
			t.push(new asn1ts.Integer({ value: s.iInterfaceType, name: "iInterfaceType" }));
			t.push(new asn1ts.Integer({ value: s.iProtocol, name: "iProtocol" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBindAddress, name: "u8sBindAddress" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Boolean({ value: s.bIsDefault, name: "bIsDefault" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCertHash, name: "u8sCertHash" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCertContainerFile, name: "u8sCertContainerFile" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCertContainerContent, name: "u8sCertContainerContent" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDNSName, name: "u8sDNSName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPublicIP, name: "u8sPublicIP" }));
			t.push(new asn1ts.Integer({ value: s.iPublicPort, name: "iPublicPort" }));
		}

		if (errors.validateResult(newContext, "AsnListeningInterface"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterface | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterface");

		let t: ENetUC_Mgmt.AsnListeningInterface | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnListeningInterface.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnListeningInterface["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sInterfaceGUID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iInterfaceType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProtocol", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBindAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsDefault", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCertHash", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCertContainerFile", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCertContainerContent", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDNSName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPublicIP", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPublicPort", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnListeningInterface"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnListeningInterfaceStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnListeningInterfaceStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnListeningInterfaceStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterfaceStatus");

		const t = {} as ENetUC_Mgmt.AsnListeningInterfaceStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnListeningInterfaceStatus";
		TSConverter.fillJSONParam(s, t, "u8sInterfaceGUID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext);
		const _iSocketServerIDs = ENetUC_Common_Converter.SEQInteger_Converter.toJSON(s.iSocketServerIDs, errors, newContext, "iSocketServerIDs");
		if (_iSocketServerIDs)
			t.iSocketServerIDs = _iSocketServerIDs;
		TSConverter.fillJSONParam(s, t, "iOpenConnections", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterfaceStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterfaceStatus");

		let t: ENetUC_Mgmt.AsnListeningInterfaceStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnListeningInterfaceStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnListeningInterfaceStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sInterfaceGUID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext, false);
			const _isocketserverids = ENetUC_Common_Converter.SEQInteger_Converter.fromJSON(s.iSocketServerIDs, errors, newContext, "iSocketServerIDs", false);
			if (_isocketserverids)
				t.iSocketServerIDs = _isocketserverids;
			TSConverter.fillJSONParam(s, t, "iOpenConnections", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnListeningInterfaceStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnListeningInterfaceStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterfaceStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sInterfaceGUID", "string", errors, newContext);
		TSConverter.validateParam(s, "iStatus", "number", errors, newContext);
		const _iSocketServerIDs = ENetUC_Common_Converter.SEQInteger_Converter.toBER(s.iSocketServerIDs, errors, newContext, "iSocketServerIDs");
		TSConverter.validateParam(s, "iOpenConnections", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sInterfaceGUID, name: "u8sInterfaceGUID" }));
			t.push(new asn1ts.Integer({ value: s.iStatus, name: "iStatus" }));
			if (_iSocketServerIDs)
				t.push(_iSocketServerIDs);
			t.push(new asn1ts.Integer({ value: s.iOpenConnections, name: "iOpenConnections" }));
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterfaceStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterfaceStatus");

		let t: ENetUC_Mgmt.AsnListeningInterfaceStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnListeningInterfaceStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnListeningInterfaceStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sInterfaceGUID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStatus", "Integer", errors, newContext);
			const _isocketserverids = ENetUC_Common_Converter.SEQInteger_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "iSocketServerIDs"), errors, newContext, "iSocketServerIDs");
			if (_isocketserverids)
				t.iSocketServerIDs = _isocketserverids;
			TSConverter.fillASN1Param(s, t, "iOpenConnections", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMediaServerLogFile_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMediaServerLogFile, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMediaServerLogFile & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMediaServerLogFile");

		const t = {} as ENetUC_Mgmt.AsnMediaServerLogFile & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMediaServerLogFile";
		TSConverter.fillJSONParam(s, t, "u8sLogLevel", "string", errors, newContext);
		const _u8slistLogLevel = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistLogLevel, errors, newContext, "u8slistLogLevel");
		if (_u8slistLogLevel)
			t.u8slistLogLevel = _u8slistLogLevel;
		TSConverter.fillJSONParam(s, t, "iRestartImmediately", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMediaServerLogFile"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMediaServerLogFile | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMediaServerLogFile");

		let t: ENetUC_Mgmt.AsnMediaServerLogFile | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMediaServerLogFile>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMediaServerLogFile["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLogLevel", "string", errors, newContext, false);
			const _u8slistloglevel = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistLogLevel, errors, newContext, "u8slistLogLevel", false);
			if (_u8slistloglevel)
				t.u8slistLogLevel = _u8slistloglevel;
			TSConverter.fillJSONParam(s, t, "iRestartImmediately", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMediaServerLogFile"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMediaServerLogFile | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMediaServerLogFile";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMediaServerLogFile");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLogLevel", "string", errors, newContext);
		const _u8slistLogLevel = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistLogLevel, errors, newContext, "u8slistLogLevel");
		TSConverter.validateParam(s, "iRestartImmediately", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLogLevel, name: "u8sLogLevel" }));
			if (_u8slistLogLevel)
				t.push(_u8slistLogLevel);
			t.push(new asn1ts.Integer({ value: s.iRestartImmediately, name: "iRestartImmediately" }));
		}

		if (errors.validateResult(newContext, "AsnMediaServerLogFile"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMediaServerLogFile | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMediaServerLogFile");

		let t: ENetUC_Mgmt.AsnMediaServerLogFile | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMediaServerLogFile.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMediaServerLogFile["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLogLevel", "Utf8String", errors, newContext);
			const _u8slistloglevel = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistLogLevel"), errors, newContext, "u8slistLogLevel");
			if (_u8slistloglevel)
				t.u8slistLogLevel = _u8slistloglevel;
			TSConverter.fillASN1Param(s, t, "iRestartImmediately", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMediaServerLogFile"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNumberFormatRegExpressionMgmt_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressionMgmt");

		const t = {} as ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNumberFormatRegExpressionMgmt";
		TSConverter.fillJSONParam(s, t, "u8sSearch", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sReplace", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMatchReplace", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoCreatedRule", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAutoRuleforLocation", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionMgmt"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressionMgmt");

		let t: ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sSearch", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sReplace", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMatchReplace", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoCreatedRule", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAutoRuleforLocation", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionMgmt"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNumberFormatRegExpressionMgmt";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressionMgmt");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sSearch", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sReplace", "string", errors, newContext);
		TSConverter.validateParam(s, "bMatchReplace", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAutoCreatedRule", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sAutoRuleforLocation", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sSearch, name: "u8sSearch" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sReplace, name: "u8sReplace" }));
			t.push(new asn1ts.Boolean({ value: s.bMatchReplace, name: "bMatchReplace" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoCreatedRule, name: "bAutoCreatedRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAutoRuleforLocation, name: "u8sAutoRuleforLocation" }));
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionMgmt"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressionMgmt");

		let t: ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnNumberFormatRegExpressionMgmt["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sSearch", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sReplace", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMatchReplace", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoCreatedRule", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAutoRuleforLocation", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionMgmt"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnRuleSoftphoneEmergencyMgmt_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmt");

		const t = {} as ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnRuleSoftphoneEmergencyMgmt";
		TSConverter.fillJSONParam(s, t, "u8sName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEmergencyNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSubnetID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSubnetMaskLen", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmt"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmt");

		let t: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEmergencyNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSubnetID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSubnetMaskLen", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmt"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnRuleSoftphoneEmergencyMgmt";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmt");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEmergencyNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSubnetID", "string", errors, newContext);
		TSConverter.validateParam(s, "iSubnetMaskLen", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sName, name: "u8sName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEmergencyNumber, name: "u8sEmergencyNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPrefix, name: "u8sPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSubnetID, name: "u8sSubnetID" }));
			t.push(new asn1ts.Integer({ value: s.iSubnetMaskLen, name: "iSubnetMaskLen" }));
		}

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmt"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmt");

		let t: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmt["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEmergencyNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSubnetID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSubnetMaskLen", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmt"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnELocalDialingRuleForeignPNALocalCallItem_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItem");

		const t = {} as ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnELocalDialingRuleForeignPNALocalCallItem";
		TSConverter.fillJSONParam(s, t, "u8sAreaCode", "string", errors, newContext);
		const _u8slistNXXPrefixList = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistNXXPrefixList, errors, newContext, "u8slistNXXPrefixList");
		if (_u8slistNXXPrefixList)
			t.u8slistNXXPrefixList = _u8slistNXXPrefixList;

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItem"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItem");

		let t: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sAreaCode", "string", errors, newContext, false);
			const _u8slistnxxprefixlist = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistNXXPrefixList, errors, newContext, "u8slistNXXPrefixList", false);
			if (_u8slistnxxprefixlist)
				t.u8slistNXXPrefixList = _u8slistnxxprefixlist;
		}

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItem"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnELocalDialingRuleForeignPNALocalCallItem";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItem");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sAreaCode", "string", errors, newContext);
		const _u8slistNXXPrefixList = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistNXXPrefixList, errors, newContext, "u8slistNXXPrefixList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sAreaCode, name: "u8sAreaCode" }));
			if (_u8slistNXXPrefixList)
				t.push(_u8slistNXXPrefixList);
		}

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItem"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItem");

		let t: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItem["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sAreaCode", "Utf8String", errors, newContext);
			const _u8slistnxxprefixlist = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistNXXPrefixList"), errors, newContext, "u8slistNXXPrefixList");
			if (_u8slistnxxprefixlist)
				t.u8slistNXXPrefixList = _u8slistnxxprefixlist;
		}

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItem"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnELCRProvider_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnELCRProvider, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnELCRProvider & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRProvider");

		const t = {} as ENetUC_Mgmt.AsnELCRProvider & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnELCRProvider";
		TSConverter.fillJSONParam(s, t, "u8sProviderName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProviderNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProviderCOLOR", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnELCRProvider"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRProvider | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRProvider");

		let t: ENetUC_Mgmt.AsnELCRProvider | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnELCRProvider>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnELCRProvider["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sProviderName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProviderNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProviderCOLOR", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnELCRProvider"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnELCRProvider | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnELCRProvider";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRProvider");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sProviderName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProviderNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "iProviderCOLOR", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sProviderName, name: "u8sProviderName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProviderNumber, name: "u8sProviderNumber" }));
			t.push(new asn1ts.Integer({ value: s.iProviderCOLOR, name: "iProviderCOLOR" }));
		}

		if (errors.validateResult(newContext, "AsnELCRProvider"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRProvider | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRProvider");

		let t: ENetUC_Mgmt.AsnELCRProvider | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnELCRProvider.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnELCRProvider["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sProviderName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProviderNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProviderCOLOR", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnELCRProvider"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnELCRZone_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnELCRZone, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnELCRZone & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRZone");

		const t = {} as ENetUC_Mgmt.AsnELCRZone & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnELCRZone";
		TSConverter.fillJSONParam(s, t, "u8sZoneName", "string", errors, newContext);
		const _u8slistZonePrefixList = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistZonePrefixList, errors, newContext, "u8slistZonePrefixList");
		if (_u8slistZonePrefixList)
			t.u8slistZonePrefixList = _u8slistZonePrefixList;
		TSConverter.fillJSONParam(s, t, "u8sTimeToProviderWeekDay", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTimeToProviderSaturday", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTimeToProviderSunday", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnELCRZone"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRZone | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRZone");

		let t: ENetUC_Mgmt.AsnELCRZone | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnELCRZone>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnELCRZone["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sZoneName", "string", errors, newContext, false);
			const _u8slistzoneprefixlist = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistZonePrefixList, errors, newContext, "u8slistZonePrefixList", false);
			if (_u8slistzoneprefixlist)
				t.u8slistZonePrefixList = _u8slistzoneprefixlist;
			TSConverter.fillJSONParam(s, t, "u8sTimeToProviderWeekDay", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTimeToProviderSaturday", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTimeToProviderSunday", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnELCRZone"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnELCRZone | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnELCRZone";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRZone");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sZoneName", "string", errors, newContext);
		const _u8slistZonePrefixList = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistZonePrefixList, errors, newContext, "u8slistZonePrefixList");
		TSConverter.validateParam(s, "u8sTimeToProviderWeekDay", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTimeToProviderSaturday", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTimeToProviderSunday", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sZoneName, name: "u8sZoneName" }));
			if (_u8slistZonePrefixList)
				t.push(_u8slistZonePrefixList);
			t.push(new asn1ts.Utf8String({ value: s.u8sTimeToProviderWeekDay, name: "u8sTimeToProviderWeekDay" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTimeToProviderSaturday, name: "u8sTimeToProviderSaturday" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTimeToProviderSunday, name: "u8sTimeToProviderSunday" }));
		}

		if (errors.validateResult(newContext, "AsnELCRZone"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRZone | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRZone");

		let t: ENetUC_Mgmt.AsnELCRZone | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnELCRZone.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnELCRZone["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sZoneName", "Utf8String", errors, newContext);
			const _u8slistzoneprefixlist = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistZonePrefixList"), errors, newContext, "u8slistZonePrefixList");
			if (_u8slistzoneprefixlist)
				t.u8slistZonePrefixList = _u8slistzoneprefixlist;
			TSConverter.fillASN1Param(s, t, "u8sTimeToProviderWeekDay", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTimeToProviderSaturday", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTimeToProviderSunday", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnELCRZone"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLocationInformationMgmtArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLocationInformationMgmtArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLocationInformationMgmtArgument";
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLocationInformationMgmtArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLocationInformationMgmtArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLocationInformationMgmtArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLocationInformationMgmtArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLocationInformationMgmtResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLocationInformationMgmtResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLocationInformationMgmtResult";

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLocationInformationMgmtResult");

		let t: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLocationInformationMgmtResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLocationInformationMgmtResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLocationInformationMgmtResult");

		let t: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDeleteLocationArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDeleteLocationArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDeleteLocationArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeleteLocationArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtDeleteLocationArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDeleteLocationArgument";
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDeleteLocationArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeleteLocationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeleteLocationArgument");

		let t: ENetUC_Mgmt.AsnMgmtDeleteLocationArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDeleteLocationArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDeleteLocationArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDeleteLocationArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDeleteLocationArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDeleteLocationArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeleteLocationArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDeleteLocationArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeleteLocationArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeleteLocationArgument");

		let t: ENetUC_Mgmt.AsnMgmtDeleteLocationArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDeleteLocationArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDeleteLocationArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDeleteLocationArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLocationChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLocationChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLocationChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLocationChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtLocationChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLocationChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMD5CheckSum", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtLocationChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLocationChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLocationChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtLocationChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLocationChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLocationChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMD5CheckSum", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtLocationChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLocationChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLocationChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLocationChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMD5CheckSum", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMD5CheckSum, name: "u8sMD5CheckSum" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtLocationChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLocationChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLocationChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtLocationChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLocationChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLocationChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMD5CheckSum", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtLocationChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCSTAServerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnCSTAServerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnCSTAServerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCSTAServerSettings");

		const t = {} as ENetUC_Mgmt.AsnCSTAServerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCSTAServerSettings";
		TSConverter.fillJSONParam(s, t, "iCSTAServerEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCSTAServerPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCSTAServerBindAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCSTAServerSSLEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCSTAServerSSLPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCSTAServerSSLBindAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCSTAServerSSLCertificateHash", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCSTAServerUser", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCSTAServerPasswd", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnCSTAServerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnCSTAServerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCSTAServerSettings");

		let t: ENetUC_Mgmt.AsnCSTAServerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnCSTAServerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnCSTAServerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iCSTAServerEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCSTAServerPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCSTAServerBindAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCSTAServerSSLEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCSTAServerSSLPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCSTAServerSSLBindAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCSTAServerSSLCertificateHash", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCSTAServerUser", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCSTAServerPasswd", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnCSTAServerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnCSTAServerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCSTAServerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCSTAServerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iCSTAServerEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iCSTAServerPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCSTAServerBindAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iCSTAServerSSLEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iCSTAServerSSLPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCSTAServerSSLBindAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCSTAServerSSLCertificateHash", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCSTAServerUser", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCSTAServerPasswd", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iCSTAServerEnabled, name: "iCSTAServerEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iCSTAServerPort, name: "iCSTAServerPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCSTAServerBindAddress, name: "u8sCSTAServerBindAddress" }));
			t.push(new asn1ts.Integer({ value: s.iCSTAServerSSLEnabled, name: "iCSTAServerSSLEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iCSTAServerSSLPort, name: "iCSTAServerSSLPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCSTAServerSSLBindAddress, name: "u8sCSTAServerSSLBindAddress" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCSTAServerSSLCertificateHash, name: "u8sCSTAServerSSLCertificateHash" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCSTAServerUser, name: "u8sCSTAServerUser" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCSTAServerPasswd, name: "u8sCSTAServerPasswd" }));
		}

		if (errors.validateResult(newContext, "AsnCSTAServerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnCSTAServerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCSTAServerSettings");

		let t: ENetUC_Mgmt.AsnCSTAServerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnCSTAServerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnCSTAServerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iCSTAServerEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCSTAServerPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCSTAServerBindAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCSTAServerSSLEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCSTAServerSSLPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCSTAServerSSLBindAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCSTAServerSSLCertificateHash", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCSTAServerUser", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCSTAServerPasswd", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnCSTAServerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAVStunOrTurnServer_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnAVStunOrTurnServer, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnAVStunOrTurnServer & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAVStunOrTurnServer");

		const t = {} as ENetUC_Mgmt.AsnAVStunOrTurnServer & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAVStunOrTurnServer";
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTTLSeconds", "number", errors, newContext);
		const _u8slistStrUris = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistStrUris, errors, newContext, "u8slistStrUris");
		if (_u8slistStrUris)
			t.u8slistStrUris = _u8slistStrUris;

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServer"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnAVStunOrTurnServer | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAVStunOrTurnServer");

		let t: ENetUC_Mgmt.AsnAVStunOrTurnServer | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnAVStunOrTurnServer>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnAVStunOrTurnServer["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTTLSeconds", "number", errors, newContext, false);
			const _u8sliststruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistStrUris, errors, newContext, "u8slistStrUris", false);
			if (_u8sliststruris)
				t.u8slistStrUris = _u8sliststruris;
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServer"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnAVStunOrTurnServer | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAVStunOrTurnServer";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAVStunOrTurnServer");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iTTLSeconds", "number", errors, newContext);
		const _u8slistStrUris = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistStrUris, errors, newContext, "u8slistStrUris");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPassword, name: "u8sPassword" }));
			t.push(new asn1ts.Integer({ value: s.iTTLSeconds, name: "iTTLSeconds" }));
			if (_u8slistStrUris)
				t.push(_u8slistStrUris);
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServer"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnAVStunOrTurnServer | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAVStunOrTurnServer");

		let t: ENetUC_Mgmt.AsnAVStunOrTurnServer | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnAVStunOrTurnServer.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnAVStunOrTurnServer["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTTLSeconds", "Integer", errors, newContext);
			const _u8sliststruris = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistStrUris"), errors, newContext, "u8slistStrUris");
			if (_u8sliststruris)
				t.u8slistStrUris = _u8sliststruris;
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServer"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSTUNandTURNConsumerConfigResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSTUNandTURNConsumerConfigResult";
		const _config = ENetUC_Common_SIPCTI_Converter.AsnConfigSTUNandTURNList_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _config = ENetUC_Common_SIPCTI_Converter.AsnConfigSTUNandTURNList_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSTUNandTURNConsumerConfigResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigResult");

		// [Print_BER_EncoderSeqDefCode]
		const _config = ENetUC_Common_SIPCTI_Converter.AsnConfigSTUNandTURNList_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _config = ENetUC_Common_SIPCTI_Converter.AsnConfigSTUNandTURNList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDBManSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDBManSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDBManSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDBManSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtDBManSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDBManSettings";
		TSConverter.fillJSONParam(s, t, "iNetDBEnabled", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDBManSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDBManSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDBManSettings");

		let t: ENetUC_Mgmt.AsnMgmtDBManSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDBManSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDBManSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNetDBEnabled", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDBManSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDBManSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDBManSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDBManSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNetDBEnabled", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNetDBEnabled, name: "iNetDBEnabled" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDBManSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDBManSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDBManSettings");

		let t: ENetUC_Mgmt.AsnMgmtDBManSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDBManSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDBManSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNetDBEnabled", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDBManSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnXMPPSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnXMPPSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnXMPPSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnXMPPSettings");

		const t = {} as ENetUC_Mgmt.AsnXMPPSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnXMPPSettings";
		TSConverter.fillJSONParam(s, t, "iXMPPEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iS2SPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sS2SBindAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProxyEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProxyPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyPwdEncrypted", "string", errors, newContext);
		const _u8sintpairlistDomainsAllow = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.toJSON(s.u8sintpairlistDomainsAllow, errors, newContext, "u8sintpairlistDomainsAllow");
		if (_u8sintpairlistDomainsAllow)
			t.u8sintpairlistDomainsAllow = _u8sintpairlistDomainsAllow;
		TSConverter.fillJSONParam(s, t, "u8sCertificateHash", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEncryptionLevel", "number", errors, newContext);
		const _u8sintpairlistDomainEncryptionLevel = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.toJSON(s.u8sintpairlistDomainEncryptionLevel, errors, newContext, "u8sintpairlistDomainEncryptionLevel");
		if (_u8sintpairlistDomainEncryptionLevel)
			t.u8sintpairlistDomainEncryptionLevel = _u8sintpairlistDomainEncryptionLevel;

		if (errors.validateResult(newContext, "AsnXMPPSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnXMPPSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnXMPPSettings");

		let t: ENetUC_Mgmt.AsnXMPPSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnXMPPSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnXMPPSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iXMPPEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iS2SPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sS2SBindAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProxyEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProxyPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyPwdEncrypted", "string", errors, newContext, false);
			const _u8sintpairlistdomainsallow = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.fromJSON(s.u8sintpairlistDomainsAllow, errors, newContext, "u8sintpairlistDomainsAllow", false);
			if (_u8sintpairlistdomainsallow)
				t.u8sintpairlistDomainsAllow = _u8sintpairlistdomainsallow;
			TSConverter.fillJSONParam(s, t, "u8sCertificateHash", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEncryptionLevel", "number", errors, newContext, false);
			const _u8sintpairlistdomainencryptionlevel = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.fromJSON(s.u8sintpairlistDomainEncryptionLevel, errors, newContext, "u8sintpairlistDomainEncryptionLevel", false);
			if (_u8sintpairlistdomainencryptionlevel)
				t.u8sintpairlistDomainEncryptionLevel = _u8sintpairlistdomainencryptionlevel;
		}

		if (errors.validateResult(newContext, "AsnXMPPSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnXMPPSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnXMPPSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnXMPPSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iXMPPEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iS2SPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sS2SBindAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iProxyEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iProxyPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyPwdEncrypted", "string", errors, newContext);
		const _u8sintpairlistDomainsAllow = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.toBER(s.u8sintpairlistDomainsAllow, errors, newContext, "u8sintpairlistDomainsAllow");
		TSConverter.validateParam(s, "u8sCertificateHash", "string", errors, newContext);
		TSConverter.validateParam(s, "iEncryptionLevel", "number", errors, newContext);
		const _u8sintpairlistDomainEncryptionLevel = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.toBER(s.u8sintpairlistDomainEncryptionLevel, errors, newContext, "u8sintpairlistDomainEncryptionLevel");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iXMPPEnabled, name: "iXMPPEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iS2SPort, name: "iS2SPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sS2SBindAddress, name: "u8sS2SBindAddress" }));
			t.push(new asn1ts.Integer({ value: s.iProxyEnabled, name: "iProxyEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iProxyPort, name: "iProxyPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyAddress, name: "u8sProxyAddress" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyPwdEncrypted, name: "u8sProxyPwdEncrypted" }));
			if (_u8sintpairlistDomainsAllow)
				t.push(_u8sintpairlistDomainsAllow);
			t.push(new asn1ts.Utf8String({ value: s.u8sCertificateHash, name: "u8sCertificateHash" }));
			t.push(new asn1ts.Integer({ value: s.iEncryptionLevel, name: "iEncryptionLevel" }));
			if (_u8sintpairlistDomainEncryptionLevel)
				t.push(_u8sintpairlistDomainEncryptionLevel);
		}

		if (errors.validateResult(newContext, "AsnXMPPSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnXMPPSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnXMPPSettings");

		let t: ENetUC_Mgmt.AsnXMPPSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnXMPPSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnXMPPSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iXMPPEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iS2SPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sS2SBindAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProxyEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProxyPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyPwdEncrypted", "Utf8String", errors, newContext);
			const _u8sintpairlistdomainsallow = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sintpairlistDomainsAllow"), errors, newContext, "u8sintpairlistDomainsAllow");
			if (_u8sintpairlistdomainsallow)
				t.u8sintpairlistDomainsAllow = _u8sintpairlistdomainsallow;
			TSConverter.fillASN1Param(s, t, "u8sCertificateHash", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEncryptionLevel", "Integer", errors, newContext);
			const _u8sintpairlistdomainencryptionlevel = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sintpairlistDomainEncryptionLevel"), errors, newContext, "u8sintpairlistDomainEncryptionLevel");
			if (_u8sintpairlistdomainencryptionlevel)
				t.u8sintpairlistDomainEncryptionLevel = _u8sintpairlistdomainencryptionlevel;
		}

		if (errors.validateResult(newContext, "AsnXMPPSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnListenInterfaceDescription_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnListenInterfaceDescription, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnListenInterfaceDescription & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListenInterfaceDescription");

		const t = {} as ENetUC_Mgmt.AsnListenInterfaceDescription & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnListenInterfaceDescription";
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIPAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProtocol", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iService", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sGUID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStaticRouteRefCount", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnListenInterfaceDescription"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListenInterfaceDescription | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListenInterfaceDescription");

		let t: ENetUC_Mgmt.AsnListenInterfaceDescription | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnListenInterfaceDescription>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnListenInterfaceDescription["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIPAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProtocol", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iService", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sGUID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStaticRouteRefCount", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnListenInterfaceDescription"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnListenInterfaceDescription | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnListenInterfaceDescription";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListenInterfaceDescription");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sIPAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iProtocol", "number", errors, newContext);
		TSConverter.validateParam(s, "iService", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sGUID", "string", errors, newContext);
		TSConverter.validateParam(s, "iStaticRouteRefCount", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIPAddress, name: "u8sIPAddress" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Integer({ value: s.iProtocol, name: "iProtocol" }));
			t.push(new asn1ts.Integer({ value: s.iService, name: "iService" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sGUID, name: "u8sGUID" }));
			t.push(new asn1ts.Integer({ value: s.iStaticRouteRefCount, name: "iStaticRouteRefCount" }));
		}

		if (errors.validateResult(newContext, "AsnListenInterfaceDescription"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListenInterfaceDescription | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListenInterfaceDescription");

		let t: ENetUC_Mgmt.AsnListenInterfaceDescription | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnListenInterfaceDescription.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnListenInterfaceDescription["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIPAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProtocol", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iService", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sGUID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStaticRouteRefCount", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnListenInterfaceDescription"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSIPFEDPubIPAdrResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDPubIPAdrResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSIPFEDPubIPAdrResult";
		TSConverter.fillJSONParam(s, t, "u8sPublicIPAddress", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDPubIPAdrResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDPubIPAdrResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sPublicIPAddress", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDPubIPAdrResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSIPFEDPubIPAdrResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDPubIPAdrResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sPublicIPAddress", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sPublicIPAddress, name: "u8sPublicIPAddress" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDPubIPAdrResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDPubIPAdrResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDPubIPAdrResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sPublicIPAddress", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDPubIPAdrResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtStartSipFedXmppDiagnosticsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtStartSipFedXmppDiagnosticsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtStartSipFedXmppDiagnosticsArgument";
		const _u8slistCommands = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistCommands, errors, newContext, "u8slistCommands");
		if (_u8slistCommands)
			t.u8slistCommands = _u8slistCommands;

		if (errors.validateResult(newContext, "AsnMgmtStartSipFedXmppDiagnosticsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtStartSipFedXmppDiagnosticsArgument");

		let t: ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistcommands = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistCommands, errors, newContext, "u8slistCommands", false);
			if (_u8slistcommands)
				t.u8slistCommands = _u8slistcommands;
		}

		if (errors.validateResult(newContext, "AsnMgmtStartSipFedXmppDiagnosticsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtStartSipFedXmppDiagnosticsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtStartSipFedXmppDiagnosticsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistCommands = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistCommands, errors, newContext, "u8slistCommands");
		if (!errors.hasNewErrors()) {
			if (_u8slistCommands)
				t.push(_u8slistCommands);
		}

		if (errors.validateResult(newContext, "AsnMgmtStartSipFedXmppDiagnosticsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtStartSipFedXmppDiagnosticsArgument");

		let t: ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtStartSipFedXmppDiagnosticsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistcommands = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistCommands"), errors, newContext, "u8slistCommands");
			if (_u8slistcommands)
				t.u8slistCommands = _u8slistcommands;
		}

		if (errors.validateResult(newContext, "AsnMgmtStartSipFedXmppDiagnosticsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSIPFEDSrvStateResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDSrvStateResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSIPFEDSrvStateResult";
		TSConverter.fillJSONParam(s, t, "u8sServerState", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSrvStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDSrvStateResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sServerState", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSrvStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSIPFEDSrvStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDSrvStateResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sServerState", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sServerState, name: "u8sServerState" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSrvStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDSrvStateResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDSrvStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sServerState", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSrvStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSIPFEDNetStateResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDNetStateResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSIPFEDNetStateResult";
		const _u8slistNetStates = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistNetStates, errors, newContext, "u8slistNetStates");
		if (_u8slistNetStates)
			t.u8slistNetStates = _u8slistNetStates;

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDNetStateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDNetStateResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistnetstates = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistNetStates, errors, newContext, "u8slistNetStates", false);
			if (_u8slistnetstates)
				t.u8slistNetStates = _u8slistnetstates;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDNetStateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSIPFEDNetStateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDNetStateResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistNetStates = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistNetStates, errors, newContext, "u8slistNetStates");
		if (!errors.hasNewErrors()) {
			if (_u8slistNetStates)
				t.push(_u8slistNetStates);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDNetStateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDNetStateResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDNetStateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistnetstates = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistNetStates"), errors, newContext, "u8slistNetStates");
			if (_u8slistnetstates)
				t.u8slistNetStates = _u8slistnetstates;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDNetStateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSIPGatewaySettingsRegisteredUser_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUser");

		const t = {} as ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSIPGatewaySettingsRegisteredUser";
		TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sListenUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDisplayName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAuthUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAuthPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sManualNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMainTrunkUser", "boolean", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUser"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUser");

		let t: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sListenUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDisplayName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAuthUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAuthPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sManualNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMainTrunkUser", "boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUser"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSIPGatewaySettingsRegisteredUser";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUser");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sListenUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDisplayName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAuthUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAuthPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sManualNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "bMainTrunkUser", "boolean", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUserName, name: "u8sUserName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sListenUserName, name: "u8sListenUserName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDisplayName, name: "u8sDisplayName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAuthUserName, name: "u8sAuthUserName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAuthPassword, name: "u8sAuthPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sManualNumber, name: "u8sManualNumber" }));
			if (s.bMainTrunkUser !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bMainTrunkUser, name: "bMainTrunkUser", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUser"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUser");

		let t: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUser["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sListenUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDisplayName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAuthUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAuthPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sManualNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMainTrunkUser", "Boolean", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUser"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetSIPGatewaySettingsV2Result_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Result");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetSIPGatewaySettingsV2Result";

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Result"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Result");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Result"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetSIPGatewaySettingsV2Result";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Result");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Result"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Result");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Result["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Result"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCallRecorderSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnCallRecorderSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnCallRecorderSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCallRecorderSettings");

		const t = {} as ENetUC_Mgmt.AsnCallRecorderSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCallRecorderSettings";
		TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseAudioCompression", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxConn", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMSNList", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDoNOTValidateCalledMSN", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEncoderPath", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEncoderParams", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEncoderOutSuffix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sManagedMailbox", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnCallRecorderSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnCallRecorderSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCallRecorderSettings");

		let t: ENetUC_Mgmt.AsnCallRecorderSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnCallRecorderSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnCallRecorderSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseAudioCompression", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxConn", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMSNList", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDoNOTValidateCalledMSN", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEncoderPath", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEncoderParams", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEncoderOutSuffix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sManagedMailbox", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnCallRecorderSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnCallRecorderSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCallRecorderSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCallRecorderSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iUseAudioCompression", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxConn", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sMSNList", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iDoNOTValidateCalledMSN", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sEncoderPath", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEncoderParams", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEncoderOutSuffix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sManagedMailbox", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iEnabled, name: "iEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iUseAudioCompression, name: "iUseAudioCompression" }));
			t.push(new asn1ts.Integer({ value: s.iMaxConn, name: "iMaxConn" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMSNList, name: "u8sMSNList" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Integer({ value: s.iDoNOTValidateCalledMSN, name: "iDoNOTValidateCalledMSN" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEncoderPath, name: "u8sEncoderPath" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEncoderParams, name: "u8sEncoderParams" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEncoderOutSuffix, name: "u8sEncoderOutSuffix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sManagedMailbox, name: "u8sManagedMailbox" }));
		}

		if (errors.validateResult(newContext, "AsnCallRecorderSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnCallRecorderSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCallRecorderSettings");

		let t: ENetUC_Mgmt.AsnCallRecorderSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnCallRecorderSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnCallRecorderSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseAudioCompression", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxConn", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMSNList", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDoNOTValidateCalledMSN", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEncoderPath", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEncoderParams", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEncoderOutSuffix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sManagedMailbox", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnCallRecorderSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLoginArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLoginArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLoginArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLoginArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtLoginArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLoginArgument";
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iVersion", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDuplicate", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSIPAVLines", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtLoginArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLoginArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLoginArgument");

		let t: ENetUC_Mgmt.AsnMgmtLoginArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLoginArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLoginArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iVersion", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDuplicate", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSIPAVLines", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtLoginArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLoginArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLoginArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLoginArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iVersion", "number", errors, newContext);
		TSConverter.validateParam(s, "iDuplicate", "number", errors, newContext);
		TSConverter.validateParam(s, "iSIPAVLines", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPassword, name: "u8sPassword" }));
			t.push(new asn1ts.Integer({ value: s.iVersion, name: "iVersion" }));
			t.push(new asn1ts.Integer({ value: s.iDuplicate, name: "iDuplicate" }));
			t.push(new asn1ts.Integer({ value: s.iSIPAVLines, name: "iSIPAVLines" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtLoginArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLoginArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLoginArgument");

		let t: ENetUC_Mgmt.AsnMgmtLoginArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLoginArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLoginArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iVersion", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDuplicate", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSIPAVLines", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtLoginArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLoginResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLoginResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLoginResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLoginResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtLoginResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLoginResult";
		TSConverter.fillJSONParam(s, t, "iOpenState", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtLoginResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLoginResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLoginResult");

		let t: ENetUC_Mgmt.AsnMgmtLoginResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLoginResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLoginResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iOpenState", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtLoginResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLoginResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLoginResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLoginResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iOpenState", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iOpenState, name: "iOpenState" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtLoginResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLoginResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLoginResult");

		let t: ENetUC_Mgmt.AsnMgmtLoginResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLoginResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLoginResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iOpenState", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtLoginResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtChangeLoginArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtChangeLoginArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtChangeLoginArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtChangeLoginArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtChangeLoginArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtChangeLoginArgument";
		TSConverter.fillJSONParam(s, t, "u8sNewUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNewPasswd", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtChangeLoginArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtChangeLoginArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtChangeLoginArgument");

		let t: ENetUC_Mgmt.AsnMgmtChangeLoginArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtChangeLoginArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtChangeLoginArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sNewUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNewPasswd", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtChangeLoginArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtChangeLoginArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtChangeLoginArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtChangeLoginArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sNewUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNewPasswd", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sNewUserName, name: "u8sNewUserName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNewPasswd, name: "u8sNewPasswd" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtChangeLoginArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtChangeLoginArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtChangeLoginArgument");

		let t: ENetUC_Mgmt.AsnMgmtChangeLoginArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtChangeLoginArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtChangeLoginArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sNewUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNewPasswd", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtChangeLoginArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtServerStatistics4Admin_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtServerStatistics4Admin, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtServerStatistics4Admin & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtServerStatistics4Admin");

		const t = {} as ENetUC_Mgmt.AsnMgmtServerStatistics4Admin & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtServerStatistics4Admin";
		TSConverter.fillJSONParam(s, t, "u8sService", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServiceUIName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iServiceState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sActive", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCount", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLicenses", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4Admin"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtServerStatistics4Admin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtServerStatistics4Admin");

		let t: ENetUC_Mgmt.AsnMgmtServerStatistics4Admin | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtServerStatistics4Admin>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtServerStatistics4Admin["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sService", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServiceUIName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iServiceState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sActive", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCount", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLicenses", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4Admin"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtServerStatistics4Admin | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtServerStatistics4Admin";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtServerStatistics4Admin");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sService", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sServiceUIName", "string", errors, newContext);
		TSConverter.validateParam(s, "iServiceState", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sActive", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCount", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLicenses", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sService, name: "u8sService" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServiceUIName, name: "u8sServiceUIName" }));
			t.push(new asn1ts.Integer({ value: s.iServiceState, name: "iServiceState" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sActive, name: "u8sActive" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCount, name: "u8sCount" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLicenses, name: "u8sLicenses" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4Admin"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtServerStatistics4Admin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtServerStatistics4Admin");

		let t: ENetUC_Mgmt.AsnMgmtServerStatistics4Admin | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtServerStatistics4Admin.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtServerStatistics4Admin["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sService", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServiceUIName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iServiceState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sActive", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCount", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLicenses", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4Admin"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSaveSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSaveSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSaveSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSaveSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSaveSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSaveSettingsArgument";
		TSConverter.fillJSONParam(s, t, "iSaveFlags", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSaveSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSaveSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSaveSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSaveSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSaveSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSaveSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iSaveFlags", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSaveSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSaveSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSaveSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSaveSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iSaveFlags", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iSaveFlags, name: "iSaveFlags" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSaveSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSaveSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSaveSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSaveSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSaveSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSaveSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iSaveFlags", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSaveSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtStartTLSArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtStartTLSArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtStartTLSArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtStartTLSArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtStartTLSArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtStartTLSArgument";

		if (errors.validateResult(newContext, "AsnMgmtStartTLSArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtStartTLSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtStartTLSArgument");

		let t: ENetUC_Mgmt.AsnMgmtStartTLSArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtStartTLSArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtStartTLSArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtStartTLSArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtStartTLSArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtStartTLSArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtStartTLSArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtStartTLSArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtStartTLSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtStartTLSArgument");

		let t: ENetUC_Mgmt.AsnMgmtStartTLSArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtStartTLSArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtStartTLSArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtStartTLSArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtStartTLSResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtStartTLSResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtStartTLSResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtStartTLSResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtStartTLSResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtStartTLSResult";

		if (errors.validateResult(newContext, "AsnMgmtStartTLSResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtStartTLSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtStartTLSResult");

		let t: ENetUC_Mgmt.AsnMgmtStartTLSResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtStartTLSResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtStartTLSResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtStartTLSResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtStartTLSResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtStartTLSResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtStartTLSResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtStartTLSResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtStartTLSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtStartTLSResult");

		let t: ENetUC_Mgmt.AsnMgmtStartTLSResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtStartTLSResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtStartTLSResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtStartTLSResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetServerVersionArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetServerVersionArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetServerVersionArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetServerVersionArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetServerVersionArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetServerVersionArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetServerVersionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetServerVersionArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetServerVersionArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetServerVersionArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetServerVersionArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetServerVersionArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetServerVersionArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetServerVersionArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetServerVersionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetServerVersionArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetServerVersionArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetServerVersionArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetServerVersionArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetServerVersionResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetServerVersionResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetServerVersionResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetServerVersionResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetServerVersionResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetServerVersionResult";
		TSConverter.fillJSONParam(s, t, "u8sInterfaceVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBuildVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sOSVersionString", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetServerVersionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetServerVersionResult");

		let t: ENetUC_Mgmt.AsnMgmtGetServerVersionResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetServerVersionResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetServerVersionResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sInterfaceVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBuildVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sOSVersionString", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetServerVersionResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetServerVersionResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetServerVersionResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sInterfaceVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sBuildVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sOSVersionString", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sInterfaceVersion, name: "u8sInterfaceVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBuildVersion, name: "u8sBuildVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sOSVersionString, name: "u8sOSVersionString" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetServerVersionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetServerVersionResult");

		let t: ENetUC_Mgmt.AsnMgmtGetServerVersionResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetServerVersionResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetServerVersionResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sInterfaceVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBuildVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sOSVersionString", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetServerVersionResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetCtiServerTypeArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCtiServerTypeArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetCtiServerTypeArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCtiServerTypeArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetCtiServerTypeArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCtiServerTypeArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCtiServerTypeArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetCtiServerTypeArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetIPInterfaceListResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetIPInterfaceListResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetIPInterfaceListResult";
		const _u8slistIPInterfaces = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistIPInterfaces, errors, newContext, "u8slistIPInterfaces");
		if (_u8slistIPInterfaces)
			t.u8slistIPInterfaces = _u8slistIPInterfaces;

		if (errors.validateResult(newContext, "AsnMgmtGetIPInterfaceListResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetIPInterfaceListResult");

		let t: ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistipinterfaces = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistIPInterfaces, errors, newContext, "u8slistIPInterfaces", false);
			if (_u8slistipinterfaces)
				t.u8slistIPInterfaces = _u8slistipinterfaces;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetIPInterfaceListResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetIPInterfaceListResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetIPInterfaceListResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistIPInterfaces = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistIPInterfaces, errors, newContext, "u8slistIPInterfaces");
		if (!errors.hasNewErrors()) {
			if (_u8slistIPInterfaces)
				t.push(_u8slistIPInterfaces);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetIPInterfaceListResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetIPInterfaceListResult");

		let t: ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetIPInterfaceListResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistipinterfaces = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistIPInterfaces"), errors, newContext, "u8slistIPInterfaces");
			if (_u8slistipinterfaces)
				t.u8slistIPInterfaces = _u8slistipinterfaces;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetIPInterfaceListResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSendPushCheckResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSendPushCheckResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSendPushCheckResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendPushCheckResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSendPushCheckResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSendPushCheckResult";
		TSConverter.fillJSONParam(s, t, "u8sErrorString", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSendPushCheckResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendPushCheckResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendPushCheckResult");

		let t: ENetUC_Mgmt.AsnMgmtSendPushCheckResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSendPushCheckResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSendPushCheckResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sErrorString", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendPushCheckResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSendPushCheckResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSendPushCheckResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSendPushCheckResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sErrorString", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sErrorString, name: "u8sErrorString" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSendPushCheckResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSendPushCheckResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSendPushCheckResult");

		let t: ENetUC_Mgmt.AsnMgmtSendPushCheckResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSendPushCheckResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSendPushCheckResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sErrorString", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSendPushCheckResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetUCCheckServerCookieArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUCCheckServerCookieArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetUCCheckServerCookieArgument";
		TSConverter.fillJSONParam(s, t, "u8sCookie", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetUCCheckServerCookieArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUCCheckServerCookieArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sCookie", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUCCheckServerCookieArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetUCCheckServerCookieArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUCCheckServerCookieArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sCookie", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sCookie, name: "u8sCookie" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUCCheckServerCookieArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUCCheckServerCookieArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetUCCheckServerCookieArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sCookie", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUCCheckServerCookieArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtNotificationSettingsExclusions_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtNotificationSettingsExclusions");

		const t = {} as ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtNotificationSettingsExclusions";
		TSConverter.fillJSONParam(s, t, "bNotForInternalCalls", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForCallsWithoutNumber", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForCallsWithoutContactDetails", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForRecurrentCallsWhileOffline", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForRecurrentCallsForTimeSpan", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNotForRecurrentCallsTimeSpan", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForShortRingingCall", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNotForShortRingingCallTimeSpan", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForLongRingingCall", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNotForLongRingingCallTimeSpan", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNotForCallsFromSpecificExtensions", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNotForCallsFromSpecificExtensions", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettingsExclusions"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtNotificationSettingsExclusions");

		let t: ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bNotForInternalCalls", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForCallsWithoutNumber", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForCallsWithoutContactDetails", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForRecurrentCallsWhileOffline", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForRecurrentCallsForTimeSpan", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNotForRecurrentCallsTimeSpan", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForShortRingingCall", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNotForShortRingingCallTimeSpan", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForLongRingingCall", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNotForLongRingingCallTimeSpan", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNotForCallsFromSpecificExtensions", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNotForCallsFromSpecificExtensions", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettingsExclusions"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtNotificationSettingsExclusions";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtNotificationSettingsExclusions");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bNotForInternalCalls", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bNotForCallsWithoutNumber", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bNotForCallsWithoutContactDetails", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bNotForRecurrentCallsWhileOffline", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bNotForRecurrentCallsForTimeSpan", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iNotForRecurrentCallsTimeSpan", "number", errors, newContext);
		TSConverter.validateParam(s, "bNotForShortRingingCall", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iNotForShortRingingCallTimeSpan", "number", errors, newContext);
		TSConverter.validateParam(s, "bNotForLongRingingCall", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iNotForLongRingingCallTimeSpan", "number", errors, newContext);
		TSConverter.validateParam(s, "bNotForCallsFromSpecificExtensions", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sNotForCallsFromSpecificExtensions", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bNotForInternalCalls, name: "bNotForInternalCalls" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForCallsWithoutNumber, name: "bNotForCallsWithoutNumber" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForCallsWithoutContactDetails, name: "bNotForCallsWithoutContactDetails" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForRecurrentCallsWhileOffline, name: "bNotForRecurrentCallsWhileOffline" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForRecurrentCallsForTimeSpan, name: "bNotForRecurrentCallsForTimeSpan" }));
			t.push(new asn1ts.Integer({ value: s.iNotForRecurrentCallsTimeSpan, name: "iNotForRecurrentCallsTimeSpan" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForShortRingingCall, name: "bNotForShortRingingCall" }));
			t.push(new asn1ts.Integer({ value: s.iNotForShortRingingCallTimeSpan, name: "iNotForShortRingingCallTimeSpan" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForLongRingingCall, name: "bNotForLongRingingCall" }));
			t.push(new asn1ts.Integer({ value: s.iNotForLongRingingCallTimeSpan, name: "iNotForLongRingingCallTimeSpan" }));
			t.push(new asn1ts.Boolean({ value: s.bNotForCallsFromSpecificExtensions, name: "bNotForCallsFromSpecificExtensions" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNotForCallsFromSpecificExtensions, name: "u8sNotForCallsFromSpecificExtensions" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettingsExclusions"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtNotificationSettingsExclusions");

		let t: ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtNotificationSettingsExclusions["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bNotForInternalCalls", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForCallsWithoutNumber", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForCallsWithoutContactDetails", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForRecurrentCallsWhileOffline", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForRecurrentCallsForTimeSpan", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNotForRecurrentCallsTimeSpan", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForShortRingingCall", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNotForShortRingingCallTimeSpan", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForLongRingingCall", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNotForLongRingingCallTimeSpan", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNotForCallsFromSpecificExtensions", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNotForCallsFromSpecificExtensions", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettingsExclusions"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtFetchMetaDNsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFetchMetaDNsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtFetchMetaDNsArgument";
		TSConverter.fillJSONParam(s, t, "u8sMetaServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iForceSSL", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFetchMetaDNsArgument");

		let t: ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMetaServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iForceSSL", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtFetchMetaDNsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFetchMetaDNsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMetaServer", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iForceSSL", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMetaServer, name: "u8sMetaServer" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Integer({ value: s.iForceSSL, name: "iForceSSL" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFetchMetaDNsArgument");

		let t: ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtFetchMetaDNsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMetaServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iForceSSL", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtFetchMetaDNsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFetchMetaDNsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtFetchMetaDNsResult";
		const _u8slistDnsList = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistDnsList, errors, newContext, "u8slistDnsList");
		if (_u8slistDnsList)
			t.u8slistDnsList = _u8slistDnsList;

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFetchMetaDNsResult");

		let t: ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistdnslist = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistDnsList, errors, newContext, "u8slistDnsList", false);
			if (_u8slistdnslist)
				t.u8slistDnsList = _u8slistdnslist;
		}

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtFetchMetaDNsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFetchMetaDNsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistDnsList = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistDnsList, errors, newContext, "u8slistDnsList");
		if (!errors.hasNewErrors()) {
			if (_u8slistDnsList)
				t.push(_u8slistDnsList);
		}

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFetchMetaDNsResult");

		let t: ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtFetchMetaDNsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistdnslist = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistDnsList"), errors, newContext, "u8slistDnsList");
			if (_u8slistdnslist)
				t.u8slistDnsList = _u8slistdnslist;
		}

		if (errors.validateResult(newContext, "AsnMgmtFetchMetaDNsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSSLCertificateDetails_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSSLCertificateDetails, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSSLCertificateDetails & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSSLCertificateDetails");

		const t = {} as ENetUC_Mgmt.AsnSSLCertificateDetails & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSSLCertificateDetails";
		TSConverter.fillJSONParam(s, t, "u8sCertHash", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIssuedTo", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIssuer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timValidFrom", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timValidTo", "Date", errors, newContext);
		const _u8sListAlternateNames = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sListAlternateNames, errors, newContext, "u8sListAlternateNames");
		if (_u8sListAlternateNames)
			t.u8sListAlternateNames = _u8sListAlternateNames;
		TSConverter.fillJSONParam(s, t, "bPrivateKeyAvail", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnSSLCertificateDetails"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSSLCertificateDetails | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSSLCertificateDetails");

		let t: ENetUC_Mgmt.AsnSSLCertificateDetails | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSSLCertificateDetails>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnSSLCertificateDetails["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sCertHash", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIssuedTo", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIssuer", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "timValidFrom", "string", errors, newContext, false))
				t.timValidFrom = new Date(s.timValidFrom);
			if (TSConverter.validateParam(s, "timValidTo", "string", errors, newContext, false))
				t.timValidTo = new Date(s.timValidTo);
			const _u8slistalternatenames = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sListAlternateNames, errors, newContext, "u8sListAlternateNames", false);
			if (_u8slistalternatenames)
				t.u8sListAlternateNames = _u8slistalternatenames;
			TSConverter.fillJSONParam(s, t, "bPrivateKeyAvail", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnSSLCertificateDetails"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSSLCertificateDetails | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSSLCertificateDetails";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSSLCertificateDetails");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sCertHash", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sIssuedTo", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sIssuer", "string", errors, newContext);
		TSConverter.validateParam(s, "timValidFrom", "Date", errors, newContext);
		TSConverter.validateParam(s, "timValidTo", "Date", errors, newContext);
		const _u8sListAlternateNames = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sListAlternateNames, errors, newContext, "u8sListAlternateNames");
		TSConverter.validateParam(s, "bPrivateKeyAvail", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sCertHash, name: "u8sCertHash" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIssuedTo, name: "u8sIssuedTo" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIssuer, name: "u8sIssuer" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timValidFrom), name: "timValidFrom" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timValidTo), name: "timValidTo" }));
			if (_u8sListAlternateNames)
				t.push(_u8sListAlternateNames);
			t.push(new asn1ts.Boolean({ value: s.bPrivateKeyAvail, name: "bPrivateKeyAvail" }));
		}

		if (errors.validateResult(newContext, "AsnSSLCertificateDetails"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSSLCertificateDetails | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSSLCertificateDetails");

		let t: ENetUC_Mgmt.AsnSSLCertificateDetails | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSSLCertificateDetails.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnSSLCertificateDetails["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sCertHash", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIssuedTo", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIssuer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timValidFrom", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timValidTo", "AsnSystemTime", errors, newContext);
			const _u8slistalternatenames = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sListAlternateNames"), errors, newContext, "u8sListAlternateNames");
			if (_u8slistalternatenames)
				t.u8sListAlternateNames = _u8slistalternatenames;
			TSConverter.fillASN1Param(s, t, "bPrivateKeyAvail", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnSSLCertificateDetails"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSoftwareProfilesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSoftwareProfilesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSoftwareProfilesResult";
		const _u8slistSoftwareProfilesAsXML = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistSoftwareProfilesAsXML, errors, newContext, "u8slistSoftwareProfilesAsXML");
		if (_u8slistSoftwareProfilesAsXML)
			t.u8slistSoftwareProfilesAsXML = _u8slistSoftwareProfilesAsXML;

		if (errors.validateResult(newContext, "AsnMgmtGetSoftwareProfilesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSoftwareProfilesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistsoftwareprofilesasxml = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistSoftwareProfilesAsXML, errors, newContext, "u8slistSoftwareProfilesAsXML", false);
			if (_u8slistsoftwareprofilesasxml)
				t.u8slistSoftwareProfilesAsXML = _u8slistsoftwareprofilesasxml;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSoftwareProfilesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSoftwareProfilesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSoftwareProfilesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistSoftwareProfilesAsXML = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistSoftwareProfilesAsXML, errors, newContext, "u8slistSoftwareProfilesAsXML");
		if (!errors.hasNewErrors()) {
			if (_u8slistSoftwareProfilesAsXML)
				t.push(_u8slistSoftwareProfilesAsXML);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSoftwareProfilesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSoftwareProfilesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSoftwareProfilesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistsoftwareprofilesasxml = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistSoftwareProfilesAsXML"), errors, newContext, "u8slistSoftwareProfilesAsXML");
			if (_u8slistsoftwareprofilesasxml)
				t.u8slistSoftwareProfilesAsXML = _u8slistsoftwareprofilesasxml;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSoftwareProfilesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetSoftwareProfilesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSoftwareProfilesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetSoftwareProfilesArgument";
		const _u8slistSoftwareProfilesAsXML = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistSoftwareProfilesAsXML, errors, newContext, "u8slistSoftwareProfilesAsXML");
		if (_u8slistSoftwareProfilesAsXML)
			t.u8slistSoftwareProfilesAsXML = _u8slistSoftwareProfilesAsXML;

		if (errors.validateResult(newContext, "AsnMgmtSetSoftwareProfilesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSoftwareProfilesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistsoftwareprofilesasxml = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistSoftwareProfilesAsXML, errors, newContext, "u8slistSoftwareProfilesAsXML", false);
			if (_u8slistsoftwareprofilesasxml)
				t.u8slistSoftwareProfilesAsXML = _u8slistsoftwareprofilesasxml;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSoftwareProfilesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetSoftwareProfilesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSoftwareProfilesArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistSoftwareProfilesAsXML = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistSoftwareProfilesAsXML, errors, newContext, "u8slistSoftwareProfilesAsXML");
		if (!errors.hasNewErrors()) {
			if (_u8slistSoftwareProfilesAsXML)
				t.push(_u8slistSoftwareProfilesAsXML);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSoftwareProfilesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSoftwareProfilesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetSoftwareProfilesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistsoftwareprofilesasxml = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistSoftwareProfilesAsXML"), errors, newContext, "u8slistSoftwareProfilesAsXML");
			if (_u8slistsoftwareprofilesasxml)
				t.u8slistSoftwareProfilesAsXML = _u8slistsoftwareprofilesasxml;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSoftwareProfilesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetGlobalGroupingAttributesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGlobalGroupingAttributesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetGlobalGroupingAttributesResult";
		TSConverter.fillJSONParam(s, t, "u8sGroupingAttributeSetGlobal", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetGlobalGroupingAttributesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGlobalGroupingAttributesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sGroupingAttributeSetGlobal", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGlobalGroupingAttributesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetGlobalGroupingAttributesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGlobalGroupingAttributesResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sGroupingAttributeSetGlobal", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupingAttributeSetGlobal, name: "u8sGroupingAttributeSetGlobal" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGlobalGroupingAttributesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGlobalGroupingAttributesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetGlobalGroupingAttributesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sGroupingAttributeSetGlobal", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGlobalGroupingAttributesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetGlobalGroupingAttributesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetGlobalGroupingAttributesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetGlobalGroupingAttributesArgument";
		TSConverter.fillJSONParam(s, t, "u8sGroupingAttributeSetGlobal", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetGlobalGroupingAttributesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetGlobalGroupingAttributesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sGroupingAttributeSetGlobal", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGlobalGroupingAttributesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetGlobalGroupingAttributesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetGlobalGroupingAttributesArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sGroupingAttributeSetGlobal", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupingAttributeSetGlobal, name: "u8sGroupingAttributeSetGlobal" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGlobalGroupingAttributesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetGlobalGroupingAttributesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetGlobalGroupingAttributesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sGroupingAttributeSetGlobal", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGlobalGroupingAttributesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserXmlClientContentArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserXmlClientContentArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserXmlClientContentArgument";
		TSConverter.fillJSONParam(s, t, "u8sUserID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserXmlClientContentArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUserID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserXmlClientContentArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserXmlClientContentArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUserID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUserID, name: "u8sUserID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserXmlClientContentArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUserID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserXmlClientContentResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserXmlClientContentResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserXmlClientContentResult";
		TSConverter.fillJSONParam(s, t, "u8sClientContentAsXML", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserXmlClientContentResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sClientContentAsXML", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserXmlClientContentResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserXmlClientContentResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sClientContentAsXML", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sClientContentAsXML, name: "u8sClientContentAsXML" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserXmlClientContentResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserXmlClientContentResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sClientContentAsXML", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserXmlClientContentResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetUserXmlClientContentArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUserXmlClientContentArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetUserXmlClientContentArgument";
		TSConverter.fillJSONParam(s, t, "u8sUserID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientContentAsXML", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetUserXmlClientContentArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUserXmlClientContentArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUserID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientContentAsXML", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUserXmlClientContentArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetUserXmlClientContentArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUserXmlClientContentArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUserID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sClientContentAsXML", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUserID, name: "u8sUserID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientContentAsXML, name: "u8sClientContentAsXML" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUserXmlClientContentArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUserXmlClientContentArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetUserXmlClientContentArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUserID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientContentAsXML", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUserXmlClientContentArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserDefinedCustomFieldsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserDefinedCustomFieldsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserDefinedCustomFieldsResult";
		const _mapCustomFields = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.mapCustomFields, errors, newContext, "mapCustomFields");
		if (_mapCustomFields)
			t.mapCustomFields = _mapCustomFields;

		if (errors.validateResult(newContext, "AsnMgmtGetUserDefinedCustomFieldsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserDefinedCustomFieldsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _mapcustomfields = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.mapCustomFields, errors, newContext, "mapCustomFields", false);
			if (_mapcustomfields)
				t.mapCustomFields = _mapcustomfields;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserDefinedCustomFieldsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserDefinedCustomFieldsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserDefinedCustomFieldsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _mapCustomFields = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.mapCustomFields, errors, newContext, "mapCustomFields");
		if (!errors.hasNewErrors()) {
			if (_mapCustomFields)
				t.push(_mapCustomFields);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserDefinedCustomFieldsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserDefinedCustomFieldsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserDefinedCustomFieldsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _mapcustomfields = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapCustomFields"), errors, newContext, "mapCustomFields");
			if (_mapcustomfields)
				t.mapCustomFields = _mapcustomfields;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserDefinedCustomFieldsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetUserDefinedCustomFieldsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUserDefinedCustomFieldsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetUserDefinedCustomFieldsArgument";
		const _mapCustomFields = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.mapCustomFields, errors, newContext, "mapCustomFields");
		if (_mapCustomFields)
			t.mapCustomFields = _mapCustomFields;

		if (errors.validateResult(newContext, "AsnMgmtSetUserDefinedCustomFieldsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUserDefinedCustomFieldsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _mapcustomfields = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.mapCustomFields, errors, newContext, "mapCustomFields", false);
			if (_mapcustomfields)
				t.mapCustomFields = _mapcustomfields;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUserDefinedCustomFieldsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetUserDefinedCustomFieldsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUserDefinedCustomFieldsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _mapCustomFields = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.mapCustomFields, errors, newContext, "mapCustomFields");
		if (!errors.hasNewErrors()) {
			if (_mapCustomFields)
				t.push(_mapCustomFields);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUserDefinedCustomFieldsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUserDefinedCustomFieldsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetUserDefinedCustomFieldsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _mapcustomfields = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapCustomFields"), errors, newContext, "mapCustomFields");
			if (_mapcustomfields)
				t.mapCustomFields = _mapcustomfields;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUserDefinedCustomFieldsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSIPFEDXmppDiagnosticResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDXmppDiagnosticResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSIPFEDXmppDiagnosticResult";
		const _u8slistResults = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistResults, errors, newContext, "u8slistResults");
		if (_u8slistResults)
			t.u8slistResults = _u8slistResults;

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDXmppDiagnosticResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDXmppDiagnosticResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistresults = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistResults, errors, newContext, "u8slistResults", false);
			if (_u8slistresults)
				t.u8slistResults = _u8slistresults;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDXmppDiagnosticResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSIPFEDXmppDiagnosticResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDXmppDiagnosticResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistResults = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistResults, errors, newContext, "u8slistResults");
		if (!errors.hasNewErrors()) {
			if (_u8slistResults)
				t.push(_u8slistResults);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDXmppDiagnosticResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDXmppDiagnosticResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDXmppDiagnosticResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistresults = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistResults"), errors, newContext, "u8slistResults");
			if (_u8slistresults)
				t.u8slistResults = _u8slistresults;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDXmppDiagnosticResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtCtiForwardEntry_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtCtiForwardEntry, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtCtiForwardEntry & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiForwardEntry");

		const t = {} as ENetUC_Mgmt.AsnMgmtCtiForwardEntry & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtCtiForwardEntry";
		TSConverter.fillJSONParam(s, t, "iInternalID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iForwardController", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iForwardMode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iBackEndSpecific", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNoAnswerTime", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDestinationSC", "string", errors, newContext);
		const _u8slistCallerIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistCallerIDs, errors, newContext, "u8slistCallerIDs");
		if (_u8slistCallerIDs)
			t.u8slistCallerIDs = _u8slistCallerIDs;

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntry"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiForwardEntry | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiForwardEntry");

		let t: ENetUC_Mgmt.AsnMgmtCtiForwardEntry | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtCtiForwardEntry>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtCtiForwardEntry["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iInternalID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iForwardController", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iForwardMode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iBackEndSpecific", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNoAnswerTime", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDestinationSC", "string", errors, newContext, false);
			const _u8slistcallerids = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistCallerIDs, errors, newContext, "u8slistCallerIDs", false);
			if (_u8slistcallerids)
				t.u8slistCallerIDs = _u8slistcallerids;
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntry"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtCtiForwardEntry | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtCtiForwardEntry";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiForwardEntry");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iInternalID", "number", errors, newContext);
		TSConverter.validateParam(s, "iForwardController", "number", errors, newContext);
		TSConverter.validateParam(s, "iForwardMode", "number", errors, newContext);
		TSConverter.validateParam(s, "iBackEndSpecific", "number", errors, newContext);
		TSConverter.validateParam(s, "iNoAnswerTime", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sDestinationSC", "string", errors, newContext);
		const _u8slistCallerIDs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistCallerIDs, errors, newContext, "u8slistCallerIDs");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iInternalID, name: "iInternalID" }));
			t.push(new asn1ts.Integer({ value: s.iForwardController, name: "iForwardController" }));
			t.push(new asn1ts.Integer({ value: s.iForwardMode, name: "iForwardMode" }));
			t.push(new asn1ts.Integer({ value: s.iBackEndSpecific, name: "iBackEndSpecific" }));
			t.push(new asn1ts.Integer({ value: s.iNoAnswerTime, name: "iNoAnswerTime" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDestinationSC, name: "u8sDestinationSC" }));
			if (_u8slistCallerIDs)
				t.push(_u8slistCallerIDs);
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntry"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiForwardEntry | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiForwardEntry");

		let t: ENetUC_Mgmt.AsnMgmtCtiForwardEntry | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtCtiForwardEntry.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtCtiForwardEntry["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iInternalID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iForwardController", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iForwardMode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iBackEndSpecific", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNoAnswerTime", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDestinationSC", "Utf8String", errors, newContext);
			const _u8slistcallerids = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistCallerIDs"), errors, newContext, "u8slistCallerIDs");
			if (_u8slistcallerids)
				t.u8slistCallerIDs = _u8slistcallerids;
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntry"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineForwardingArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineForwardingArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineForwardingArgument";
		TSConverter.fillJSONParam(s, t, "iFWController", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineForwardingArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iFWController", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineForwardingArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineForwardingArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iFWController", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iFWController, name: "iFWController" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineForwardingArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineForwardingArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iFWController", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAvailableLanguage_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAvailableLanguage, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAvailableLanguage & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAvailableLanguage");

		const t = {} as ENetUC_Mgmt.AsnMgmtAvailableLanguage & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAvailableLanguage";
		TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext);
		const _mapTranslatedStrings = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.toJSON(s.mapTranslatedStrings, errors, newContext, "mapTranslatedStrings");
		if (_mapTranslatedStrings)
			t.mapTranslatedStrings = _mapTranslatedStrings;
		const _mapTranslatedStringToString = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.mapTranslatedStringToString, errors, newContext, "mapTranslatedStringToString");
		if (_mapTranslatedStringToString)
			t.mapTranslatedStringToString = _mapTranslatedStringToString;

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguage"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAvailableLanguage | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAvailableLanguage");

		let t: ENetUC_Mgmt.AsnMgmtAvailableLanguage | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAvailableLanguage>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAvailableLanguage["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext, false);
			const _maptranslatedstrings = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.fromJSON(s.mapTranslatedStrings, errors, newContext, "mapTranslatedStrings", false);
			if (_maptranslatedstrings)
				t.mapTranslatedStrings = _maptranslatedstrings;
			const _maptranslatedstringtostring = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.mapTranslatedStringToString, errors, newContext, "mapTranslatedStringToString", false);
			if (_maptranslatedstringtostring)
				t.mapTranslatedStringToString = _maptranslatedstringtostring;
		}

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguage"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAvailableLanguage | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAvailableLanguage";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAvailableLanguage");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iLanguage", "number", errors, newContext);
		const _mapTranslatedStrings = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.toBER(s.mapTranslatedStrings, errors, newContext, "mapTranslatedStrings");
		const _mapTranslatedStringToString = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.mapTranslatedStringToString, errors, newContext, "mapTranslatedStringToString");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iLanguage, name: "iLanguage" }));
			if (_mapTranslatedStrings)
				t.push(_mapTranslatedStrings);
			if (_mapTranslatedStringToString)
				t.push(_mapTranslatedStringToString);
		}

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguage"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAvailableLanguage | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAvailableLanguage");

		let t: ENetUC_Mgmt.AsnMgmtAvailableLanguage | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAvailableLanguage.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAvailableLanguage["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iLanguage", "Integer", errors, newContext);
			const _maptranslatedstrings = ENetUC_Common_Converter.AsnStringIntegerPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapTranslatedStrings"), errors, newContext, "mapTranslatedStrings");
			if (_maptranslatedstrings)
				t.mapTranslatedStrings = _maptranslatedstrings;
			const _maptranslatedstringtostring = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapTranslatedStringToString"), errors, newContext, "mapTranslatedStringToString");
			if (_maptranslatedstringtostring)
				t.mapTranslatedStringToString = _maptranslatedstringtostring;
		}

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguage"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUpgradeProgressArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpgradeProgressArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUpgradeProgressArgument";
		TSConverter.fillJSONParam(s, t, "iProgressMax", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProgressCur", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUpgradeProgressArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpgradeProgressArgument");

		let t: ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iProgressMax", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProgressCur", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeProgressArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUpgradeProgressArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpgradeProgressArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iProgressMax", "number", errors, newContext);
		TSConverter.validateParam(s, "iProgressCur", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iProgressMax, name: "iProgressMax" }));
			t.push(new asn1ts.Integer({ value: s.iProgressCur, name: "iProgressCur" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeProgressArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpgradeProgressArgument");

		let t: ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUpgradeProgressArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iProgressMax", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProgressCur", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeProgressArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUpgradeStartArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUpgradeStartArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUpgradeStartArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpgradeStartArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtUpgradeStartArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUpgradeStartArgument";

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpgradeStartArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpgradeStartArgument");

		let t: ENetUC_Mgmt.AsnMgmtUpgradeStartArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUpgradeStartArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUpgradeStartArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUpgradeStartArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUpgradeStartArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpgradeStartArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpgradeStartArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpgradeStartArgument");

		let t: ENetUC_Mgmt.AsnMgmtUpgradeStartArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUpgradeStartArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUpgradeStartArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUpgradeStartResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUpgradeStartResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUpgradeStartResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpgradeStartResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtUpgradeStartResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUpgradeStartResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpgradeStartResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpgradeStartResult");

		let t: ENetUC_Mgmt.AsnMgmtUpgradeStartResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUpgradeStartResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUpgradeStartResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUpgradeStartResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUpgradeStartResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpgradeStartResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpgradeStartResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpgradeStartResult");

		let t: ENetUC_Mgmt.AsnMgmtUpgradeStartResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUpgradeStartResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUpgradeStartResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpgradeStartResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtPushServiceDeviceProps_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDeviceProps");

		const t = {} as ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtPushServiceDeviceProps";
		TSConverter.fillJSONParam(s, t, "u8sDeviceID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDeviceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPushID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPushChannel", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOnlineState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timlastRegisterTime", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMessageTypes", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEncryptionMode", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceProps"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDeviceProps");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sDeviceID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDeviceName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPushID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPushChannel", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOnlineState", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "timlastRegisterTime", "string", errors, newContext, false))
				t.timlastRegisterTime = new Date(s.timlastRegisterTime);
			TSConverter.fillJSONParam(s, t, "iMessageTypes", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEncryptionMode", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceProps"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtPushServiceDeviceProps";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDeviceProps");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sDeviceID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDeviceName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPushID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPushChannel", "string", errors, newContext);
		TSConverter.validateParam(s, "iOnlineState", "number", errors, newContext);
		TSConverter.validateParam(s, "timlastRegisterTime", "Date", errors, newContext);
		TSConverter.validateParam(s, "iMessageTypes", "number", errors, newContext);
		TSConverter.validateParam(s, "iEncryptionMode", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sDeviceID, name: "u8sDeviceID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDeviceName, name: "u8sDeviceName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPushID, name: "u8sPushID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPushChannel, name: "u8sPushChannel" }));
			t.push(new asn1ts.Integer({ value: s.iOnlineState, name: "iOnlineState" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timlastRegisterTime), name: "timlastRegisterTime" }));
			t.push(new asn1ts.Integer({ value: s.iMessageTypes, name: "iMessageTypes" }));
			t.push(new asn1ts.Integer({ value: s.iEncryptionMode, name: "iEncryptionMode" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceProps"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDeviceProps");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtPushServiceDeviceProps["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sDeviceID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDeviceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPushID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPushChannel", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOnlineState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timlastRegisterTime", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMessageTypes", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEncryptionMode", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceProps"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetPushServiceDevicesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPushServiceDevicesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetPushServiceDevicesArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPushServiceDevicesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetPushServiceDevicesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPushServiceDevicesArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPushServiceDevicesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetPushServiceDevicesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPushServiceDevicesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetPushServiceDevicesResult";
		TSConverter.fillJSONParam(s, t, "u8sCrossRefID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPushServiceDevicesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sCrossRefID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetPushServiceDevicesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPushServiceDevicesResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sCrossRefID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sCrossRefID, name: "u8sCrossRefID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPushServiceDevicesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetPushServiceDevicesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sCrossRefID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPushServiceDevicesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDeletePushServiceDeviceArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeletePushServiceDeviceArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDeletePushServiceDeviceArgument";
		TSConverter.fillJSONParam(s, t, "u8sDeviceID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeletePushServiceDeviceArgument");

		let t: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sDeviceID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDeletePushServiceDeviceArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeletePushServiceDeviceArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sDeviceID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sDeviceID, name: "u8sDeviceID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeletePushServiceDeviceArgument");

		let t: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sDeviceID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDeletePushServiceDeviceResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeletePushServiceDeviceResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDeletePushServiceDeviceResult";

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeletePushServiceDeviceResult");

		let t: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDeletePushServiceDeviceResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDeletePushServiceDeviceResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDeletePushServiceDeviceResult");

		let t: ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDeletePushServiceDeviceResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtDeletePushServiceDeviceResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtPhoneJournalSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtPhoneJournalSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtPhoneJournalSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPhoneJournalSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtPhoneJournalSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtPhoneJournalSettings";
		TSConverter.fillJSONParam(s, t, "iPrivateCallOptions", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseOfflineJournal", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOfflineDeleteOldEntries", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOfflineDaysNoDelete", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDeleteInternalJournalEntries", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeleteInternalJournalEntriesAfterDays", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDeleteExternalJournalEntries", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeleteExternalJournalEntriesAfterDays", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDeleteNoteJournalEntries", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeleteNoteJournalEntriesAfterDays", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUnansweredCallJournalOption", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iAnsweredRedirectedCallJournalOption", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoMarkReadGroupCallsOnCallback", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iHandlingMode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iArchiveJournalEntriesAfterDays", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtPhoneJournalSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPhoneJournalSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPhoneJournalSettings");

		let t: ENetUC_Mgmt.AsnMgmtPhoneJournalSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtPhoneJournalSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtPhoneJournalSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iPrivateCallOptions", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseOfflineJournal", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOfflineDeleteOldEntries", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOfflineDaysNoDelete", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDeleteInternalJournalEntries", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeleteInternalJournalEntriesAfterDays", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDeleteExternalJournalEntries", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeleteExternalJournalEntriesAfterDays", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDeleteNoteJournalEntries", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeleteNoteJournalEntriesAfterDays", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUnansweredCallJournalOption", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iAnsweredRedirectedCallJournalOption", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoMarkReadGroupCallsOnCallback", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iHandlingMode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iArchiveJournalEntriesAfterDays", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtPhoneJournalSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtPhoneJournalSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtPhoneJournalSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPhoneJournalSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iPrivateCallOptions", "number", errors, newContext);
		TSConverter.validateParam(s, "iUseOfflineJournal", "number", errors, newContext);
		TSConverter.validateParam(s, "iOfflineDeleteOldEntries", "number", errors, newContext);
		TSConverter.validateParam(s, "iOfflineDaysNoDelete", "number", errors, newContext);
		TSConverter.validateParam(s, "bDeleteInternalJournalEntries", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iDeleteInternalJournalEntriesAfterDays", "number", errors, newContext);
		TSConverter.validateParam(s, "bDeleteExternalJournalEntries", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iDeleteExternalJournalEntriesAfterDays", "number", errors, newContext);
		TSConverter.validateParam(s, "bDeleteNoteJournalEntries", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iDeleteNoteJournalEntriesAfterDays", "number", errors, newContext);
		TSConverter.validateParam(s, "iUnansweredCallJournalOption", "number", errors, newContext);
		TSConverter.validateParam(s, "iAnsweredRedirectedCallJournalOption", "number", errors, newContext);
		TSConverter.validateParam(s, "bAutoMarkReadGroupCallsOnCallback", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iHandlingMode", "number", errors, newContext);
		TSConverter.validateParam(s, "iArchiveJournalEntriesAfterDays", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iPrivateCallOptions, name: "iPrivateCallOptions" }));
			t.push(new asn1ts.Integer({ value: s.iUseOfflineJournal, name: "iUseOfflineJournal" }));
			t.push(new asn1ts.Integer({ value: s.iOfflineDeleteOldEntries, name: "iOfflineDeleteOldEntries" }));
			t.push(new asn1ts.Integer({ value: s.iOfflineDaysNoDelete, name: "iOfflineDaysNoDelete" }));
			t.push(new asn1ts.Boolean({ value: s.bDeleteInternalJournalEntries, name: "bDeleteInternalJournalEntries" }));
			t.push(new asn1ts.Integer({ value: s.iDeleteInternalJournalEntriesAfterDays, name: "iDeleteInternalJournalEntriesAfterDays" }));
			t.push(new asn1ts.Boolean({ value: s.bDeleteExternalJournalEntries, name: "bDeleteExternalJournalEntries" }));
			t.push(new asn1ts.Integer({ value: s.iDeleteExternalJournalEntriesAfterDays, name: "iDeleteExternalJournalEntriesAfterDays" }));
			t.push(new asn1ts.Boolean({ value: s.bDeleteNoteJournalEntries, name: "bDeleteNoteJournalEntries" }));
			t.push(new asn1ts.Integer({ value: s.iDeleteNoteJournalEntriesAfterDays, name: "iDeleteNoteJournalEntriesAfterDays" }));
			t.push(new asn1ts.Integer({ value: s.iUnansweredCallJournalOption, name: "iUnansweredCallJournalOption" }));
			t.push(new asn1ts.Integer({ value: s.iAnsweredRedirectedCallJournalOption, name: "iAnsweredRedirectedCallJournalOption" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoMarkReadGroupCallsOnCallback, name: "bAutoMarkReadGroupCallsOnCallback" }));
			t.push(new asn1ts.Integer({ value: s.iHandlingMode, name: "iHandlingMode" }));
			t.push(new asn1ts.Integer({ value: s.iArchiveJournalEntriesAfterDays, name: "iArchiveJournalEntriesAfterDays" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtPhoneJournalSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPhoneJournalSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPhoneJournalSettings");

		let t: ENetUC_Mgmt.AsnMgmtPhoneJournalSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtPhoneJournalSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtPhoneJournalSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iPrivateCallOptions", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseOfflineJournal", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOfflineDeleteOldEntries", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOfflineDaysNoDelete", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDeleteInternalJournalEntries", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeleteInternalJournalEntriesAfterDays", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDeleteExternalJournalEntries", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeleteExternalJournalEntriesAfterDays", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDeleteNoteJournalEntries", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeleteNoteJournalEntriesAfterDays", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUnansweredCallJournalOption", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iAnsweredRedirectedCallJournalOption", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoMarkReadGroupCallsOnCallback", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iHandlingMode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iArchiveJournalEntriesAfterDays", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtPhoneJournalSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetPhoneJournalSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetPhoneJournalSettingsArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetPhoneJournalSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetPhoneJournalSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetPhoneJournalSettingsResult";

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetPhoneJournalSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetGroupProfileArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetGroupProfileArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetGroupProfileArgument";
		TSConverter.fillJSONParam(s, t, "iSearchFilter", "number", errors, newContext);
		const _groupProfile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.toJSON(s.groupProfile, errors, newContext, "groupProfile");
		if (_groupProfile)
			t.groupProfile = _groupProfile;
		if (s.oldMemberListForDeltaChangeCalculation) {
			const _oldMemberListForDeltaChangeCalculation = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.oldMemberListForDeltaChangeCalculation, errors, newContext, "oldMemberListForDeltaChangeCalculation");
			if (_oldMemberListForDeltaChangeCalculation)
				t.oldMemberListForDeltaChangeCalculation = _oldMemberListForDeltaChangeCalculation;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetGroupProfileArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iSearchFilter", "number", errors, newContext, false);
			const _groupprofile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.fromJSON(s.groupProfile, errors, newContext, "groupProfile", false);
			if (_groupprofile)
				t.groupProfile = _groupprofile;
			const _oldmemberlistfordeltachangecalculation = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.oldMemberListForDeltaChangeCalculation, errors, newContext, "oldMemberListForDeltaChangeCalculation", true);
			if (_oldmemberlistfordeltachangecalculation)
				t.oldMemberListForDeltaChangeCalculation = _oldmemberlistfordeltachangecalculation;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetGroupProfileArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetGroupProfileArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iSearchFilter", "number", errors, newContext);
		const _groupProfile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.toBER(s.groupProfile, errors, newContext, "groupProfile");
		const _oldMemberListForDeltaChangeCalculation = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.oldMemberListForDeltaChangeCalculation, errors, newContext, "oldMemberListForDeltaChangeCalculation", 0);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iSearchFilter, name: "iSearchFilter" }));
			if (_groupProfile)
				t.push(_groupProfile);
			if (_oldMemberListForDeltaChangeCalculation)
				t.push(_oldMemberListForDeltaChangeCalculation);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetGroupProfileArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetGroupProfileArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iSearchFilter", "Integer", errors, newContext);
			const _groupprofile = ENetUC_Admin_Converter.AsnGroupProfile_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "groupProfile"), errors, newContext, "groupProfile");
			if (_groupprofile)
				t.groupProfile = _groupprofile;
			t.oldMemberListForDeltaChangeCalculation = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "oldMemberListForDeltaChangeCalculation"), errors, newContext, "oldMemberListForDeltaChangeCalculation", true);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetGroupProfileResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetGroupProfileResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetGroupProfileResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetGroupProfileResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetGroupProfileResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetGroupProfileResult";
		TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetGroupProfileResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetGroupProfileResult");

		let t: ENetUC_Mgmt.AsnMgmtSetGroupProfileResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetGroupProfileResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetGroupProfileResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetGroupProfileResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetGroupProfileResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetGroupProfileResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bSuccess", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bSuccess, name: "bSuccess" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetGroupProfileResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetGroupProfileResult");

		let t: ENetUC_Mgmt.AsnMgmtSetGroupProfileResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetGroupProfileResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetGroupProfileResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bSuccess", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetGroupProfileResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRemoveUserProfileEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveUserProfileEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRemoveUserProfileEventArgument";
		TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRemoveUserProfileEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveUserProfileEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveUserProfileEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRemoveUserProfileEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveUserProfileEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUserName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUserName, name: "u8sUserName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveUserProfileEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveUserProfileEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRemoveUserProfileEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUserName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveUserProfileEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRemoveGroupProfileEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveGroupProfileEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRemoveGroupProfileEventArgument";
		TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupProfileEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveGroupProfileEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sGroupName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupProfileEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRemoveGroupProfileEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveGroupProfileEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sGroupName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sGroupName, name: "u8sGroupName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupProfileEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveGroupProfileEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRemoveGroupProfileEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sGroupName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveGroupProfileEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtRemoveComputerProfileEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveComputerProfileEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtRemoveComputerProfileEventArgument";
		TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerProfileEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveComputerProfileEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerProfileEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtRemoveComputerProfileEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtRemoveComputerProfileEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sComputerName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerName, name: "u8sComputerName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerProfileEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtRemoveComputerProfileEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtRemoveComputerProfileEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sComputerName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtRemoveComputerProfileEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtChatSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtChatSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtChatSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtChatSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtChatSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtChatSettings";
		TSConverter.fillJSONParam(s, t, "bDeleteChatEntries", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeleteChatEntriesAfterDays", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtChatSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtChatSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtChatSettings");

		let t: ENetUC_Mgmt.AsnMgmtChatSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtChatSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtChatSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bDeleteChatEntries", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeleteChatEntriesAfterDays", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtChatSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtChatSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtChatSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtChatSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bDeleteChatEntries", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iDeleteChatEntriesAfterDays", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bDeleteChatEntries, name: "bDeleteChatEntries" }));
			t.push(new asn1ts.Integer({ value: s.iDeleteChatEntriesAfterDays, name: "iDeleteChatEntriesAfterDays" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtChatSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtChatSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtChatSettings");

		let t: ENetUC_Mgmt.AsnMgmtChatSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtChatSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtChatSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bDeleteChatEntries", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeleteChatEntriesAfterDays", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtChatSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMeshControllerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMeshControllerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMeshControllerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshControllerSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtMeshControllerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtMeshControllerSettings";
		TSConverter.fillJSONParam(s, t, "bMeshEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoAddMeshNodes", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoAddUseTLS", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMeshID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMeshPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMeshNodeID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtMeshControllerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshControllerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshControllerSettings");

		let t: ENetUC_Mgmt.AsnMgmtMeshControllerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMeshControllerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtMeshControllerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bMeshEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoAddMeshNodes", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoAddUseTLS", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMeshID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMeshPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMeshNodeID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshControllerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMeshControllerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMeshControllerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshControllerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bMeshEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAutoAddMeshNodes", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAutoAddUseTLS", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sMeshID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMeshPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMeshNodeID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bMeshEnabled, name: "bMeshEnabled" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoAddMeshNodes, name: "bAutoAddMeshNodes" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoAddUseTLS, name: "bAutoAddUseTLS" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMeshID, name: "u8sMeshID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMeshPassword, name: "u8sMeshPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMeshNodeID, name: "u8sMeshNodeID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshControllerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshControllerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshControllerSettings");

		let t: ENetUC_Mgmt.AsnMgmtMeshControllerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMeshControllerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtMeshControllerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bMeshEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoAddMeshNodes", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoAddUseTLS", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMeshID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMeshPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMeshNodeID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshControllerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMeshNodeConfig_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMeshNodeConfig, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMeshNodeConfig & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeConfig");

		const t = {} as ENetUC_Mgmt.AsnMgmtMeshNodeConfig & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtMeshNodeConfig";
		TSConverter.fillJSONParam(s, t, "u8sComputerNameFQDN", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bForceTLS", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMeshNodeID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsDynamicMode", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNodeEnabled", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfig"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeConfig | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeConfig");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeConfig | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMeshNodeConfig>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtMeshNodeConfig["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sComputerNameFQDN", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bForceTLS", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMeshNodeID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsDynamicMode", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNodeEnabled", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfig"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMeshNodeConfig | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMeshNodeConfig";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeConfig");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sComputerNameFQDN", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "bForceTLS", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sMeshNodeID", "string", errors, newContext);
		TSConverter.validateParam(s, "bIsDynamicMode", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bNodeEnabled", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerNameFQDN, name: "u8sComputerNameFQDN" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Boolean({ value: s.bForceTLS, name: "bForceTLS" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMeshNodeID, name: "u8sMeshNodeID" }));
			t.push(new asn1ts.Boolean({ value: s.bIsDynamicMode, name: "bIsDynamicMode" }));
			t.push(new asn1ts.Boolean({ value: s.bNodeEnabled, name: "bNodeEnabled" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfig"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeConfig | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeConfig");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeConfig | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMeshNodeConfig.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtMeshNodeConfig["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sComputerNameFQDN", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bForceTLS", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMeshNodeID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsDynamicMode", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNodeEnabled", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfig"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMeshNodeStatusTLS_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeStatusTLS");

		const t = {} as ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtMeshNodeStatusTLS";
		TSConverter.fillJSONParam(s, t, "bTLS", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTLSProtocol", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCertChainVerifyReturn", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIssuedTo", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIssuer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timValidFrom", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timValidTo", "Date", errors, newContext);
		const _u8sListAlternateNames = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sListAlternateNames, errors, newContext, "u8sListAlternateNames");
		if (_u8sListAlternateNames)
			t.u8sListAlternateNames = _u8sListAlternateNames;

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatusTLS"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeStatusTLS");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bTLS", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTLSProtocol", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCertChainVerifyReturn", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIssuedTo", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIssuer", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "timValidFrom", "string", errors, newContext, false))
				t.timValidFrom = new Date(s.timValidFrom);
			if (TSConverter.validateParam(s, "timValidTo", "string", errors, newContext, false))
				t.timValidTo = new Date(s.timValidTo);
			const _u8slistalternatenames = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sListAlternateNames, errors, newContext, "u8sListAlternateNames", false);
			if (_u8slistalternatenames)
				t.u8sListAlternateNames = _u8slistalternatenames;
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatusTLS"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMeshNodeStatusTLS";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeStatusTLS");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bTLS", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iTLSProtocol", "number", errors, newContext);
		TSConverter.validateParam(s, "iCertChainVerifyReturn", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sIssuedTo", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sIssuer", "string", errors, newContext);
		TSConverter.validateParam(s, "timValidFrom", "Date", errors, newContext);
		TSConverter.validateParam(s, "timValidTo", "Date", errors, newContext);
		const _u8sListAlternateNames = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sListAlternateNames, errors, newContext, "u8sListAlternateNames");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bTLS, name: "bTLS" }));
			t.push(new asn1ts.Integer({ value: s.iTLSProtocol, name: "iTLSProtocol" }));
			t.push(new asn1ts.Integer({ value: s.iCertChainVerifyReturn, name: "iCertChainVerifyReturn" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIssuedTo, name: "u8sIssuedTo" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIssuer, name: "u8sIssuer" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timValidFrom), name: "timValidFrom" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timValidTo), name: "timValidTo" }));
			if (_u8sListAlternateNames)
				t.push(_u8sListAlternateNames);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatusTLS"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeStatusTLS");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtMeshNodeStatusTLS["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bTLS", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTLSProtocol", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCertChainVerifyReturn", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIssuedTo", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIssuer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timValidFrom", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timValidTo", "AsnSystemTime", errors, newContext);
			const _u8slistalternatenames = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sListAlternateNames"), errors, newContext, "u8sListAlternateNames");
			if (_u8slistalternatenames)
				t.u8sListAlternateNames = _u8slistalternatenames;
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatusTLS"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSubscribeConnectionInformationChangesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSubscribeConnectionInformationChangesArgument";
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSubscribeConnectionInformationChangesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSubscribeConnectionInformationChangesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSubscribeConnectionInformationChangesResult";

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesResult");

		let t: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSubscribeConnectionInformationChangesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSubscribeConnectionInformationChangesResult");

		let t: ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSubscribeConnectionInformationChangesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSubscribeConnectionInformationChangesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUnSubscribeConnectionInformationChangesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUnSubscribeConnectionInformationChangesArgument";
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesArgument");

		let t: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUnSubscribeConnectionInformationChangesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesArgument");

		let t: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUnSubscribeConnectionInformationChangesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUnSubscribeConnectionInformationChangesResult";

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesResult");

		let t: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUnSubscribeConnectionInformationChangesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUnSubscribeConnectionInformationChangesResult");

		let t: ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUnSubscribeConnectionInformationChangesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtUnSubscribeConnectionInformationChangesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDisconnectClientArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDisconnectClientArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDisconnectClientArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDisconnectClientArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtDisconnectClientArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDisconnectClientArgument";
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sConnectionID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDisconnectClientArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDisconnectClientArgument");

		let t: ENetUC_Mgmt.AsnMgmtDisconnectClientArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDisconnectClientArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDisconnectClientArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sConnectionID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDisconnectClientArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDisconnectClientArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDisconnectClientArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sConnectionID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sConnectionID, name: "u8sConnectionID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDisconnectClientArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDisconnectClientArgument");

		let t: ENetUC_Mgmt.AsnMgmtDisconnectClientArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDisconnectClientArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDisconnectClientArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sConnectionID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDisconnectClientResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDisconnectClientResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDisconnectClientResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDisconnectClientResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtDisconnectClientResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDisconnectClientResult";
		TSConverter.fillJSONParam(s, t, "bResult", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDisconnectClientResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDisconnectClientResult");

		let t: ENetUC_Mgmt.AsnMgmtDisconnectClientResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDisconnectClientResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDisconnectClientResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bResult", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDisconnectClientResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDisconnectClientResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDisconnectClientResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bResult", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bResult, name: "bResult" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDisconnectClientResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDisconnectClientResult");

		let t: ENetUC_Mgmt.AsnMgmtDisconnectClientResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDisconnectClientResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDisconnectClientResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bResult", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDisconnectClientResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGDPREraseArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGDPREraseArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGDPREraseArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPREraseArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGDPREraseArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGDPREraseArgument";
		TSConverter.fillJSONParam(s, t, "u8sSIPAddress", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPREraseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPREraseArgument");

		let t: ENetUC_Mgmt.AsnMgmtGDPREraseArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGDPREraseArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGDPREraseArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sSIPAddress", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGDPREraseArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGDPREraseArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPREraseArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sSIPAddress", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sSIPAddress, name: "u8sSIPAddress" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPREraseArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPREraseArgument");

		let t: ENetUC_Mgmt.AsnMgmtGDPREraseArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGDPREraseArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGDPREraseArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sSIPAddress", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGDPREraseResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGDPREraseResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGDPREraseResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPREraseResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGDPREraseResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGDPREraseResult";

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPREraseResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPREraseResult");

		let t: ENetUC_Mgmt.AsnMgmtGDPREraseResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGDPREraseResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGDPREraseResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGDPREraseResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGDPREraseResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPREraseResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPREraseResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPREraseResult");

		let t: ENetUC_Mgmt.AsnMgmtGDPREraseResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGDPREraseResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGDPREraseResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPREraseResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGDPRFindContactsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPRFindContactsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGDPRFindContactsArgument";
		TSConverter.fillJSONParam(s, t, "u8sFilterText", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPRFindContactsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sFilterText", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGDPRFindContactsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPRFindContactsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sFilterText", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sFilterText, name: "u8sFilterText" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPRFindContactsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGDPRFindContactsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sFilterText", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGDPRFindContactsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPRFindContactsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGDPRFindContactsResult";
		const _contactList = ENetUC_Common_Converter.AsnNetDatabaseContactList_Converter.toJSON(s.contactList, errors, newContext, "contactList");
		if (_contactList)
			t.contactList = _contactList;

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPRFindContactsResult");

		let t: ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _contactlist = ENetUC_Common_Converter.AsnNetDatabaseContactList_Converter.fromJSON(s.contactList, errors, newContext, "contactList", false);
			if (_contactlist)
				t.contactList = _contactlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGDPRFindContactsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGDPRFindContactsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _contactList = ENetUC_Common_Converter.AsnNetDatabaseContactList_Converter.toBER(s.contactList, errors, newContext, "contactList");
		if (!errors.hasNewErrors()) {
			if (_contactList)
				t.push(_contactList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGDPRFindContactsResult");

		let t: ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGDPRFindContactsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _contactlist = ENetUC_Common_Converter.AsnNetDatabaseContactList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "contactList"), errors, newContext, "contactList");
			if (_contactlist)
				t.contactList = _contactlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGDPRFindContactsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUpdateDatabaseProgressArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpdateDatabaseProgressArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUpdateDatabaseProgressArgument";
		TSConverter.fillJSONParam(s, t, "iProgressMax", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProgressCur", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUpdateDatabaseProgressArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpdateDatabaseProgressArgument");

		let t: ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iProgressMax", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProgressCur", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpdateDatabaseProgressArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUpdateDatabaseProgressArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUpdateDatabaseProgressArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iProgressMax", "number", errors, newContext);
		TSConverter.validateParam(s, "iProgressCur", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iProgressMax, name: "iProgressMax" }));
			t.push(new asn1ts.Integer({ value: s.iProgressCur, name: "iProgressCur" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUpdateDatabaseProgressArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUpdateDatabaseProgressArgument");

		let t: ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUpdateDatabaseProgressArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iProgressMax", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProgressCur", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUpdateDatabaseProgressArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDatabaseUpdateInProgressArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDatabaseUpdateInProgressArgument";

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressArgument");

		let t: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDatabaseUpdateInProgressArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressArgument");

		let t: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDatabaseUpdateInProgressResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDatabaseUpdateInProgressResult";
		TSConverter.fillJSONParam(s, t, "bResult", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressResult");

		let t: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bResult", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDatabaseUpdateInProgressResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bResult", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bResult, name: "bResult" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDatabaseUpdateInProgressResult");

		let t: ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDatabaseUpdateInProgressResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bResult", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDatabaseUpdateInProgressResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetBinaryTransferSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetBinaryTransferSettingsArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetBinaryTransferSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetBinaryTransferSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetBinaryTransferSettingsResult";
		const _storageSettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.toJSON(s.storageSettings, errors, newContext, "storageSettings");
		if (_storageSettings)
			t.storageSettings = _storageSettings;

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _storagesettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.fromJSON(s.storageSettings, errors, newContext, "storageSettings", false);
			if (_storagesettings)
				t.storageSettings = _storagesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetBinaryTransferSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _storageSettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.toBER(s.storageSettings, errors, newContext, "storageSettings");
		if (!errors.hasNewErrors()) {
			if (_storageSettings)
				t.push(_storageSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetBinaryTransferSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetBinaryTransferSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _storagesettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "storageSettings"), errors, newContext, "storageSettings");
			if (_storagesettings)
				t.storageSettings = _storagesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetBinaryTransferSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetBinaryTransferSettingsArgument";
		const _storageSettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.toJSON(s.storageSettings, errors, newContext, "storageSettings");
		if (_storageSettings)
			t.storageSettings = _storageSettings;

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _storagesettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.fromJSON(s.storageSettings, errors, newContext, "storageSettings", false);
			if (_storagesettings)
				t.storageSettings = _storagesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetBinaryTransferSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _storageSettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.toBER(s.storageSettings, errors, newContext, "storageSettings");
		if (!errors.hasNewErrors()) {
			if (_storageSettings)
				t.push(_storageSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _storagesettings = ENetUC_BinaryTransfer_Converter.AsnBinaryTransferStorageSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "storageSettings"), errors, newContext, "storageSettings");
			if (_storagesettings)
				t.storageSettings = _storagesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetBinaryTransferSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetBinaryTransferSettingsResult";
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (_u8slistComputers)
			t.u8slistComputers = _u8slistComputers;

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistComputers, errors, newContext, "u8slistComputers", false);
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetBinaryTransferSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _u8slistComputers = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistComputers, errors, newContext, "u8slistComputers");
		if (!errors.hasNewErrors()) {
			if (_u8slistComputers)
				t.push(_u8slistComputers);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetBinaryTransferSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetBinaryTransferSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _u8slistcomputers = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistComputers"), errors, newContext, "u8slistComputers");
			if (_u8slistcomputers)
				t.u8slistComputers = _u8slistcomputers;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConnectionOption_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConnectionOption, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConnectionOption & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConnectionOption");

		const t = {} as ENetUC_Mgmt.AsnMgmtConnectionOption & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConnectionOption";
		TSConverter.fillJSONParam(s, t, "u8sHostOrIP", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsFromDNSRecords", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDNSWeight", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtConnectionOption"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConnectionOption | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConnectionOption");

		let t: ENetUC_Mgmt.AsnMgmtConnectionOption | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConnectionOption>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConnectionOption["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sHostOrIP", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsFromDNSRecords", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDNSWeight", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionOption"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConnectionOption | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConnectionOption";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConnectionOption");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sHostOrIP", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "bIsFromDNSRecords", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iDNSWeight", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sHostOrIP, name: "u8sHostOrIP" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Boolean({ value: s.bIsFromDNSRecords, name: "bIsFromDNSRecords" }));
			t.push(new asn1ts.Integer({ value: s.iDNSWeight, name: "iDNSWeight" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionOption"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConnectionOption | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConnectionOption");

		let t: ENetUC_Mgmt.AsnMgmtConnectionOption | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConnectionOption.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConnectionOption["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sHostOrIP", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsFromDNSRecords", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDNSWeight", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionOption"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConnectionOptionsDNSArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConnectionOptionsDNSArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConnectionOptionsDNSArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConfigurationManagerSettings";
		TSConverter.fillJSONParam(s, t, "bRemoteDBUse", "boolean", errors, newContext);
		const _mapRemoteDBProperties = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.mapRemoteDBProperties, errors, newContext, "mapRemoteDBProperties");
		if (_mapRemoteDBProperties)
			t.mapRemoteDBProperties = _mapRemoteDBProperties;
		TSConverter.fillJSONParam(s, t, "u8sHomeServerName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sHomeServerVersion", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bRemoteDBUse", "boolean", errors, newContext, false);
			const _mapremotedbproperties = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.mapRemoteDBProperties, errors, newContext, "mapRemoteDBProperties", false);
			if (_mapremotedbproperties)
				t.mapRemoteDBProperties = _mapremotedbproperties;
			TSConverter.fillJSONParam(s, t, "u8sHomeServerName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sHomeServerVersion", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bRemoteDBUse", "boolean", errors, newContext);
		const _mapRemoteDBProperties = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.mapRemoteDBProperties, errors, newContext, "mapRemoteDBProperties");
		TSConverter.validateParam(s, "u8sHomeServerName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sHomeServerVersion", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bRemoteDBUse, name: "bRemoteDBUse" }));
			if (_mapRemoteDBProperties)
				t.push(_mapRemoteDBProperties);
			t.push(new asn1ts.Utf8String({ value: s.u8sHomeServerName, name: "u8sHomeServerName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sHomeServerVersion, name: "u8sHomeServerVersion" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bRemoteDBUse", "Boolean", errors, newContext);
			const _mapremotedbproperties = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapRemoteDBProperties"), errors, newContext, "mapRemoteDBProperties");
			if (_mapremotedbproperties)
				t.mapRemoteDBProperties = _mapremotedbproperties;
			TSConverter.fillASN1Param(s, t, "u8sHomeServerName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sHomeServerVersion", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConfigurationManagerSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConfigurationManagerSettingsArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConfigurationManagerSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetConfigurationManagerSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetConfigurationManagerSettingsResult";

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetConfigurationManagerSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtDirectPersistDeleteSettingArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDirectPersistDeleteSettingArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtDirectPersistDeleteSettingArgument";
		TSConverter.fillJSONParam(s, t, "key", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "objectName", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtDirectPersistDeleteSettingArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDirectPersistDeleteSettingArgument");

		let t: ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "key", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "objectName", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtDirectPersistDeleteSettingArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtDirectPersistDeleteSettingArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtDirectPersistDeleteSettingArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "key", "string", errors, newContext);
		TSConverter.validateParam(s, "objectName", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.key, name: "key" }));
			t.push(new asn1ts.Utf8String({ value: s.objectName, name: "objectName" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtDirectPersistDeleteSettingArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtDirectPersistDeleteSettingArgument");

		let t: ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtDirectPersistDeleteSettingArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "key", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "objectName", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtDirectPersistDeleteSettingArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTestConfigurationManagerDBArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTestConfigurationManagerDBArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTestConfigurationManagerDBArgument";
		if (s.mapRemoteDBProperties) {
			const _mapRemoteDBProperties = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.mapRemoteDBProperties, errors, newContext, "mapRemoteDBProperties");
			if (_mapRemoteDBProperties)
				t.mapRemoteDBProperties = _mapRemoteDBProperties;
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTestConfigurationManagerDBArgument");

		let t: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _mapremotedbproperties = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.mapRemoteDBProperties, errors, newContext, "mapRemoteDBProperties", true);
			if (_mapremotedbproperties)
				t.mapRemoteDBProperties = _mapremotedbproperties;
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTestConfigurationManagerDBArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTestConfigurationManagerDBArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _mapRemoteDBProperties = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.mapRemoteDBProperties, errors, newContext, "mapRemoteDBProperties", 0);
		if (!errors.hasNewErrors()) {
			if (_mapRemoteDBProperties)
				t.push(_mapRemoteDBProperties);
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTestConfigurationManagerDBArgument");

		let t: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			t.mapRemoteDBProperties = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapRemoteDBProperties"), errors, newContext, "mapRemoteDBProperties", true);
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTestConfigurationManagerDBResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTestConfigurationManagerDBResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTestConfigurationManagerDBResult";
		TSConverter.fillJSONParam(s, t, "bFilledWithConfigurationSettings", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTestConfigurationManagerDBResult");

		let t: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bFilledWithConfigurationSettings", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTestConfigurationManagerDBResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTestConfigurationManagerDBResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bFilledWithConfigurationSettings", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bFilledWithConfigurationSettings, name: "bFilledWithConfigurationSettings" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTestConfigurationManagerDBResult");

		let t: ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTestConfigurationManagerDBResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bFilledWithConfigurationSettings", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtTestConfigurationManagerDBResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserManagerConnectionStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerConnectionStatus");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserManagerConnectionStatus";
		TSConverter.fillJSONParam(s, t, "bADConnected", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerConnectionStatus");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bADConnected", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserManagerConnectionStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerConnectionStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bADConnected", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bADConnected, name: "bADConnected" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerConnectionStatus");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bADConnected", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserManagerConnectionStatusArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserManagerConnectionStatusArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserManagerConnectionStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientPersistenceDeleteArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceDeleteArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientPersistenceDeleteArgument";
		TSConverter.fillJSONParam(s, t, "u8sItemStore", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sItemStoreID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceDeleteArgument");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sItemStore", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sItemStoreID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientPersistenceDeleteArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceDeleteArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sItemStore", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sItemStoreID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sItemStore, name: "u8sItemStore" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sItemStoreID, name: "u8sItemStoreID" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceDeleteArgument");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sItemStore", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sItemStoreID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientPersistenceDeleteResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceDeleteResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientPersistenceDeleteResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceDeleteResult");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientPersistenceDeleteResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceDeleteResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceDeleteResult");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceDeleteResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceDeleteResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientPersistenceCreateArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceCreateArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientPersistenceCreateArgument";
		TSConverter.fillJSONParam(s, t, "u8sItemStore", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sItemStoreID", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "data", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceCreateArgument");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sItemStore", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sItemStoreID", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "data", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientPersistenceCreateArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceCreateArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sItemStore", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sItemStoreID", "string", errors, newContext, true);
		TSConverter.validateParam(s, "data", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sItemStore, name: "u8sItemStore" }));
			if (s.u8sItemStoreID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sItemStoreID, name: "u8sItemStoreID", idBlock: { optionalID: 0 } }));
			t.push(new asn1ts.Utf8String({ value: s.data, name: "data" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceCreateArgument");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceCreateArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sItemStore", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sItemStoreID", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "data", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientPersistenceCreateResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceCreateResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientPersistenceCreateResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceCreateResult");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientPersistenceCreateResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientPersistenceCreateResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientPersistenceCreateResult");

		let t: ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientPersistenceCreateResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientPersistenceCreateResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerStatus");

		const t = {} as ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConfigurationManagerStatus";
		TSConverter.fillJSONParam(s, t, "bRemoteDBEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRemoteDBConnected", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRemoteDBInitiallyFullSynced", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRemoteDBEmpty", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sRemoteDBLastError", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerStatus");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bRemoteDBEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRemoteDBConnected", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRemoteDBInitiallyFullSynced", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRemoteDBEmpty", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sRemoteDBLastError", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bRemoteDBEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bRemoteDBConnected", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bRemoteDBInitiallyFullSynced", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bRemoteDBEmpty", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sRemoteDBLastError", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bRemoteDBEnabled, name: "bRemoteDBEnabled" }));
			t.push(new asn1ts.Boolean({ value: s.bRemoteDBConnected, name: "bRemoteDBConnected" }));
			t.push(new asn1ts.Boolean({ value: s.bRemoteDBInitiallyFullSynced, name: "bRemoteDBInitiallyFullSynced" }));
			t.push(new asn1ts.Boolean({ value: s.bRemoteDBEmpty, name: "bRemoteDBEmpty" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sRemoteDBLastError, name: "u8sRemoteDBLastError" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerStatus");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bRemoteDBEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRemoteDBConnected", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRemoteDBInitiallyFullSynced", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRemoteDBEmpty", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sRemoteDBLastError", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConfigurationManagerStatusArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConfigurationManagerStatusArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConfigurationManagerStatusArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerServerListItem_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerServerListItem");

		const t = {} as ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConfigurationManagerServerListItem";
		TSConverter.fillJSONParam(s, t, "serverListItem", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRedisHeartbeat", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListItem"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerServerListItem");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "serverListItem", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRedisHeartbeat", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListItem"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerServerListItem";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerServerListItem");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "serverListItem", "string", errors, newContext);
		TSConverter.validateParam(s, "bRedisHeartbeat", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.serverListItem, name: "serverListItem" }));
			t.push(new asn1ts.Boolean({ value: s.bRedisHeartbeat, name: "bRedisHeartbeat" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListItem"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerServerListItem");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListItem["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "serverListItem", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRedisHeartbeat", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListItem"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtCleanupBinaryTransferFilesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtCleanupBinaryTransferFilesArgument";
		TSConverter.fillJSONParam(s, t, "iFileAgeDays", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesArgument");

		let t: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iFileAgeDays", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtCleanupBinaryTransferFilesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iFileAgeDays", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iFileAgeDays, name: "iFileAgeDays" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesArgument");

		let t: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iFileAgeDays", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtCleanupBinaryTransferFilesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtCleanupBinaryTransferFilesResult";
		TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCountRemoved", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesResult");

		let t: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCountRemoved", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtCleanupBinaryTransferFilesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bSuccess", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iCountRemoved", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bSuccess, name: "bSuccess" }));
			t.push(new asn1ts.Integer({ value: s.iCountRemoved, name: "iCountRemoved" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCleanupBinaryTransferFilesResult");

		let t: ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtCleanupBinaryTransferFilesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bSuccess", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCountRemoved", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtCleanupBinaryTransferFilesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetPresenceDomainArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPresenceDomainArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetPresenceDomainArgument";
		TSConverter.fillJSONParam(s, t, "u8sPresenceDomain", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPresenceDomainArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sPresenceDomain", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetPresenceDomainArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPresenceDomainArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sPresenceDomain", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sPresenceDomain, name: "u8sPresenceDomain" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPresenceDomainArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetPresenceDomainArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sPresenceDomain", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetPresenceDomainResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPresenceDomainResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetPresenceDomainResult";
		TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext);
		const _u8slistOtherDatacenterServersRunning = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistOtherDatacenterServersRunning, errors, newContext, "u8slistOtherDatacenterServersRunning");
		if (_u8slistOtherDatacenterServersRunning)
			t.u8slistOtherDatacenterServersRunning = _u8slistOtherDatacenterServersRunning;

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPresenceDomainResult");

		let t: ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iResult", "number", errors, newContext, false);
			const _u8slistotherdatacenterserversrunning = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistOtherDatacenterServersRunning, errors, newContext, "u8slistOtherDatacenterServersRunning", false);
			if (_u8slistotherdatacenterserversrunning)
				t.u8slistOtherDatacenterServersRunning = _u8slistotherdatacenterserversrunning;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetPresenceDomainResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPresenceDomainResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iResult", "number", errors, newContext);
		const _u8slistOtherDatacenterServersRunning = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistOtherDatacenterServersRunning, errors, newContext, "u8slistOtherDatacenterServersRunning");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iResult, name: "iResult" }));
			if (_u8slistOtherDatacenterServersRunning)
				t.push(_u8slistOtherDatacenterServersRunning);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPresenceDomainResult");

		let t: ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetPresenceDomainResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iResult", "Integer", errors, newContext);
			const _u8slistotherdatacenterserversrunning = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistOtherDatacenterServersRunning"), errors, newContext, "u8slistOtherDatacenterServersRunning");
			if (_u8slistotherdatacenterserversrunning)
				t.u8slistOtherDatacenterServersRunning = _u8slistotherdatacenterserversrunning;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPresenceDomainResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAdminUserManagerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserManagerSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAdminUserManagerSettings";
		TSConverter.fillJSONParam(s, t, "iAdminUserManagerType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseUserManagerLDAPSettings", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sHost", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iForceLDAPS", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBaseDNUsers", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtAdminUserManagerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iAdminUserManagerType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseUserManagerLDAPSettings", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sHost", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iForceLDAPS", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBaseDNUsers", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserManagerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAdminUserManagerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserManagerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iAdminUserManagerType", "number", errors, newContext);
		TSConverter.validateParam(s, "bUseUserManagerLDAPSettings", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sHost", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iForceLDAPS", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sBaseDNUsers", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iAdminUserManagerType, name: "iAdminUserManagerType" }));
			t.push(new asn1ts.Boolean({ value: s.bUseUserManagerLDAPSettings, name: "bUseUserManagerLDAPSettings" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sHost, name: "u8sHost" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPassword, name: "u8sPassword" }));
			t.push(new asn1ts.Integer({ value: s.iForceLDAPS, name: "iForceLDAPS" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBaseDNUsers, name: "u8sBaseDNUsers" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserManagerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserManagerSettings");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserManagerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iAdminUserManagerType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseUserManagerLDAPSettings", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sHost", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iForceLDAPS", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBaseDNUsers", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserManagerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAdminUserManagerSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAdminUserManagerSettingsArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAdminUserManagerSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetAdminUserManagerSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetAdminUserManagerSettingsResult";
		TSConverter.fillJSONParam(s, t, "iLastErrorCode", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iLastErrorCode", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetAdminUserManagerSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iLastErrorCode", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iLastErrorCode, name: "iLastErrorCode" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iLastErrorCode", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAdminUserRightStateReadWrite_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRightStateReadWrite");

		const t = {} as ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAdminUserRightStateReadWrite";
		TSConverter.fillJSONParam(s, t, "bWrite", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateReadWrite"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRightStateReadWrite");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bWrite", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateReadWrite"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAdminUserRightStateReadWrite";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRightStateReadWrite");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bWrite", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bWrite, name: "bWrite" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateReadWrite"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRightStateReadWrite");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRightStateReadWrite["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bWrite", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateReadWrite"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAdminUserRightStateExecute_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRightStateExecute");

		const t = {} as ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAdminUserRightStateExecute";

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateExecute"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRightStateExecute");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateExecute"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAdminUserRightStateExecute";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRightStateExecute");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateExecute"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRightStateExecute");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRightStateExecute["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightStateExecute"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAdminUserRightsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserRightsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAdminUserRightsArgument";

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserRightsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAdminUserRightsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserRightsArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserRightsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserRightsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEntraIdSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEntraIdSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEntraIdSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEntraIdSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtEntraIdSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEntraIdSettings";
		TSConverter.fillJSONParam(s, t, "u8sClientId", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sClientSecret", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTenantId", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtEntraIdSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEntraIdSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEntraIdSettings");

		let t: ENetUC_Mgmt.AsnMgmtEntraIdSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEntraIdSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEntraIdSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sClientId", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sClientSecret", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTenantId", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtEntraIdSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEntraIdSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEntraIdSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEntraIdSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sClientId", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sClientSecret", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTenantId", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sClientId, name: "u8sClientId" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sClientSecret, name: "u8sClientSecret" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTenantId, name: "u8sTenantId" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtEntraIdSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEntraIdSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEntraIdSettings");

		let t: ENetUC_Mgmt.AsnMgmtEntraIdSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEntraIdSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEntraIdSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sClientId", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sClientSecret", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTenantId", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtEntraIdSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnClientConnectionDescriptions_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnClientConnectionDescriptions, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnClientConnectionDescriptions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnClientConnectionDescriptions");

		const t = [] as ENetUC_Mgmt.AsnClientConnectionDescriptions;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnClientConnectionDescription_Converter.toJSON(se, errors, newContext, "AsnClientConnectionDescription");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnClientConnectionDescriptions"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnClientConnectionDescriptions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnClientConnectionDescriptions");

		let t: ENetUC_Mgmt.AsnClientConnectionDescriptions | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnClientConnectionDescriptions>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnClientConnectionDescriptions();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnClientConnectionDescription_Converter.fromJSON(se, errors, newContext, "AsnClientConnectionDescription", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnClientConnectionDescriptions"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnClientConnectionDescriptions | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnClientConnectionDescriptions";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnClientConnectionDescriptions");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnClientConnectionDescription_Converter.toBER(s[id], errors, newContext, "AsnClientConnectionDescription");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnClientConnectionDescriptions"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnClientConnectionDescriptions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnClientConnectionDescriptions");

		let t: ENetUC_Mgmt.AsnClientConnectionDescriptions | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnClientConnectionDescriptions.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnClientConnectionDescriptions();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnClientConnectionDescription_Converter.fromBER(se, errors, newContext, "AsnClientConnectionDescription", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnClientConnectionDescriptions"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientConnectionInformation_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientConnectionInformation, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientConnectionInformation & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientConnectionInformation");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientConnectionInformation & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientConnectionInformation";
		TSConverter.fillJSONParam(s, t, "u8sLastLoginDeviceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timLastLogin", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bOnline", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAVLineIsDND", "boolean", errors, newContext);
		const _connectionDescriptions = AsnClientConnectionDescriptions_Converter.toJSON(s.connectionDescriptions, errors, newContext, "connectionDescriptions");
		if (_connectionDescriptions)
			t.connectionDescriptions = _connectionDescriptions;
		const _clientCapabilities = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2ByIDList_Converter.toJSON(s.clientCapabilities, errors, newContext, "clientCapabilities");
		if (_clientCapabilities)
			t.clientCapabilities = _clientCapabilities;
		const _clientCapabilitiesSum = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2_Converter.toJSON(s.clientCapabilitiesSum, errors, newContext, "clientCapabilitiesSum");
		if (_clientCapabilitiesSum)
			t.clientCapabilitiesSum = _clientCapabilitiesSum;

		if (errors.validateResult(newContext, "AsnMgmtClientConnectionInformation"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientConnectionInformation | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientConnectionInformation");

		let t: ENetUC_Mgmt.AsnMgmtClientConnectionInformation | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientConnectionInformation>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientConnectionInformation["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLastLoginDeviceName", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "timLastLogin", "string", errors, newContext, false))
				t.timLastLogin = new Date(s.timLastLogin);
			TSConverter.fillJSONParam(s, t, "bOnline", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAVLineIsDND", "boolean", errors, newContext, false);
			const _connectiondescriptions = AsnClientConnectionDescriptions_Converter.fromJSON(s.connectionDescriptions, errors, newContext, "connectionDescriptions", false);
			if (_connectiondescriptions)
				t.connectionDescriptions = _connectiondescriptions;
			const _clientcapabilities = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2ByIDList_Converter.fromJSON(s.clientCapabilities, errors, newContext, "clientCapabilities", false);
			if (_clientcapabilities)
				t.clientCapabilities = _clientcapabilities;
			const _clientcapabilitiessum = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2_Converter.fromJSON(s.clientCapabilitiesSum, errors, newContext, "clientCapabilitiesSum", false);
			if (_clientcapabilitiessum)
				t.clientCapabilitiesSum = _clientcapabilitiessum;
		}

		if (errors.validateResult(newContext, "AsnMgmtClientConnectionInformation"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientConnectionInformation | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientConnectionInformation";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientConnectionInformation");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLastLoginDeviceName", "string", errors, newContext);
		TSConverter.validateParam(s, "timLastLogin", "Date", errors, newContext);
		TSConverter.validateParam(s, "bOnline", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAVLineIsDND", "boolean", errors, newContext);
		const _connectionDescriptions = AsnClientConnectionDescriptions_Converter.toBER(s.connectionDescriptions, errors, newContext, "connectionDescriptions");
		const _clientCapabilities = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2ByIDList_Converter.toBER(s.clientCapabilities, errors, newContext, "clientCapabilities");
		const _clientCapabilitiesSum = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2_Converter.toBER(s.clientCapabilitiesSum, errors, newContext, "clientCapabilitiesSum");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLastLoginDeviceName, name: "u8sLastLoginDeviceName" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timLastLogin), name: "timLastLogin" }));
			t.push(new asn1ts.Boolean({ value: s.bOnline, name: "bOnline" }));
			t.push(new asn1ts.Boolean({ value: s.bAVLineIsDND, name: "bAVLineIsDND" }));
			if (_connectionDescriptions)
				t.push(_connectionDescriptions);
			if (_clientCapabilities)
				t.push(_clientCapabilities);
			if (_clientCapabilitiesSum)
				t.push(_clientCapabilitiesSum);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientConnectionInformation"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientConnectionInformation | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientConnectionInformation");

		let t: ENetUC_Mgmt.AsnMgmtClientConnectionInformation | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientConnectionInformation.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientConnectionInformation["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLastLoginDeviceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timLastLogin", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bOnline", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAVLineIsDND", "Boolean", errors, newContext);
			const _connectiondescriptions = AsnClientConnectionDescriptions_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "connectionDescriptions"), errors, newContext, "connectionDescriptions");
			if (_connectiondescriptions)
				t.connectionDescriptions = _connectiondescriptions;
			const _clientcapabilities = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2ByIDList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "clientCapabilities"), errors, newContext, "clientCapabilities");
			if (_clientcapabilities)
				t.clientCapabilities = _clientcapabilities;
			const _clientcapabilitiessum = ENetUC_ClientCapabilities_Converter.AsnClientCapabilitiesV2_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "clientCapabilitiesSum"), errors, newContext, "clientCapabilitiesSum");
			if (_clientcapabilitiessum)
				t.clientCapabilitiesSum = _clientcapabilitiessum;
		}

		if (errors.validateResult(newContext, "AsnMgmtClientConnectionInformation"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserProfileData_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserProfileData, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserProfileData & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileData");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserProfileData & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserProfileData";
		const _userProfile = ENetUC_Admin_Converter.AsnUserProfile_Converter.toJSON(s.userProfile, errors, newContext, "userProfile");
		if (_userProfile)
			t.userProfile = _userProfile;
		const _clientConnectionInfo = AsnMgmtClientConnectionInformation_Converter.toJSON(s.clientConnectionInfo, errors, newContext, "clientConnectionInfo");
		if (_clientConnectionInfo)
			t.clientConnectionInfo = _clientConnectionInfo;

		if (errors.validateResult(newContext, "AsnMgmtUserProfileData"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileData | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileData");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileData | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserProfileData>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserProfileData["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _userprofile = ENetUC_Admin_Converter.AsnUserProfile_Converter.fromJSON(s.userProfile, errors, newContext, "userProfile", false);
			if (_userprofile)
				t.userProfile = _userprofile;
			const _clientconnectioninfo = AsnMgmtClientConnectionInformation_Converter.fromJSON(s.clientConnectionInfo, errors, newContext, "clientConnectionInfo", false);
			if (_clientconnectioninfo)
				t.clientConnectionInfo = _clientconnectioninfo;
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileData"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserProfileData | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserProfileData";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileData");

		// [Print_BER_EncoderSeqDefCode]
		const _userProfile = ENetUC_Admin_Converter.AsnUserProfile_Converter.toBER(s.userProfile, errors, newContext, "userProfile");
		const _clientConnectionInfo = AsnMgmtClientConnectionInformation_Converter.toBER(s.clientConnectionInfo, errors, newContext, "clientConnectionInfo");
		if (!errors.hasNewErrors()) {
			if (_userProfile)
				t.push(_userProfile);
			if (_clientConnectionInfo)
				t.push(_clientConnectionInfo);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileData"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileData | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileData");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileData | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserProfileData.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserProfileData["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _userprofile = ENetUC_Admin_Converter.AsnUserProfile_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "userProfile"), errors, newContext, "userProfile");
			if (_userprofile)
				t.userProfile = _userprofile;
			const _clientconnectioninfo = AsnMgmtClientConnectionInformation_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "clientConnectionInfo"), errors, newContext, "clientConnectionInfo");
			if (_clientconnectioninfo)
				t.clientConnectionInfo = _clientconnectioninfo;
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileData"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserProfileDataList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserProfileDataList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserProfileDataList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileDataList");

		const t = [] as ENetUC_Mgmt.AsnMgmtUserProfileDataList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtUserProfileData_Converter.toJSON(se, errors, newContext, "AsnMgmtUserProfileData");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileDataList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileDataList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileDataList");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileDataList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserProfileDataList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtUserProfileDataList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtUserProfileData_Converter.fromJSON(se, errors, newContext, "AsnMgmtUserProfileData", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileDataList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserProfileDataList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserProfileDataList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserProfileDataList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtUserProfileData_Converter.toBER(s[id], errors, newContext, "AsnMgmtUserProfileData");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtUserProfileDataList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserProfileDataList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserProfileDataList");

		let t: ENetUC_Mgmt.AsnMgmtUserProfileDataList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserProfileDataList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtUserProfileDataList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtUserProfileData_Converter.fromBER(se, errors, newContext, "AsnMgmtUserProfileData", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtUserProfileDataList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserListEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserListEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserListEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserListEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserListEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserListEventArgument";
		const _userProfileDataList = AsnMgmtUserProfileDataList_Converter.toJSON(s.userProfileDataList, errors, newContext, "userProfileDataList");
		if (_userProfileDataList)
			t.userProfileDataList = _userProfileDataList;

		if (errors.validateResult(newContext, "AsnMgmtGetUserListEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserListEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserListEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserListEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserListEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserListEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _userprofiledatalist = AsnMgmtUserProfileDataList_Converter.fromJSON(s.userProfileDataList, errors, newContext, "userProfileDataList", false);
			if (_userprofiledatalist)
				t.userProfileDataList = _userprofiledatalist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserListEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserListEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserListEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserListEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _userProfileDataList = AsnMgmtUserProfileDataList_Converter.toBER(s.userProfileDataList, errors, newContext, "userProfileDataList");
		if (!errors.hasNewErrors()) {
			if (_userProfileDataList)
				t.push(_userProfileDataList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserListEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserListEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserListEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUserListEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserListEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserListEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _userprofiledatalist = AsnMgmtUserProfileDataList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "userProfileDataList"), errors, newContext, "userProfileDataList");
			if (_userprofiledatalist)
				t.userProfileDataList = _userprofiledatalist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserListEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAgentPublicPresenceItemList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAgentPublicPresenceItemList");

		const t = [] as ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtAgentPublicPresenceItem_Converter.toJSON(se, errors, newContext, "AsnMgmtAgentPublicPresenceItem");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItemList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAgentPublicPresenceItemList");

		let t: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtAgentPublicPresenceItem_Converter.fromJSON(se, errors, newContext, "AsnMgmtAgentPublicPresenceItem", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItemList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAgentPublicPresenceItemList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAgentPublicPresenceItemList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtAgentPublicPresenceItem_Converter.toBER(s[id], errors, newContext, "AsnMgmtAgentPublicPresenceItem");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItemList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAgentPublicPresenceItemList");

		let t: ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtAgentPublicPresenceItemList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtAgentPublicPresenceItem_Converter.fromBER(se, errors, newContext, "AsnMgmtAgentPublicPresenceItem", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtAgentPublicPresenceItemList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetGroupAgentPublicPresenceResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetGroupAgentPublicPresenceResult";
		const _listAgentPresence = AsnMgmtAgentPublicPresenceItemList_Converter.toJSON(s.listAgentPresence, errors, newContext, "listAgentPresence");
		if (_listAgentPresence)
			t.listAgentPresence = _listAgentPresence;

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceResult");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listagentpresence = AsnMgmtAgentPublicPresenceItemList_Converter.fromJSON(s.listAgentPresence, errors, newContext, "listAgentPresence", false);
			if (_listagentpresence)
				t.listAgentPresence = _listagentpresence;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetGroupAgentPublicPresenceResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceResult");

		// [Print_BER_EncoderSeqDefCode]
		const _listAgentPresence = AsnMgmtAgentPublicPresenceItemList_Converter.toBER(s.listAgentPresence, errors, newContext, "listAgentPresence");
		if (!errors.hasNewErrors()) {
			if (_listAgentPresence)
				t.push(_listAgentPresence);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetGroupAgentPublicPresenceResult");

		let t: ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetGroupAgentPublicPresenceResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listagentpresence = AsnMgmtAgentPublicPresenceItemList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listAgentPresence"), errors, newContext, "listAgentPresence");
			if (_listagentpresence)
				t.listAgentPresence = _listagentpresence;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetGroupAgentPublicPresenceResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientInstallProfileActionList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfileActionList");

		const t = [] as ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtClientInstallProfileAction_Converter.toJSON(se, errors, newContext, "AsnMgmtClientInstallProfileAction");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileActionList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfileActionList");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtClientInstallProfileAction_Converter.fromJSON(se, errors, newContext, "AsnMgmtClientInstallProfileAction", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileActionList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientInstallProfileActionList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfileActionList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtClientInstallProfileAction_Converter.toBER(s[id], errors, newContext, "AsnMgmtClientInstallProfileAction");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileActionList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfileActionList");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtClientInstallProfileActionList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtClientInstallProfileAction_Converter.fromBER(se, errors, newContext, "AsnMgmtClientInstallProfileAction", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileActionList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientInstallProfileData_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientInstallProfileData, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientInstallProfileData & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfileData");

		const t = {} as ENetUC_Mgmt.AsnMgmtClientInstallProfileData & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtClientInstallProfileData";
		TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProfileName", "string", errors, newContext);
		const _actionList = AsnMgmtClientInstallProfileActionList_Converter.toJSON(s.actionList, errors, newContext, "actionList");
		if (_actionList)
			t.actionList = _actionList;
		TSConverter.fillJSONParam(s, t, "u8sAdminName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAdminPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bFirstInstallation", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLastServiceStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLastSoftwareStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLogData", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileData"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfileData | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfileData");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfileData | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientInstallProfileData>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtClientInstallProfileData["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProfileName", "string", errors, newContext, false);
			const _actionlist = AsnMgmtClientInstallProfileActionList_Converter.fromJSON(s.actionList, errors, newContext, "actionList", false);
			if (_actionlist)
				t.actionList = _actionlist;
			TSConverter.fillJSONParam(s, t, "u8sAdminName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAdminPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bFirstInstallation", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLastServiceStatus", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLastSoftwareStatus", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLogData", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileData"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientInstallProfileData | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientInstallProfileData";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfileData");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sComputerName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProfileName", "string", errors, newContext);
		const _actionList = AsnMgmtClientInstallProfileActionList_Converter.toBER(s.actionList, errors, newContext, "actionList");
		TSConverter.validateParam(s, "u8sAdminName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAdminPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "bFirstInstallation", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iLastServiceStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "iLastSoftwareStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLogData", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerName, name: "u8sComputerName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProfileName, name: "u8sProfileName" }));
			if (_actionList)
				t.push(_actionList);
			t.push(new asn1ts.Utf8String({ value: s.u8sAdminName, name: "u8sAdminName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAdminPassword, name: "u8sAdminPassword" }));
			t.push(new asn1ts.Boolean({ value: s.bFirstInstallation, name: "bFirstInstallation" }));
			t.push(new asn1ts.Integer({ value: s.iLastServiceStatus, name: "iLastServiceStatus" }));
			t.push(new asn1ts.Integer({ value: s.iLastSoftwareStatus, name: "iLastSoftwareStatus" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLogData, name: "u8sLogData" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileData"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfileData | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfileData");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfileData | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientInstallProfileData.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtClientInstallProfileData["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sComputerName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProfileName", "Utf8String", errors, newContext);
			const _actionlist = AsnMgmtClientInstallProfileActionList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "actionList"), errors, newContext, "actionList");
			if (_actionlist)
				t.actionList = _actionlist;
			TSConverter.fillASN1Param(s, t, "u8sAdminName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAdminPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bFirstInstallation", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLastServiceStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLastSoftwareStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLogData", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfileData"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetClientInstallProfileResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetClientInstallProfileResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetClientInstallProfileResult";
		const _profileData = AsnMgmtClientInstallProfileData_Converter.toJSON(s.profileData, errors, newContext, "profileData");
		if (_profileData)
			t.profileData = _profileData;

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetClientInstallProfileResult");

		let t: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _profiledata = AsnMgmtClientInstallProfileData_Converter.fromJSON(s.profileData, errors, newContext, "profileData", false);
			if (_profiledata)
				t.profileData = _profiledata;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetClientInstallProfileResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetClientInstallProfileResult");

		// [Print_BER_EncoderSeqDefCode]
		const _profileData = AsnMgmtClientInstallProfileData_Converter.toBER(s.profileData, errors, newContext, "profileData");
		if (!errors.hasNewErrors()) {
			if (_profileData)
				t.push(_profileData);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetClientInstallProfileResult");

		let t: ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetClientInstallProfileResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _profiledata = AsnMgmtClientInstallProfileData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "profileData"), errors, newContext, "profileData");
			if (_profiledata)
				t.profileData = _profiledata;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetClientInstallProfileResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetClientInstallProfileArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetClientInstallProfileArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetClientInstallProfileArgument";
		TSConverter.fillJSONParam(s, t, "iACICommand", "number", errors, newContext);
		const _profileData = AsnMgmtClientInstallProfileData_Converter.toJSON(s.profileData, errors, newContext, "profileData");
		if (_profileData)
			t.profileData = _profileData;

		if (errors.validateResult(newContext, "AsnMgmtSetClientInstallProfileArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetClientInstallProfileArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iACICommand", "number", errors, newContext, false);
			const _profiledata = AsnMgmtClientInstallProfileData_Converter.fromJSON(s.profileData, errors, newContext, "profileData", false);
			if (_profiledata)
				t.profileData = _profiledata;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetClientInstallProfileArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetClientInstallProfileArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetClientInstallProfileArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iACICommand", "number", errors, newContext);
		const _profileData = AsnMgmtClientInstallProfileData_Converter.toBER(s.profileData, errors, newContext, "profileData");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iACICommand, name: "iACICommand" }));
			if (_profileData)
				t.push(_profileData);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetClientInstallProfileArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetClientInstallProfileArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetClientInstallProfileArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iACICommand", "Integer", errors, newContext);
			const _profiledata = AsnMgmtClientInstallProfileData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "profileData"), errors, newContext, "profileData");
			if (_profiledata)
				t.profileData = _profiledata;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetClientInstallProfileArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtACUFileForUpdateDescriptionList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtACUFileForUpdateDescriptionList");

		const t = [] as ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtACUFileForUpdateDescription_Converter.toJSON(se, errors, newContext, "AsnMgmtACUFileForUpdateDescription");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescriptionList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtACUFileForUpdateDescriptionList");

		let t: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtACUFileForUpdateDescription_Converter.fromJSON(se, errors, newContext, "AsnMgmtACUFileForUpdateDescription", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescriptionList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtACUFileForUpdateDescriptionList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtACUFileForUpdateDescriptionList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtACUFileForUpdateDescription_Converter.toBER(s[id], errors, newContext, "AsnMgmtACUFileForUpdateDescription");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescriptionList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtACUFileForUpdateDescriptionList");

		let t: ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtACUFileForUpdateDescriptionList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtACUFileForUpdateDescription_Converter.fromBER(se, errors, newContext, "AsnMgmtACUFileForUpdateDescription", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtACUFileForUpdateDescriptionList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAvailableUpdatesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableUpdatesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAvailableUpdatesResult";
		const _updateDescriptionList = AsnMgmtACUFileForUpdateDescriptionList_Converter.toJSON(s.updateDescriptionList, errors, newContext, "updateDescriptionList");
		if (_updateDescriptionList)
			t.updateDescriptionList = _updateDescriptionList;

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableUpdatesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableUpdatesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _updatedescriptionlist = AsnMgmtACUFileForUpdateDescriptionList_Converter.fromJSON(s.updateDescriptionList, errors, newContext, "updateDescriptionList", false);
			if (_updatedescriptionlist)
				t.updateDescriptionList = _updatedescriptionlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableUpdatesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAvailableUpdatesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableUpdatesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _updateDescriptionList = AsnMgmtACUFileForUpdateDescriptionList_Converter.toBER(s.updateDescriptionList, errors, newContext, "updateDescriptionList");
		if (!errors.hasNewErrors()) {
			if (_updateDescriptionList)
				t.push(_updateDescriptionList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableUpdatesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableUpdatesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableUpdatesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _updatedescriptionlist = AsnMgmtACUFileForUpdateDescriptionList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "updateDescriptionList"), errors, newContext, "updateDescriptionList");
			if (_updatedescriptionlist)
				t.updateDescriptionList = _updatedescriptionlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableUpdatesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtClientInstallProfilePacketList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfilePacketList");

		const t = [] as ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtClientInstallProfilePacket_Converter.toJSON(se, errors, newContext, "AsnMgmtClientInstallProfilePacket");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacketList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfilePacketList");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtClientInstallProfilePacket_Converter.fromJSON(se, errors, newContext, "AsnMgmtClientInstallProfilePacket", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacketList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtClientInstallProfilePacketList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtClientInstallProfilePacketList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtClientInstallProfilePacket_Converter.toBER(s[id], errors, newContext, "AsnMgmtClientInstallProfilePacket");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacketList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtClientInstallProfilePacketList");

		let t: ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtClientInstallProfilePacketList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtClientInstallProfilePacket_Converter.fromBER(se, errors, newContext, "AsnMgmtClientInstallProfilePacket", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtClientInstallProfilePacketList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSoftwareStatusComputer_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSoftwareStatusComputer");

		const t = {} as ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSoftwareStatusComputer";
		TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUpdateServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProCallVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProCallPacketIdentifier", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timProCallLastLogin", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUpdateServiceVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timUpdateServiceLastLogin", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUpdateServiceStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUpdateServiceWorkingStatus", "number", errors, newContext);
		const _u8slistInstallLogs = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistInstallLogs, errors, newContext, "u8slistInstallLogs");
		if (_u8slistInstallLogs)
			t.u8slistInstallLogs = _u8slistInstallLogs;
		const _installedSoftwareList = AsnMgmtClientInstallProfilePacketList_Converter.toJSON(s.installedSoftwareList, errors, newContext, "installedSoftwareList");
		if (_installedSoftwareList)
			t.installedSoftwareList = _installedSoftwareList;

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputer"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSoftwareStatusComputer");

		let t: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sComputerName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUpdateServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProCallVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProCallPacketIdentifier", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "timProCallLastLogin", "string", errors, newContext, false))
				t.timProCallLastLogin = new Date(s.timProCallLastLogin);
			TSConverter.fillJSONParam(s, t, "u8sUpdateServiceVersion", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "timUpdateServiceLastLogin", "string", errors, newContext, false))
				t.timUpdateServiceLastLogin = new Date(s.timUpdateServiceLastLogin);
			TSConverter.fillJSONParam(s, t, "iUpdateServiceStatus", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUpdateServiceWorkingStatus", "number", errors, newContext, false);
			const _u8slistinstalllogs = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistInstallLogs, errors, newContext, "u8slistInstallLogs", false);
			if (_u8slistinstalllogs)
				t.u8slistInstallLogs = _u8slistinstalllogs;
			const _installedsoftwarelist = AsnMgmtClientInstallProfilePacketList_Converter.fromJSON(s.installedSoftwareList, errors, newContext, "installedSoftwareList", false);
			if (_installedsoftwarelist)
				t.installedSoftwareList = _installedsoftwarelist;
		}

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputer"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSoftwareStatusComputer";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSoftwareStatusComputer");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sComputerName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUpdateServer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProCallVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProCallPacketIdentifier", "string", errors, newContext);
		TSConverter.validateParam(s, "timProCallLastLogin", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sUpdateServiceVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "timUpdateServiceLastLogin", "Date", errors, newContext);
		TSConverter.validateParam(s, "iUpdateServiceStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "iUpdateServiceWorkingStatus", "number", errors, newContext);
		const _u8slistInstallLogs = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistInstallLogs, errors, newContext, "u8slistInstallLogs");
		const _installedSoftwareList = AsnMgmtClientInstallProfilePacketList_Converter.toBER(s.installedSoftwareList, errors, newContext, "installedSoftwareList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerName, name: "u8sComputerName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUpdateServer, name: "u8sUpdateServer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProCallVersion, name: "u8sProCallVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProCallPacketIdentifier, name: "u8sProCallPacketIdentifier" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timProCallLastLogin), name: "timProCallLastLogin" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUpdateServiceVersion, name: "u8sUpdateServiceVersion" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timUpdateServiceLastLogin), name: "timUpdateServiceLastLogin" }));
			t.push(new asn1ts.Integer({ value: s.iUpdateServiceStatus, name: "iUpdateServiceStatus" }));
			t.push(new asn1ts.Integer({ value: s.iUpdateServiceWorkingStatus, name: "iUpdateServiceWorkingStatus" }));
			if (_u8slistInstallLogs)
				t.push(_u8slistInstallLogs);
			if (_installedSoftwareList)
				t.push(_installedSoftwareList);
		}

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputer"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSoftwareStatusComputer");

		let t: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSoftwareStatusComputer["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sComputerName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUpdateServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProCallVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProCallPacketIdentifier", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timProCallLastLogin", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUpdateServiceVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timUpdateServiceLastLogin", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUpdateServiceStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUpdateServiceWorkingStatus", "Integer", errors, newContext);
			const _u8slistinstalllogs = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistInstallLogs"), errors, newContext, "u8slistInstallLogs");
			if (_u8slistinstalllogs)
				t.u8slistInstallLogs = _u8slistinstalllogs;
			const _installedsoftwarelist = AsnMgmtClientInstallProfilePacketList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "installedSoftwareList"), errors, newContext, "installedSoftwareList");
			if (_installedsoftwarelist)
				t.installedSoftwareList = _installedsoftwarelist;
		}

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputer"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSoftwareStatusComputerChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSoftwareStatusComputerChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSoftwareStatusComputerChangedArgument";
		const _status = AsnMgmtSoftwareStatusComputer_Converter.toJSON(s.status, errors, newContext, "status");
		if (_status)
			t.status = _status;

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputerChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSoftwareStatusComputerChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _status = AsnMgmtSoftwareStatusComputer_Converter.fromJSON(s.status, errors, newContext, "status", false);
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputerChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSoftwareStatusComputerChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSoftwareStatusComputerChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _status = AsnMgmtSoftwareStatusComputer_Converter.toBER(s.status, errors, newContext, "status");
		if (!errors.hasNewErrors()) {
			if (_status)
				t.push(_status);
		}

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputerChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSoftwareStatusComputerChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSoftwareStatusComputerChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _status = AsnMgmtSoftwareStatusComputer_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "status"), errors, newContext, "status");
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtSoftwareStatusComputerChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLineStatusList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLineStatusList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLineStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineStatusList");

		const t = [] as ENetUC_Mgmt.AsnMgmtLineStatusList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtLineStatus_Converter.toJSON(se, errors, newContext, "AsnMgmtLineStatus");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStatusList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineStatusList");

		let t: ENetUC_Mgmt.AsnMgmtLineStatusList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLineStatusList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtLineStatusList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtLineStatus_Converter.fromJSON(se, errors, newContext, "AsnMgmtLineStatus", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStatusList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLineStatusList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLineStatusList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineStatusList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtLineStatus_Converter.toBER(s[id], errors, newContext, "AsnMgmtLineStatus");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtLineStatusList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineStatusList");

		let t: ENetUC_Mgmt.AsnMgmtLineStatusList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLineStatusList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtLineStatusList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtLineStatus_Converter.fromBER(se, errors, newContext, "AsnMgmtLineStatus", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStatusList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLineStateChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLineStateChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLineStateChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineStateChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtLineStateChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLineStateChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOpenState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNumCalls", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSipResponseCode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sReasonPhrase", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEffectiveHomeServer", "string", errors, newContext, true);
		if (s.lineStatusList) {
			const _lineStatusList = AsnMgmtLineStatusList_Converter.toJSON(s.lineStatusList, errors, newContext, "lineStatusList");
			if (_lineStatusList)
				t.lineStatusList = _lineStatusList;
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStateChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineStateChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineStateChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtLineStateChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLineStateChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLineStateChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOpenState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNumCalls", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSipResponseCode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sReasonPhrase", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEffectiveHomeServer", "string", errors, newContext, true);
			const _linestatuslist = AsnMgmtLineStatusList_Converter.fromJSON(s.lineStatusList, errors, newContext, "lineStatusList", true);
			if (_linestatuslist)
				t.lineStatusList = _linestatuslist;
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStateChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLineStateChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLineStateChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLineStateChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		TSConverter.validateParam(s, "iOpenState", "number", errors, newContext);
		TSConverter.validateParam(s, "iNumCalls", "number", errors, newContext);
		TSConverter.validateParam(s, "iSipResponseCode", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sReasonPhrase", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEffectiveHomeServer", "string", errors, newContext, true);
		const _lineStatusList = AsnMgmtLineStatusList_Converter.toBER(s.lineStatusList, errors, newContext, "lineStatusList", 1);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
			t.push(new asn1ts.Integer({ value: s.iOpenState, name: "iOpenState" }));
			t.push(new asn1ts.Integer({ value: s.iNumCalls, name: "iNumCalls" }));
			t.push(new asn1ts.Integer({ value: s.iSipResponseCode, name: "iSipResponseCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sReasonPhrase, name: "u8sReasonPhrase" }));
			if (s.u8sEffectiveHomeServer !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEffectiveHomeServer, name: "u8sEffectiveHomeServer", idBlock: { optionalID: 0 } }));
			if (_lineStatusList)
				t.push(_lineStatusList);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStateChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLineStateChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLineStateChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtLineStateChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLineStateChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLineStateChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOpenState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNumCalls", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSipResponseCode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sReasonPhrase", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEffectiveHomeServer", "Utf8String", errors, newContext, true);
			t.lineStatusList = AsnMgmtLineStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lineStatusList"), errors, newContext, "lineStatusList", true);
		}

		if (errors.validateResult(newContext, "AsnMgmtLineStateChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineRemovedEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineRemovedEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineRemovedEventArgument";
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (_tapiLineConfig4Admin)
			t.tapiLineConfig4Admin = _tapiLineConfig4Admin;

		if (errors.validateResult(newContext, "AsnMgmtOnLineRemovedEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineRemovedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin", false);
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineRemovedEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineRemovedEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineRemovedEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toBER(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (!errors.hasNewErrors()) {
			if (_tapiLineConfig4Admin)
				t.push(_tapiLineConfig4Admin);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineRemovedEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineRemovedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineRemovedEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "tapiLineConfig4Admin"), errors, newContext, "tapiLineConfig4Admin");
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineRemovedEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineAddedEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineAddedEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineAddedEventArgument";
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (_tapiLineConfig4Admin)
			t.tapiLineConfig4Admin = _tapiLineConfig4Admin;

		if (errors.validateResult(newContext, "AsnMgmtOnLineAddedEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineAddedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin", false);
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineAddedEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineAddedEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineAddedEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toBER(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (!errors.hasNewErrors()) {
			if (_tapiLineConfig4Admin)
				t.push(_tapiLineConfig4Admin);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineAddedEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineAddedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineAddedEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "tapiLineConfig4Admin"), errors, newContext, "tapiLineConfig4Admin");
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineAddedEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineConfigChangedEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineConfigChangedEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineConfigChangedEventArgument";
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (_tapiLineConfig4Admin)
			t.tapiLineConfig4Admin = _tapiLineConfig4Admin;

		if (errors.validateResult(newContext, "AsnMgmtOnLineConfigChangedEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineConfigChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin", false);
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineConfigChangedEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineConfigChangedEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineConfigChangedEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toBER(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (!errors.hasNewErrors()) {
			if (_tapiLineConfig4Admin)
				t.push(_tapiLineConfig4Admin);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineConfigChangedEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineConfigChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineConfigChangedEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "tapiLineConfig4Admin"), errors, newContext, "tapiLineConfig4Admin");
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineConfigChangedEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineCapsChangedEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineCapsChangedEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineCapsChangedEventArgument";
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (_tapiLineConfig4Admin)
			t.tapiLineConfig4Admin = _tapiLineConfig4Admin;

		if (errors.validateResult(newContext, "AsnMgmtOnLineCapsChangedEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineCapsChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin", false);
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineCapsChangedEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineCapsChangedEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineCapsChangedEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toBER(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (!errors.hasNewErrors()) {
			if (_tapiLineConfig4Admin)
				t.push(_tapiLineConfig4Admin);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineCapsChangedEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineCapsChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineCapsChangedEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "tapiLineConfig4Admin"), errors, newContext, "tapiLineConfig4Admin");
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineCapsChangedEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnCtiLineFoundEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnCtiLineFoundEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnCtiLineFoundEventArgument";
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (_tapiLineConfig4Admin)
			t.tapiLineConfig4Admin = _tapiLineConfig4Admin;

		if (errors.validateResult(newContext, "AsnMgmtOnCtiLineFoundEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnCtiLineFoundEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromJSON(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin", false);
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnCtiLineFoundEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnCtiLineFoundEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnCtiLineFoundEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _tapiLineConfig4Admin = AsnMgmtTapiLineConfig4Admin_Converter.toBER(s.tapiLineConfig4Admin, errors, newContext, "tapiLineConfig4Admin");
		if (!errors.hasNewErrors()) {
			if (_tapiLineConfig4Admin)
				t.push(_tapiLineConfig4Admin);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnCtiLineFoundEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnCtiLineFoundEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnCtiLineFoundEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _tapilineconfig4admin = AsnMgmtTapiLineConfig4Admin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "tapiLineConfig4Admin"), errors, newContext, "tapiLineConfig4Admin");
			if (_tapilineconfig4admin)
				t.tapiLineConfig4Admin = _tapilineconfig4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnCtiLineFoundEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineConfigResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineConfigResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineConfigResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineConfigResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineConfigResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineConfigResult";
		const _config = AsnMgmtTapiLineConfig4Admin_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineConfigResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineConfigResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineConfigResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineConfigResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineConfigResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineConfig4Admin_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineConfigResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineConfigResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineConfigResult");

		// [Print_BER_EncoderSeqDefCode]
		const _config = AsnMgmtTapiLineConfig4Admin_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineConfigResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineConfigResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineConfigResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineConfigResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineConfigResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineConfig4Admin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineConfigResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLineConfigArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLineConfigArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLineConfigArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLineConfigArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLineConfigArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLineConfigArgument";
		TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeviceID", "number", errors, newContext);
		const _config = AsnMgmtTapiLineConfiguration_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtSetLineConfigArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLineConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLineConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLineConfigArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLineConfigArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLineConfigArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSource", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeviceID", "number", errors, newContext, false);
			const _config = AsnMgmtTapiLineConfiguration_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineConfigArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLineConfigArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLineConfigArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLineConfigArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSource", "string", errors, newContext);
		TSConverter.validateParam(s, "iDeviceID", "number", errors, newContext);
		const _config = AsnMgmtTapiLineConfiguration_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSource, name: "u8sLineSource" }));
			t.push(new asn1ts.Integer({ value: s.iDeviceID, name: "iDeviceID" }));
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineConfigArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLineConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLineConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLineConfigArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLineConfigArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLineConfigArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSource", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeviceID", "Integer", errors, newContext);
			const _config = AsnMgmtTapiLineConfiguration_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineConfigArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtCtiFeatureCodeList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiFeatureCodeList");

		const t = [] as ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtCtiFeatureCode_Converter.toJSON(se, errors, newContext, "AsnMgmtCtiFeatureCode");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCodeList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiFeatureCodeList");

		let t: ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtCtiFeatureCode_Converter.fromJSON(se, errors, newContext, "AsnMgmtCtiFeatureCode", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCodeList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtCtiFeatureCodeList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiFeatureCodeList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtCtiFeatureCode_Converter.toBER(s[id], errors, newContext, "AsnMgmtCtiFeatureCode");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCodeList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiFeatureCodeList");

		let t: ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtCtiFeatureCodeList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtCtiFeatureCode_Converter.fromBER(se, errors, newContext, "AsnMgmtCtiFeatureCode", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiFeatureCodeList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtTapiLineGroupConfiguration_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiLineGroupConfiguration");

		const t = {} as ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtTapiLineGroupConfiguration";
		TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPBXGroupName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDefaultEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDefaultAutoActivate", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDefaultAutoCreate", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDefaultJournal", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLineIDAutomatic", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPhoneNumberAutomatic", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUseTapiLineNames", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutomaticLocationFinding", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSupportedFeatures", "number", errors, newContext);
		const _objFeatureCodes = AsnMgmtCtiFeatureCodeList_Converter.toJSON(s.objFeatureCodes, errors, newContext, "objFeatureCodes");
		if (_objFeatureCodes)
			t.objFeatureCodes = _objFeatureCodes;
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.customProps, errors, newContext, "customProps");
		if (_customProps)
			t.customProps = _customProps;
		TSConverter.fillJSONParam(s, t, "iRejectCodeSrv", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRejectCodeClnt", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bHideRejectClnt", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLineType", "number", errors, newContext);
		const _adminGroupForwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toJSON(s.adminGroupForwarding, errors, newContext, "adminGroupForwarding");
		if (_adminGroupForwarding)
			t.adminGroupForwarding = _adminGroupForwarding;
		TSConverter.fillJSONParam(s, t, "iMinPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNoEarlyMedia", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtTapiLineGroupConfiguration"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiLineGroupConfiguration");

		let t: ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLineSourceName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPBXGroupName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDefaultEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDefaultAutoActivate", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDefaultAutoCreate", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDefaultJournal", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLineIDAutomatic", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPhoneNumberAutomatic", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUseTapiLineNames", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutomaticLocationFinding", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSupportedFeatures", "number", errors, newContext, false);
			const _objfeaturecodes = AsnMgmtCtiFeatureCodeList_Converter.fromJSON(s.objFeatureCodes, errors, newContext, "objFeatureCodes", false);
			if (_objfeaturecodes)
				t.objFeatureCodes = _objfeaturecodes;
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.customProps, errors, newContext, "customProps", false);
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillJSONParam(s, t, "iRejectCodeSrv", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRejectCodeClnt", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bHideRejectClnt", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLineType", "number", errors, newContext, false);
			const _admingroupforwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromJSON(s.adminGroupForwarding, errors, newContext, "adminGroupForwarding", false);
			if (_admingroupforwarding)
				t.adminGroupForwarding = _admingroupforwarding;
			TSConverter.fillJSONParam(s, t, "iMinPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNoEarlyMedia", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineGroupConfiguration"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtTapiLineGroupConfiguration";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtTapiLineGroupConfiguration");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLineSourceName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPBXGroupName", "string", errors, newContext);
		TSConverter.validateParam(s, "iDefaultEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iDefaultAutoActivate", "number", errors, newContext);
		TSConverter.validateParam(s, "iDefaultAutoCreate", "number", errors, newContext);
		TSConverter.validateParam(s, "iDefaultJournal", "number", errors, newContext);
		TSConverter.validateParam(s, "iLineIDAutomatic", "number", errors, newContext);
		TSConverter.validateParam(s, "iPhoneNumberAutomatic", "number", errors, newContext);
		TSConverter.validateParam(s, "iUseTapiLineNames", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "bAutomaticLocationFinding", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iSupportedFeatures", "number", errors, newContext);
		const _objFeatureCodes = AsnMgmtCtiFeatureCodeList_Converter.toBER(s.objFeatureCodes, errors, newContext, "objFeatureCodes");
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.customProps, errors, newContext, "customProps");
		TSConverter.validateParam(s, "iRejectCodeSrv", "number", errors, newContext);
		TSConverter.validateParam(s, "iRejectCodeClnt", "number", errors, newContext);
		TSConverter.validateParam(s, "bHideRejectClnt", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iLineType", "number", errors, newContext);
		const _adminGroupForwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.toBER(s.adminGroupForwarding, errors, newContext, "adminGroupForwarding");
		TSConverter.validateParam(s, "iMinPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxPort", "number", errors, newContext);
		TSConverter.validateParam(s, "bNoEarlyMedia", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLineSourceName, name: "u8sLineSourceName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPBXGroupName, name: "u8sPBXGroupName" }));
			t.push(new asn1ts.Integer({ value: s.iDefaultEnabled, name: "iDefaultEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iDefaultAutoActivate, name: "iDefaultAutoActivate" }));
			t.push(new asn1ts.Integer({ value: s.iDefaultAutoCreate, name: "iDefaultAutoCreate" }));
			t.push(new asn1ts.Integer({ value: s.iDefaultJournal, name: "iDefaultJournal" }));
			t.push(new asn1ts.Integer({ value: s.iLineIDAutomatic, name: "iLineIDAutomatic" }));
			t.push(new asn1ts.Integer({ value: s.iPhoneNumberAutomatic, name: "iPhoneNumberAutomatic" }));
			t.push(new asn1ts.Integer({ value: s.iUseTapiLineNames, name: "iUseTapiLineNames" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Boolean({ value: s.bAutomaticLocationFinding, name: "bAutomaticLocationFinding" }));
			t.push(new asn1ts.Integer({ value: s.iSupportedFeatures, name: "iSupportedFeatures" }));
			if (_objFeatureCodes)
				t.push(_objFeatureCodes);
			if (_customProps)
				t.push(_customProps);
			t.push(new asn1ts.Integer({ value: s.iRejectCodeSrv, name: "iRejectCodeSrv" }));
			t.push(new asn1ts.Integer({ value: s.iRejectCodeClnt, name: "iRejectCodeClnt" }));
			t.push(new asn1ts.Boolean({ value: s.bHideRejectClnt, name: "bHideRejectClnt" }));
			t.push(new asn1ts.Integer({ value: s.iLineType, name: "iLineType" }));
			if (_adminGroupForwarding)
				t.push(_adminGroupForwarding);
			t.push(new asn1ts.Integer({ value: s.iMinPort, name: "iMinPort" }));
			t.push(new asn1ts.Integer({ value: s.iMaxPort, name: "iMaxPort" }));
			t.push(new asn1ts.Boolean({ value: s.bNoEarlyMedia, name: "bNoEarlyMedia" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineGroupConfiguration"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtTapiLineGroupConfiguration");

		let t: ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtTapiLineGroupConfiguration["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLineSourceName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPBXGroupName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDefaultEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDefaultAutoActivate", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDefaultAutoCreate", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDefaultJournal", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLineIDAutomatic", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPhoneNumberAutomatic", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUseTapiLineNames", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutomaticLocationFinding", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSupportedFeatures", "Integer", errors, newContext);
			const _objfeaturecodes = AsnMgmtCtiFeatureCodeList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "objFeatureCodes"), errors, newContext, "objFeatureCodes");
			if (_objfeaturecodes)
				t.objFeatureCodes = _objfeaturecodes;
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "customProps"), errors, newContext, "customProps");
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillASN1Param(s, t, "iRejectCodeSrv", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRejectCodeClnt", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bHideRejectClnt", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLineType", "Integer", errors, newContext);
			const _admingroupforwarding = ENetUC_Common_SIPCTI_Converter.AsnLineForwards_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "adminGroupForwarding"), errors, newContext, "adminGroupForwarding");
			if (_admingroupforwarding)
				t.adminGroupForwarding = _admingroupforwarding;
			TSConverter.fillASN1Param(s, t, "iMinPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNoEarlyMedia", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtTapiLineGroupConfiguration"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineGroupConfigResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupConfigResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineGroupConfigResult";
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupConfigResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineGroupConfigResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineGroupConfigResult");

		// [Print_BER_EncoderSeqDefCode]
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineGroupConfigResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineGroupConfigResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineGroupConfigResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLineGroupConfigArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLineGroupConfigArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLineGroupConfigArgument";
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtSetLineGroupConfigArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLineGroupConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineGroupConfigArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLineGroupConfigArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLineGroupConfigArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineGroupConfigArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLineGroupConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLineGroupConfigArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineGroupConfigArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineEvent4AdminEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineEvent4AdminEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineEvent4AdminEventArgument";
		const _lineEvent4Admin = AsnMgmtLineEventForAdmin_Converter.toJSON(s.lineEvent4Admin, errors, newContext, "lineEvent4Admin");
		if (_lineEvent4Admin)
			t.lineEvent4Admin = _lineEvent4Admin;

		if (errors.validateResult(newContext, "AsnMgmtOnLineEvent4AdminEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineEvent4AdminEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _lineevent4admin = AsnMgmtLineEventForAdmin_Converter.fromJSON(s.lineEvent4Admin, errors, newContext, "lineEvent4Admin", false);
			if (_lineevent4admin)
				t.lineEvent4Admin = _lineevent4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineEvent4AdminEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineEvent4AdminEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineEvent4AdminEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _lineEvent4Admin = AsnMgmtLineEventForAdmin_Converter.toBER(s.lineEvent4Admin, errors, newContext, "lineEvent4Admin");
		if (!errors.hasNewErrors()) {
			if (_lineEvent4Admin)
				t.push(_lineEvent4Admin);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineEvent4AdminEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineEvent4AdminEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineEvent4AdminEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _lineevent4admin = AsnMgmtLineEventForAdmin_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lineEvent4Admin"), errors, newContext, "lineEvent4Admin");
			if (_lineevent4admin)
				t.lineEvent4Admin = _lineevent4admin;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineEvent4AdminEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnUserManagerSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnUserManagerSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnUserManagerSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUserManagerSettings");

		const t = {} as ENetUC_Mgmt.AsnUserManagerSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnUserManagerSettings";
		TSConverter.fillJSONParam(s, t, "iUMSecurity", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUMSelfInstall", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iComputerIsDomainMember", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sComputerDomainNT", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sComputerDomainFQ", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDomainController", "string", errors, newContext);
		const _objGlobalUserRightDetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.toJSON(s.objGlobalUserRightDetails, errors, newContext, "objGlobalUserRightDetails");
		if (_objGlobalUserRightDetails)
			t.objGlobalUserRightDetails = _objGlobalUserRightDetails;
		TSConverter.fillJSONParam(s, t, "iShowAllUsersInAllMonitors", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDisableAllMonitorConfiguration", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAllJournalEntriesVisible", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iFeatures", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDeleteJournalEntriesEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoBindLinesForUsersPhoneNumbers", "boolean", errors, newContext);
		const _u8slistPresenceDomains = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistPresenceDomains, errors, newContext, "u8slistPresenceDomains");
		if (_u8slistPresenceDomains)
			t.u8slistPresenceDomains = _u8slistPresenceDomains;
		TSConverter.fillJSONParam(s, t, "u8sHomeServerIdentification", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bInternalChatDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDeskShareAccess", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bPresenceDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUserUserRightsDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bChatDatabaseDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAVAudioDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAVVideoDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDeskshareFedDisabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bLoginByMobile", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bLoginOverInternet", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnableForAnonymousApi", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bProfilePageVisible", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnableUserdefinedCustomFields", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnableBinaryTransferSend", "boolean", errors, newContext);
		const _mapUserDefinedCustomFields = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.mapUserDefinedCustomFields, errors, newContext, "mapUserDefinedCustomFields");
		if (_mapUserDefinedCustomFields)
			t.mapUserDefinedCustomFields = _mapUserDefinedCustomFields;
		if (s.objGlobalObserverGroupUserRightDetails) {
			const _objGlobalObserverGroupUserRightDetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.toJSON(s.objGlobalObserverGroupUserRightDetails, errors, newContext, "objGlobalObserverGroupUserRightDetails");
			if (_objGlobalObserverGroupUserRightDetails)
				t.objGlobalObserverGroupUserRightDetails = _objGlobalObserverGroupUserRightDetails;
		}
		TSConverter.fillJSONParam(s, t, "bEnableTeamsIntegration", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bLoginOverInternetAllowDesktop", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseWebAppEnabled", "boolean", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "eUserReplicator", "number", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnUserManagerSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnUserManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUserManagerSettings");

		let t: ENetUC_Mgmt.AsnUserManagerSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnUserManagerSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnUserManagerSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iUMSecurity", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUMSelfInstall", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iComputerIsDomainMember", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sComputerDomainNT", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sComputerDomainFQ", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDomainController", "string", errors, newContext, false);
			const _objglobaluserrightdetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.fromJSON(s.objGlobalUserRightDetails, errors, newContext, "objGlobalUserRightDetails", false);
			if (_objglobaluserrightdetails)
				t.objGlobalUserRightDetails = _objglobaluserrightdetails;
			TSConverter.fillJSONParam(s, t, "iShowAllUsersInAllMonitors", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDisableAllMonitorConfiguration", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAllJournalEntriesVisible", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iFeatures", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDeleteJournalEntriesEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoBindLinesForUsersPhoneNumbers", "boolean", errors, newContext, false);
			const _u8slistpresencedomains = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistPresenceDomains, errors, newContext, "u8slistPresenceDomains", false);
			if (_u8slistpresencedomains)
				t.u8slistPresenceDomains = _u8slistpresencedomains;
			TSConverter.fillJSONParam(s, t, "u8sHomeServerIdentification", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bInternalChatDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDeskShareAccess", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bPresenceDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUserUserRightsDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bChatDatabaseDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAVAudioDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAVVideoDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDeskshareFedDisabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bLoginByMobile", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bLoginOverInternet", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnableForAnonymousApi", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bProfilePageVisible", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnableUserdefinedCustomFields", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnableBinaryTransferSend", "boolean", errors, newContext, false);
			const _mapuserdefinedcustomfields = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.mapUserDefinedCustomFields, errors, newContext, "mapUserDefinedCustomFields", false);
			if (_mapuserdefinedcustomfields)
				t.mapUserDefinedCustomFields = _mapuserdefinedcustomfields;
			const _objglobalobservergroupuserrightdetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.fromJSON(s.objGlobalObserverGroupUserRightDetails, errors, newContext, "objGlobalObserverGroupUserRightDetails", true);
			if (_objglobalobservergroupuserrightdetails)
				t.objGlobalObserverGroupUserRightDetails = _objglobalobservergroupuserrightdetails;
			TSConverter.fillJSONParam(s, t, "bEnableTeamsIntegration", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bLoginOverInternetAllowDesktop", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseWebAppEnabled", "boolean", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "eUserReplicator", "number", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnUserManagerSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnUserManagerSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnUserManagerSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnUserManagerSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iUMSecurity", "number", errors, newContext);
		TSConverter.validateParam(s, "iUMSelfInstall", "number", errors, newContext);
		TSConverter.validateParam(s, "iComputerIsDomainMember", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sComputerDomainNT", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sComputerDomainFQ", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDomainController", "string", errors, newContext);
		const _objGlobalUserRightDetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.toBER(s.objGlobalUserRightDetails, errors, newContext, "objGlobalUserRightDetails");
		TSConverter.validateParam(s, "iShowAllUsersInAllMonitors", "number", errors, newContext);
		TSConverter.validateParam(s, "iDisableAllMonitorConfiguration", "number", errors, newContext);
		TSConverter.validateParam(s, "bAllJournalEntriesVisible", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iFeatures", "number", errors, newContext);
		TSConverter.validateParam(s, "bDeleteJournalEntriesEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAutoBindLinesForUsersPhoneNumbers", "boolean", errors, newContext);
		const _u8slistPresenceDomains = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistPresenceDomains, errors, newContext, "u8slistPresenceDomains");
		TSConverter.validateParam(s, "u8sHomeServerIdentification", "string", errors, newContext);
		TSConverter.validateParam(s, "bInternalChatDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iDeskShareAccess", "number", errors, newContext);
		TSConverter.validateParam(s, "bPresenceDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bUserUserRightsDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bChatDatabaseDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAVAudioDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAVVideoDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bDeskshareFedDisabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bLoginByMobile", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bLoginOverInternet", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEnableForAnonymousApi", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bProfilePageVisible", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEnableUserdefinedCustomFields", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEnableBinaryTransferSend", "boolean", errors, newContext);
		const _mapUserDefinedCustomFields = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.mapUserDefinedCustomFields, errors, newContext, "mapUserDefinedCustomFields");
		const _objGlobalObserverGroupUserRightDetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.toBER(s.objGlobalObserverGroupUserRightDetails, errors, newContext, "objGlobalObserverGroupUserRightDetails", 0);
		TSConverter.validateParam(s, "bEnableTeamsIntegration", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bLoginOverInternetAllowDesktop", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bUseWebAppEnabled", "boolean", errors, newContext, true);
		TSConverter.validateParam(s, "eUserReplicator", "number", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iUMSecurity, name: "iUMSecurity" }));
			t.push(new asn1ts.Integer({ value: s.iUMSelfInstall, name: "iUMSelfInstall" }));
			t.push(new asn1ts.Integer({ value: s.iComputerIsDomainMember, name: "iComputerIsDomainMember" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerDomainNT, name: "u8sComputerDomainNT" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sComputerDomainFQ, name: "u8sComputerDomainFQ" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDomainController, name: "u8sDomainController" }));
			if (_objGlobalUserRightDetails)
				t.push(_objGlobalUserRightDetails);
			t.push(new asn1ts.Integer({ value: s.iShowAllUsersInAllMonitors, name: "iShowAllUsersInAllMonitors" }));
			t.push(new asn1ts.Integer({ value: s.iDisableAllMonitorConfiguration, name: "iDisableAllMonitorConfiguration" }));
			t.push(new asn1ts.Boolean({ value: s.bAllJournalEntriesVisible, name: "bAllJournalEntriesVisible" }));
			t.push(new asn1ts.Integer({ value: s.iFeatures, name: "iFeatures" }));
			t.push(new asn1ts.Boolean({ value: s.bDeleteJournalEntriesEnabled, name: "bDeleteJournalEntriesEnabled" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoBindLinesForUsersPhoneNumbers, name: "bAutoBindLinesForUsersPhoneNumbers" }));
			if (_u8slistPresenceDomains)
				t.push(_u8slistPresenceDomains);
			t.push(new asn1ts.Utf8String({ value: s.u8sHomeServerIdentification, name: "u8sHomeServerIdentification" }));
			t.push(new asn1ts.Boolean({ value: s.bInternalChatDisabled, name: "bInternalChatDisabled" }));
			t.push(new asn1ts.Integer({ value: s.iDeskShareAccess, name: "iDeskShareAccess" }));
			t.push(new asn1ts.Boolean({ value: s.bPresenceDisabled, name: "bPresenceDisabled" }));
			t.push(new asn1ts.Boolean({ value: s.bUserUserRightsDisabled, name: "bUserUserRightsDisabled" }));
			t.push(new asn1ts.Boolean({ value: s.bChatDatabaseDisabled, name: "bChatDatabaseDisabled" }));
			t.push(new asn1ts.Boolean({ value: s.bAVAudioDisabled, name: "bAVAudioDisabled" }));
			t.push(new asn1ts.Boolean({ value: s.bAVVideoDisabled, name: "bAVVideoDisabled" }));
			t.push(new asn1ts.Boolean({ value: s.bDeskshareFedDisabled, name: "bDeskshareFedDisabled" }));
			t.push(new asn1ts.Boolean({ value: s.bLoginByMobile, name: "bLoginByMobile" }));
			t.push(new asn1ts.Boolean({ value: s.bLoginOverInternet, name: "bLoginOverInternet" }));
			t.push(new asn1ts.Boolean({ value: s.bEnableForAnonymousApi, name: "bEnableForAnonymousApi" }));
			t.push(new asn1ts.Boolean({ value: s.bProfilePageVisible, name: "bProfilePageVisible" }));
			t.push(new asn1ts.Boolean({ value: s.bEnableUserdefinedCustomFields, name: "bEnableUserdefinedCustomFields" }));
			t.push(new asn1ts.Boolean({ value: s.bEnableBinaryTransferSend, name: "bEnableBinaryTransferSend" }));
			if (_mapUserDefinedCustomFields)
				t.push(_mapUserDefinedCustomFields);
			if (_objGlobalObserverGroupUserRightDetails)
				t.push(_objGlobalObserverGroupUserRightDetails);
			t.push(new asn1ts.Boolean({ value: s.bEnableTeamsIntegration, name: "bEnableTeamsIntegration" }));
			t.push(new asn1ts.Boolean({ value: s.bLoginOverInternetAllowDesktop, name: "bLoginOverInternetAllowDesktop" }));
			if (s.bUseWebAppEnabled !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bUseWebAppEnabled, name: "bUseWebAppEnabled", idBlock: { optionalID: 1 } }));
			if (s.eUserReplicator !== undefined)
				t.push(new asn1ts.Enumerated({ value: s.eUserReplicator, name: "eUserReplicator", idBlock: { optionalID: 2 } }));
		}

		if (errors.validateResult(newContext, "AsnUserManagerSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnUserManagerSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnUserManagerSettings");

		let t: ENetUC_Mgmt.AsnUserManagerSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnUserManagerSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnUserManagerSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iUMSecurity", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUMSelfInstall", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iComputerIsDomainMember", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sComputerDomainNT", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sComputerDomainFQ", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDomainController", "Utf8String", errors, newContext);
			const _objglobaluserrightdetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "objGlobalUserRightDetails"), errors, newContext, "objGlobalUserRightDetails");
			if (_objglobaluserrightdetails)
				t.objGlobalUserRightDetails = _objglobaluserrightdetails;
			TSConverter.fillASN1Param(s, t, "iShowAllUsersInAllMonitors", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDisableAllMonitorConfiguration", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAllJournalEntriesVisible", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iFeatures", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDeleteJournalEntriesEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoBindLinesForUsersPhoneNumbers", "Boolean", errors, newContext);
			const _u8slistpresencedomains = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistPresenceDomains"), errors, newContext, "u8slistPresenceDomains");
			if (_u8slistpresencedomains)
				t.u8slistPresenceDomains = _u8slistpresencedomains;
			TSConverter.fillASN1Param(s, t, "u8sHomeServerIdentification", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bInternalChatDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDeskShareAccess", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bPresenceDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUserUserRightsDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bChatDatabaseDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAVAudioDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAVVideoDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDeskshareFedDisabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bLoginByMobile", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bLoginOverInternet", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnableForAnonymousApi", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bProfilePageVisible", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnableUserdefinedCustomFields", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnableBinaryTransferSend", "Boolean", errors, newContext);
			const _mapuserdefinedcustomfields = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mapUserDefinedCustomFields"), errors, newContext, "mapUserDefinedCustomFields");
			if (_mapuserdefinedcustomfields)
				t.mapUserDefinedCustomFields = _mapuserdefinedcustomfields;
			t.objGlobalObserverGroupUserRightDetails = ENetUC_Common_AsnContact_Converter.AsnUserDynamicRights_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "objGlobalObserverGroupUserRightDetails"), errors, newContext, "objGlobalObserverGroupUserRightDetails", true);
			TSConverter.fillASN1Param(s, t, "bEnableTeamsIntegration", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bLoginOverInternetAllowDesktop", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseWebAppEnabled", "Boolean", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "eUserReplicator", "Enumerated", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnUserManagerSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserManagerLDAPAttributeList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerLDAPAttributeList");

		const t = [] as ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtUserManagerLDAPAttribute_Converter.toJSON(se, errors, newContext, "AsnMgmtUserManagerLDAPAttribute");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttributeList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerLDAPAttributeList");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtUserManagerLDAPAttribute_Converter.fromJSON(se, errors, newContext, "AsnMgmtUserManagerLDAPAttribute", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttributeList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserManagerLDAPAttributeList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerLDAPAttributeList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtUserManagerLDAPAttribute_Converter.toBER(s[id], errors, newContext, "AsnMgmtUserManagerLDAPAttribute");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttributeList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerLDAPAttributeList");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtUserManagerLDAPAttributeList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtUserManagerLDAPAttribute_Converter.fromBER(se, errors, newContext, "AsnMgmtUserManagerLDAPAttribute", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerLDAPAttributeList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserManagerActiveDirectorySettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerActiveDirectorySettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserManagerActiveDirectorySettings";
		TSConverter.fillJSONParam(s, t, "u8sHost", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDomain", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iForceLDAPS", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBaseDNUsers", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBaseDNComputers", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBaseDNGroups", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bLDAPBaseAttributeWriteBackEnabled", "boolean", errors, newContext);
		const _objAttributeMapping = AsnMgmtUserManagerLDAPAttributeList_Converter.toJSON(s.objAttributeMapping, errors, newContext, "objAttributeMapping");
		if (_objAttributeMapping)
			t.objAttributeMapping = _objAttributeMapping;
		TSConverter.fillJSONParam(s, t, "iPhoneNumberPreformatFormat", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iExtensionVersion", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLastErrorCode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLDAPFilterUsers", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sLDAPFilterGroups", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sLDAPFilterComputers", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtUserManagerActiveDirectorySettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerActiveDirectorySettings");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sHost", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDomain", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iForceLDAPS", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBaseDNUsers", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBaseDNComputers", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBaseDNGroups", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bLDAPBaseAttributeWriteBackEnabled", "boolean", errors, newContext, false);
			const _objattributemapping = AsnMgmtUserManagerLDAPAttributeList_Converter.fromJSON(s.objAttributeMapping, errors, newContext, "objAttributeMapping", false);
			if (_objattributemapping)
				t.objAttributeMapping = _objattributemapping;
			TSConverter.fillJSONParam(s, t, "iPhoneNumberPreformatFormat", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iExtensionVersion", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLastErrorCode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLDAPFilterUsers", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sLDAPFilterGroups", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sLDAPFilterComputers", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerActiveDirectorySettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserManagerActiveDirectorySettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerActiveDirectorySettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sHost", "string", errors, newContext);
		TSConverter.validateParam(s, "iPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sDomain", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iForceLDAPS", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sBaseDNUsers", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sBaseDNComputers", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sBaseDNGroups", "string", errors, newContext);
		TSConverter.validateParam(s, "bLDAPBaseAttributeWriteBackEnabled", "boolean", errors, newContext);
		const _objAttributeMapping = AsnMgmtUserManagerLDAPAttributeList_Converter.toBER(s.objAttributeMapping, errors, newContext, "objAttributeMapping");
		TSConverter.validateParam(s, "iPhoneNumberPreformatFormat", "number", errors, newContext);
		TSConverter.validateParam(s, "iExtensionVersion", "number", errors, newContext);
		TSConverter.validateParam(s, "iLastErrorCode", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLDAPFilterUsers", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sLDAPFilterGroups", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sLDAPFilterComputers", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sHost, name: "u8sHost" }));
			t.push(new asn1ts.Integer({ value: s.iPort, name: "iPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDomain, name: "u8sDomain" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUsername, name: "u8sUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPassword, name: "u8sPassword" }));
			t.push(new asn1ts.Integer({ value: s.iForceLDAPS, name: "iForceLDAPS" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBaseDNUsers, name: "u8sBaseDNUsers" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBaseDNComputers, name: "u8sBaseDNComputers" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBaseDNGroups, name: "u8sBaseDNGroups" }));
			t.push(new asn1ts.Boolean({ value: s.bLDAPBaseAttributeWriteBackEnabled, name: "bLDAPBaseAttributeWriteBackEnabled" }));
			if (_objAttributeMapping)
				t.push(_objAttributeMapping);
			t.push(new asn1ts.Integer({ value: s.iPhoneNumberPreformatFormat, name: "iPhoneNumberPreformatFormat" }));
			t.push(new asn1ts.Integer({ value: s.iExtensionVersion, name: "iExtensionVersion" }));
			t.push(new asn1ts.Integer({ value: s.iLastErrorCode, name: "iLastErrorCode" }));
			if (s.u8sLDAPFilterUsers !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sLDAPFilterUsers, name: "u8sLDAPFilterUsers", idBlock: { optionalID: 0 } }));
			if (s.u8sLDAPFilterGroups !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sLDAPFilterGroups, name: "u8sLDAPFilterGroups", idBlock: { optionalID: 1 } }));
			if (s.u8sLDAPFilterComputers !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sLDAPFilterComputers, name: "u8sLDAPFilterComputers", idBlock: { optionalID: 2 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerActiveDirectorySettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerActiveDirectorySettings");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerActiveDirectorySettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sHost", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDomain", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iForceLDAPS", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBaseDNUsers", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBaseDNComputers", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBaseDNGroups", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bLDAPBaseAttributeWriteBackEnabled", "Boolean", errors, newContext);
			const _objattributemapping = AsnMgmtUserManagerLDAPAttributeList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "objAttributeMapping"), errors, newContext, "objAttributeMapping");
			if (_objattributemapping)
				t.objAttributeMapping = _objattributemapping;
			TSConverter.fillASN1Param(s, t, "iPhoneNumberPreformatFormat", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iExtensionVersion", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLastErrorCode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLDAPFilterUsers", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sLDAPFilterGroups", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sLDAPFilterComputers", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerActiveDirectorySettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUMInterfaceSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUMInterfaceSettingsResult";
		const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUMInterfaceSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMInterfaceSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUMInterfaceSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMInterfaceSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetUMInterfaceSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUMInterfaceSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetUMInterfaceSettingsArgument";
		TSConverter.fillJSONParam(s, t, "iInterfaceType", "number", errors, newContext);
		const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetUMInterfaceSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUMInterfaceSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iInterfaceType", "number", errors, newContext, false);
			const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMInterfaceSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetUMInterfaceSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUMInterfaceSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iInterfaceType", "number", errors, newContext);
		const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iInterfaceType, name: "iInterfaceType" }));
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMInterfaceSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUMInterfaceSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetUMInterfaceSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iInterfaceType", "Integer", errors, newContext);
			const _settings = AsnMgmtUserManagerActiveDirectorySettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMInterfaceSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUMSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUMSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUMSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUMSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUMSettingsResult";
		const _settings = AsnUserManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetUMSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUMSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUMSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUMSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnUserManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUMSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUMSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUMSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnUserManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUMSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUMSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUMSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUMSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUMSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnUserManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUMSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetUMSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUMSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetUMSettingsArgument";
		const _settings = AsnUserManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetUMSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUMSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnUserManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetUMSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetUMSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnUserManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetUMSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetUMSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnUserManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetUMSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtFeatureCountList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtFeatureCountList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtFeatureCountList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFeatureCountList");

		const t = [] as ENetUC_Mgmt.AsnMgmtFeatureCountList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtFeatureCount_Converter.toJSON(se, errors, newContext, "AsnMgmtFeatureCount");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtFeatureCountList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFeatureCountList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFeatureCountList");

		let t: ENetUC_Mgmt.AsnMgmtFeatureCountList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtFeatureCountList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtFeatureCountList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtFeatureCount_Converter.fromJSON(se, errors, newContext, "AsnMgmtFeatureCount", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtFeatureCountList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtFeatureCountList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtFeatureCountList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtFeatureCountList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtFeatureCount_Converter.toBER(s[id], errors, newContext, "AsnMgmtFeatureCount");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtFeatureCountList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtFeatureCountList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtFeatureCountList");

		let t: ENetUC_Mgmt.AsnMgmtFeatureCountList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtFeatureCountList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtFeatureCountList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtFeatureCount_Converter.fromBER(se, errors, newContext, "AsnMgmtFeatureCount", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtFeatureCountList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLicenseDetails_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLicenseDetails, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLicenseDetails & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLicenseDetails");

		const t = {} as ENetUC_Mgmt.AsnMgmtLicenseDetails & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLicenseDetails";
		const _featureCount = AsnMgmtFeatureCountList_Converter.toJSON(s.featureCount, errors, newContext, "featureCount");
		if (_featureCount)
			t.featureCount = _featureCount;
		TSConverter.fillJSONParam(s, t, "iProductID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iBaseProductIDRequired", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLicenseVersion", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsTrialFeatureLicense", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsUpgradeLicense", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsUpgradeLicenseAnyVersion", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRequiredOldLicenseVersion", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRequiresUpgradeLicense", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsTestLicense", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsNotForResale", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRequiresHWBinding", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsHWBound", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsDynamicLicense", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLicenseCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "validTo", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "contractEnd", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDescription", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bIsExpired", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCompromiseStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLicenseSerial", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iGenuineStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "genuineCheckTimeStamp", "Date", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtLicenseDetails"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLicenseDetails | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLicenseDetails");

		let t: ENetUC_Mgmt.AsnMgmtLicenseDetails | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLicenseDetails>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLicenseDetails["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _featurecount = AsnMgmtFeatureCountList_Converter.fromJSON(s.featureCount, errors, newContext, "featureCount", false);
			if (_featurecount)
				t.featureCount = _featurecount;
			TSConverter.fillJSONParam(s, t, "iProductID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iBaseProductIDRequired", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLicenseVersion", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsTrialFeatureLicense", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsUpgradeLicense", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsUpgradeLicenseAnyVersion", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRequiredOldLicenseVersion", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRequiresUpgradeLicense", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsTestLicense", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsNotForResale", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRequiresHWBinding", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsHWBound", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsDynamicLicense", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLicenseCode", "string", errors, newContext, false);
			if (TSConverter.validateParam(s, "validTo", "string", errors, newContext, false))
				t.validTo = new Date(s.validTo);
			if (TSConverter.validateParam(s, "contractEnd", "string", errors, newContext, false))
				t.contractEnd = new Date(s.contractEnd);
			TSConverter.fillJSONParam(s, t, "u8sDescription", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bIsExpired", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCompromiseStatus", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLicenseSerial", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iGenuineStatus", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "genuineCheckTimeStamp", "string", errors, newContext, false))
				t.genuineCheckTimeStamp = new Date(s.genuineCheckTimeStamp);
		}

		if (errors.validateResult(newContext, "AsnMgmtLicenseDetails"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLicenseDetails | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLicenseDetails";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLicenseDetails");

		// [Print_BER_EncoderSeqDefCode]
		const _featureCount = AsnMgmtFeatureCountList_Converter.toBER(s.featureCount, errors, newContext, "featureCount");
		TSConverter.validateParam(s, "iProductID", "number", errors, newContext);
		TSConverter.validateParam(s, "iBaseProductIDRequired", "number", errors, newContext);
		TSConverter.validateParam(s, "iLicenseVersion", "number", errors, newContext);
		TSConverter.validateParam(s, "bIsTrialFeatureLicense", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bIsUpgradeLicense", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bIsUpgradeLicenseAnyVersion", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iRequiredOldLicenseVersion", "number", errors, newContext);
		TSConverter.validateParam(s, "bRequiresUpgradeLicense", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bIsTestLicense", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bIsNotForResale", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bRequiresHWBinding", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bIsHWBound", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bIsDynamicLicense", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sLicenseCode", "string", errors, newContext);
		TSConverter.validateParam(s, "validTo", "Date", errors, newContext);
		TSConverter.validateParam(s, "contractEnd", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sDescription", "string", errors, newContext);
		TSConverter.validateParam(s, "bIsExpired", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iCompromiseStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "iLicenseSerial", "number", errors, newContext);
		TSConverter.validateParam(s, "iGenuineStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "genuineCheckTimeStamp", "Date", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_featureCount)
				t.push(_featureCount);
			t.push(new asn1ts.Integer({ value: s.iProductID, name: "iProductID" }));
			t.push(new asn1ts.Integer({ value: s.iBaseProductIDRequired, name: "iBaseProductIDRequired" }));
			t.push(new asn1ts.Integer({ value: s.iLicenseVersion, name: "iLicenseVersion" }));
			t.push(new asn1ts.Boolean({ value: s.bIsTrialFeatureLicense, name: "bIsTrialFeatureLicense" }));
			t.push(new asn1ts.Boolean({ value: s.bIsUpgradeLicense, name: "bIsUpgradeLicense" }));
			t.push(new asn1ts.Boolean({ value: s.bIsUpgradeLicenseAnyVersion, name: "bIsUpgradeLicenseAnyVersion" }));
			t.push(new asn1ts.Integer({ value: s.iRequiredOldLicenseVersion, name: "iRequiredOldLicenseVersion" }));
			t.push(new asn1ts.Boolean({ value: s.bRequiresUpgradeLicense, name: "bRequiresUpgradeLicense" }));
			t.push(new asn1ts.Boolean({ value: s.bIsTestLicense, name: "bIsTestLicense" }));
			t.push(new asn1ts.Boolean({ value: s.bIsNotForResale, name: "bIsNotForResale" }));
			t.push(new asn1ts.Boolean({ value: s.bRequiresHWBinding, name: "bRequiresHWBinding" }));
			t.push(new asn1ts.Boolean({ value: s.bIsHWBound, name: "bIsHWBound" }));
			t.push(new asn1ts.Boolean({ value: s.bIsDynamicLicense, name: "bIsDynamicLicense" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLicenseCode, name: "u8sLicenseCode" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.validTo), name: "validTo" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.contractEnd), name: "contractEnd" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDescription, name: "u8sDescription" }));
			t.push(new asn1ts.Boolean({ value: s.bIsExpired, name: "bIsExpired" }));
			t.push(new asn1ts.Integer({ value: s.iCompromiseStatus, name: "iCompromiseStatus" }));
			t.push(new asn1ts.Integer({ value: s.iLicenseSerial, name: "iLicenseSerial" }));
			t.push(new asn1ts.Integer({ value: s.iGenuineStatus, name: "iGenuineStatus" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.genuineCheckTimeStamp), name: "genuineCheckTimeStamp" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtLicenseDetails"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLicenseDetails | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLicenseDetails");

		let t: ENetUC_Mgmt.AsnMgmtLicenseDetails | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLicenseDetails.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLicenseDetails["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _featurecount = AsnMgmtFeatureCountList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "featureCount"), errors, newContext, "featureCount");
			if (_featurecount)
				t.featureCount = _featurecount;
			TSConverter.fillASN1Param(s, t, "iProductID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iBaseProductIDRequired", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLicenseVersion", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsTrialFeatureLicense", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsUpgradeLicense", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsUpgradeLicenseAnyVersion", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRequiredOldLicenseVersion", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRequiresUpgradeLicense", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsTestLicense", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsNotForResale", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRequiresHWBinding", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsHWBound", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsDynamicLicense", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLicenseCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "validTo", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "contractEnd", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDescription", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bIsExpired", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCompromiseStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLicenseSerial", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iGenuineStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "genuineCheckTimeStamp", "AsnSystemTime", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtLicenseDetails"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLicenseResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLicenseResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLicenseResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLicenseResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLicenseResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLicenseResult";
		const _details = AsnMgmtLicenseDetails_Converter.toJSON(s.details, errors, newContext, "details");
		if (_details)
			t.details = _details;

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLicenseResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLicenseResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLicenseResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLicenseResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLicenseResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _details = AsnMgmtLicenseDetails_Converter.fromJSON(s.details, errors, newContext, "details", false);
			if (_details)
				t.details = _details;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLicenseResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLicenseResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLicenseResult");

		// [Print_BER_EncoderSeqDefCode]
		const _details = AsnMgmtLicenseDetails_Converter.toBER(s.details, errors, newContext, "details");
		if (!errors.hasNewErrors()) {
			if (_details)
				t.push(_details);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLicenseResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLicenseResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLicenseResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLicenseResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLicenseResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _details = AsnMgmtLicenseDetails_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "details"), errors, newContext, "details");
			if (_details)
				t.details = _details;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLicenseResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWSStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWSStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWSStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWSStatus");

		const t = {} as ENetUC_Mgmt.AsnMgmtEUCWSStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEUCWSStatus";
		TSConverter.fillJSONParam(s, t, "u8sWCSID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sURL", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLastError", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUCConnect", "boolean", errors, newContext);
		const _capabilities = AsnMgmtEUCWSCapabilities_Converter.toJSON(s.capabilities, errors, newContext, "capabilities");
		if (_capabilities)
			t.capabilities = _capabilities;

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWSStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWSStatus");

		let t: ENetUC_Mgmt.AsnMgmtEUCWSStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWSStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEUCWSStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sWCSID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sURL", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLastError", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUCConnect", "boolean", errors, newContext, false);
			const _capabilities = AsnMgmtEUCWSCapabilities_Converter.fromJSON(s.capabilities, errors, newContext, "capabilities", false);
			if (_capabilities)
				t.capabilities = _capabilities;
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWSStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWSStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWSStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sWCSID", "string", errors, newContext);
		TSConverter.validateParam(s, "iStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sURL", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUCSID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLastError", "string", errors, newContext);
		TSConverter.validateParam(s, "bUCConnect", "boolean", errors, newContext);
		const _capabilities = AsnMgmtEUCWSCapabilities_Converter.toBER(s.capabilities, errors, newContext, "capabilities");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sWCSID, name: "u8sWCSID" }));
			t.push(new asn1ts.Integer({ value: s.iStatus, name: "iStatus" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sURL, name: "u8sURL" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSID, name: "u8sUCSID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLastError, name: "u8sLastError" }));
			t.push(new asn1ts.Boolean({ value: s.bUCConnect, name: "bUCConnect" }));
			if (_capabilities)
				t.push(_capabilities);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWSStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWSStatus");

		let t: ENetUC_Mgmt.AsnMgmtEUCWSStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWSStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEUCWSStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sWCSID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sURL", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUCSID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLastError", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUCConnect", "Boolean", errors, newContext);
			const _capabilities = AsnMgmtEUCWSCapabilities_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "capabilities"), errors, newContext, "capabilities");
			if (_capabilities)
				t.capabilities = _capabilities;
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWSStatusList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWSStatusList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWSStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWSStatusList");

		const t = [] as ENetUC_Mgmt.AsnMgmtEUCWSStatusList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtEUCWSStatus_Converter.toJSON(se, errors, newContext, "AsnMgmtEUCWSStatus");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatusList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWSStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWSStatusList");

		let t: ENetUC_Mgmt.AsnMgmtEUCWSStatusList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWSStatusList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtEUCWSStatusList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtEUCWSStatus_Converter.fromJSON(se, errors, newContext, "AsnMgmtEUCWSStatus", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatusList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWSStatusList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWSStatusList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWSStatusList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtEUCWSStatus_Converter.toBER(s[id], errors, newContext, "AsnMgmtEUCWSStatus");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatusList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWSStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWSStatusList");

		let t: ENetUC_Mgmt.AsnMgmtEUCWSStatusList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWSStatusList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtEUCWSStatusList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtEUCWSStatus_Converter.fromBER(se, errors, newContext, "AsnMgmtEUCWSStatus", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWSStatusList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWebServicesStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServicesStatus");

		const t = {} as ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEUCWebServicesStatus";
		TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext);
		const _ucConnectStatus = AsnMgmtEUCWSStatus_Converter.toJSON(s.ucConnectStatus, errors, newContext, "ucConnectStatus");
		if (_ucConnectStatus)
			t.ucConnectStatus = _ucConnectStatus;
		const _ucwsStatusMap = AsnMgmtEUCWSStatusList_Converter.toJSON(s.ucwsStatusMap, errors, newContext, "ucwsStatusMap");
		if (_ucwsStatusMap)
			t.ucwsStatusMap = _ucwsStatusMap;

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServicesStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServicesStatus");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext, false);
			const _ucconnectstatus = AsnMgmtEUCWSStatus_Converter.fromJSON(s.ucConnectStatus, errors, newContext, "ucConnectStatus", false);
			if (_ucconnectstatus)
				t.ucConnectStatus = _ucconnectstatus;
			const _ucwsstatusmap = AsnMgmtEUCWSStatusList_Converter.fromJSON(s.ucwsStatusMap, errors, newContext, "ucwsStatusMap", false);
			if (_ucwsstatusmap)
				t.ucwsStatusMap = _ucwsstatusmap;
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServicesStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWebServicesStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServicesStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sUCSID", "string", errors, newContext);
		const _ucConnectStatus = AsnMgmtEUCWSStatus_Converter.toBER(s.ucConnectStatus, errors, newContext, "ucConnectStatus");
		const _ucwsStatusMap = AsnMgmtEUCWSStatusList_Converter.toBER(s.ucwsStatusMap, errors, newContext, "ucwsStatusMap");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSID, name: "u8sUCSID" }));
			if (_ucConnectStatus)
				t.push(_ucConnectStatus);
			if (_ucwsStatusMap)
				t.push(_ucwsStatusMap);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServicesStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServicesStatus");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEUCWebServicesStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sUCSID", "Utf8String", errors, newContext);
			const _ucconnectstatus = AsnMgmtEUCWSStatus_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "ucConnectStatus"), errors, newContext, "ucConnectStatus");
			if (_ucconnectstatus)
				t.ucConnectStatus = _ucconnectstatus;
			const _ucwsstatusmap = AsnMgmtEUCWSStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "ucwsStatusMap"), errors, newContext, "ucwsStatusMap");
			if (_ucwsstatusmap)
				t.ucwsStatusMap = _ucwsstatusmap;
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServicesStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWebServiceConfigList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServiceConfigList");

		const t = [] as ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtEUCWebServiceConfig_Converter.toJSON(se, errors, newContext, "AsnMgmtEUCWebServiceConfig");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfigList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServiceConfigList");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtEUCWebServiceConfig_Converter.fromJSON(se, errors, newContext, "AsnMgmtEUCWebServiceConfig", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfigList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWebServiceConfigList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServiceConfigList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtEUCWebServiceConfig_Converter.toBER(s[id], errors, newContext, "AsnMgmtEUCWebServiceConfig");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfigList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServiceConfigList");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtEUCWebServiceConfigList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtEUCWebServiceConfig_Converter.fromBER(se, errors, newContext, "AsnMgmtEUCWebServiceConfig", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfigList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtEUCWebServiceConfig4Admin_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServiceConfig4Admin");

		const t = {} as ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtEUCWebServiceConfig4Admin";
		TSConverter.fillJSONParam(s, t, "u8sServicesUser", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServicesPassword", "string", errors, newContext);
		const _configList = AsnMgmtEUCWebServiceConfigList_Converter.toJSON(s.configList, errors, newContext, "configList");
		if (_configList)
			t.configList = _configList;

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig4Admin"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServiceConfig4Admin");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sServicesUser", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServicesPassword", "string", errors, newContext, false);
			const _configlist = AsnMgmtEUCWebServiceConfigList_Converter.fromJSON(s.configList, errors, newContext, "configList", false);
			if (_configlist)
				t.configList = _configlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig4Admin"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtEUCWebServiceConfig4Admin";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtEUCWebServiceConfig4Admin");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sServicesUser", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sServicesPassword", "string", errors, newContext);
		const _configList = AsnMgmtEUCWebServiceConfigList_Converter.toBER(s.configList, errors, newContext, "configList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sServicesUser, name: "u8sServicesUser" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServicesPassword, name: "u8sServicesPassword" }));
			if (_configList)
				t.push(_configList);
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig4Admin"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtEUCWebServiceConfig4Admin");

		let t: ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtEUCWebServiceConfig4Admin["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sServicesUser", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServicesPassword", "Utf8String", errors, newContext);
			const _configlist = AsnMgmtEUCWebServiceConfigList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "configList"), errors, newContext, "configList");
			if (_configlist)
				t.configList = _configlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtEUCWebServiceConfig4Admin"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLocalWebServiceConfig4AdminResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLocalWebServiceConfig4AdminResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLocalWebServiceConfig4AdminResult";
		const _configs = AsnMgmtEUCWebServiceConfigList_Converter.toJSON(s.configs, errors, newContext, "configs");
		if (_configs)
			t.configs = _configs;

		if (errors.validateResult(newContext, "AsnMgmtGetLocalWebServiceConfig4AdminResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLocalWebServiceConfig4AdminResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _configs = AsnMgmtEUCWebServiceConfigList_Converter.fromJSON(s.configs, errors, newContext, "configs", false);
			if (_configs)
				t.configs = _configs;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocalWebServiceConfig4AdminResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLocalWebServiceConfig4AdminResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLocalWebServiceConfig4AdminResult");

		// [Print_BER_EncoderSeqDefCode]
		const _configs = AsnMgmtEUCWebServiceConfigList_Converter.toBER(s.configs, errors, newContext, "configs");
		if (!errors.hasNewErrors()) {
			if (_configs)
				t.push(_configs);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocalWebServiceConfig4AdminResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLocalWebServiceConfig4AdminResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLocalWebServiceConfig4AdminResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _configs = AsnMgmtEUCWebServiceConfigList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "configs"), errors, newContext, "configs");
			if (_configs)
				t.configs = _configs;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocalWebServiceConfig4AdminResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUCConnectSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUCConnectSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUCConnectSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUCConnectSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtUCConnectSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUCConnectSettings";
		TSConverter.fillJSONParam(s, t, "iMobileAccessOption", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sControllerAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUCSPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sAccountMail", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTurnEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPushServiceAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPushPolicyAccepted", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPortalAddress", "string", errors, newContext);
		const _webServiceExternalAccess = AsnMgmtWebServiceAccessParams_Converter.toJSON(s.webServiceExternalAccess, errors, newContext, "webServiceExternalAccess");
		if (_webServiceExternalAccess)
			t.webServiceExternalAccess = _webServiceExternalAccess;
		TSConverter.fillJSONParam(s, t, "bUseProxy", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyUser", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sBypassServer", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtUCConnectSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUCConnectSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUCConnectSettings");

		let t: ENetUC_Mgmt.AsnMgmtUCConnectSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUCConnectSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUCConnectSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iMobileAccessOption", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sControllerAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUCSPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sAccountMail", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTurnEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPushServiceAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPushPolicyAccepted", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPortalAddress", "string", errors, newContext, false);
			const _webserviceexternalaccess = AsnMgmtWebServiceAccessParams_Converter.fromJSON(s.webServiceExternalAccess, errors, newContext, "webServiceExternalAccess", false);
			if (_webserviceexternalaccess)
				t.webServiceExternalAccess = _webserviceexternalaccess;
			TSConverter.fillJSONParam(s, t, "bUseProxy", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyUser", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sBypassServer", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtUCConnectSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUCConnectSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUCConnectSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUCConnectSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iMobileAccessOption", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sUCSID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sControllerAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUCSPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sAccountMail", "string", errors, newContext);
		TSConverter.validateParam(s, "iTurnEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sPushServiceAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iPushPolicyAccepted", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sPortalAddress", "string", errors, newContext);
		const _webServiceExternalAccess = AsnMgmtWebServiceAccessParams_Converter.toBER(s.webServiceExternalAccess, errors, newContext, "webServiceExternalAccess");
		TSConverter.validateParam(s, "bUseProxy", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyServer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyUser", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sBypassServer", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iMobileAccessOption, name: "iMobileAccessOption" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSID, name: "u8sUCSID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sControllerAddress, name: "u8sControllerAddress" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSPassword, name: "u8sUCSPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sAccountMail, name: "u8sAccountMail" }));
			t.push(new asn1ts.Integer({ value: s.iTurnEnabled, name: "iTurnEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPushServiceAddress, name: "u8sPushServiceAddress" }));
			t.push(new asn1ts.Integer({ value: s.iPushPolicyAccepted, name: "iPushPolicyAccepted" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPortalAddress, name: "u8sPortalAddress" }));
			if (_webServiceExternalAccess)
				t.push(_webServiceExternalAccess);
			t.push(new asn1ts.Integer({ value: s.bUseProxy, name: "bUseProxy" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyServer, name: "u8sProxyServer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyUser, name: "u8sProxyUser" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyPassword, name: "u8sProxyPassword" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sBypassServer, name: "u8sBypassServer" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtUCConnectSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUCConnectSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUCConnectSettings");

		let t: ENetUC_Mgmt.AsnMgmtUCConnectSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUCConnectSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUCConnectSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iMobileAccessOption", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUCSID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sControllerAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUCSPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sAccountMail", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTurnEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPushServiceAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPushPolicyAccepted", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPortalAddress", "Utf8String", errors, newContext);
			const _webserviceexternalaccess = AsnMgmtWebServiceAccessParams_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "webServiceExternalAccess"), errors, newContext, "webServiceExternalAccess");
			if (_webserviceexternalaccess)
				t.webServiceExternalAccess = _webserviceexternalaccess;
			TSConverter.fillASN1Param(s, t, "bUseProxy", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyUser", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sBypassServer", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtUCConnectSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetDatabaseManagerSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetDatabaseManagerSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetDatabaseManagerSettingsResult";
		const _settings = AsnMgmtDatabaseManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetDatabaseManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetDatabaseManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtDatabaseManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDatabaseManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetDatabaseManagerSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetDatabaseManagerSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtDatabaseManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDatabaseManagerSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetDatabaseManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetDatabaseManagerSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtDatabaseManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDatabaseManagerSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetDatabaseManagerSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetDatabaseManagerSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetDatabaseManagerSettingsArgument";
		const _settings = AsnMgmtDatabaseManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetDatabaseManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetDatabaseManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtDatabaseManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetDatabaseManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetDatabaseManagerSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetDatabaseManagerSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtDatabaseManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetDatabaseManagerSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetDatabaseManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetDatabaseManagerSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtDatabaseManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetDatabaseManagerSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAvailableDatabasesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableDatabasesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAvailableDatabasesArgument";
		const _settings = AsnMgmtDatabaseManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableDatabasesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtDatabaseManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAvailableDatabasesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableDatabasesArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtDatabaseManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableDatabasesArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableDatabasesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtDatabaseManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableDatabasesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnListeningInterfaceList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnListeningInterfaceList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnListeningInterfaceList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterfaceList");

		const t = [] as ENetUC_Mgmt.AsnListeningInterfaceList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnListeningInterface_Converter.toJSON(se, errors, newContext, "AsnListeningInterface");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterfaceList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterfaceList");

		let t: ENetUC_Mgmt.AsnListeningInterfaceList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnListeningInterfaceList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnListeningInterfaceList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnListeningInterface_Converter.fromJSON(se, errors, newContext, "AsnListeningInterface", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnListeningInterfaceList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnListeningInterfaceList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterfaceList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnListeningInterface_Converter.toBER(s[id], errors, newContext, "AsnListeningInterface");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnListeningInterfaceList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterfaceList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterfaceList");

		let t: ENetUC_Mgmt.AsnListeningInterfaceList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnListeningInterfaceList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnListeningInterfaceList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnListeningInterface_Converter.fromBER(se, errors, newContext, "AsnListeningInterface", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetListeningInterfacesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetListeningInterfacesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetListeningInterfacesResult";
		const _listeningInterfaces = AsnListeningInterfaceList_Converter.toJSON(s.listeningInterfaces, errors, newContext, "listeningInterfaces");
		if (_listeningInterfaces)
			t.listeningInterfaces = _listeningInterfaces;
		TSConverter.fillJSONParam(s, t, "u8sServerNameFQDN", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSupportedListenInterfaceTypes", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfacesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetListeningInterfacesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listeninginterfaces = AsnListeningInterfaceList_Converter.fromJSON(s.listeningInterfaces, errors, newContext, "listeningInterfaces", false);
			if (_listeninginterfaces)
				t.listeningInterfaces = _listeninginterfaces;
			TSConverter.fillJSONParam(s, t, "u8sServerNameFQDN", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSupportedListenInterfaceTypes", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfacesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetListeningInterfacesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetListeningInterfacesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _listeningInterfaces = AsnListeningInterfaceList_Converter.toBER(s.listeningInterfaces, errors, newContext, "listeningInterfaces");
		TSConverter.validateParam(s, "u8sServerNameFQDN", "string", errors, newContext);
		TSConverter.validateParam(s, "iSupportedListenInterfaceTypes", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_listeningInterfaces)
				t.push(_listeningInterfaces);
			t.push(new asn1ts.Utf8String({ value: s.u8sServerNameFQDN, name: "u8sServerNameFQDN" }));
			t.push(new asn1ts.Integer({ value: s.iSupportedListenInterfaceTypes, name: "iSupportedListenInterfaceTypes" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfacesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetListeningInterfacesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetListeningInterfacesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listeninginterfaces = AsnListeningInterfaceList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listeningInterfaces"), errors, newContext, "listeningInterfaces");
			if (_listeninginterfaces)
				t.listeningInterfaces = _listeninginterfaces;
			TSConverter.fillASN1Param(s, t, "u8sServerNameFQDN", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSupportedListenInterfaceTypes", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfacesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetListeningInterfacesArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetListeningInterfacesArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetListeningInterfacesArgument";
		const _listeningInterfaces = AsnListeningInterfaceList_Converter.toJSON(s.listeningInterfaces, errors, newContext, "listeningInterfaces");
		if (_listeningInterfaces)
			t.listeningInterfaces = _listeningInterfaces;
		TSConverter.fillJSONParam(s, t, "bDisconnectClients", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtSetListeningInterfacesArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetListeningInterfacesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listeninginterfaces = AsnListeningInterfaceList_Converter.fromJSON(s.listeningInterfaces, errors, newContext, "listeningInterfaces", false);
			if (_listeninginterfaces)
				t.listeningInterfaces = _listeninginterfaces;
			TSConverter.fillJSONParam(s, t, "bDisconnectClients", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetListeningInterfacesArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetListeningInterfacesArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetListeningInterfacesArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listeningInterfaces = AsnListeningInterfaceList_Converter.toBER(s.listeningInterfaces, errors, newContext, "listeningInterfaces");
		TSConverter.validateParam(s, "bDisconnectClients", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_listeningInterfaces)
				t.push(_listeningInterfaces);
			t.push(new asn1ts.Boolean({ value: s.bDisconnectClients, name: "bDisconnectClients" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetListeningInterfacesArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetListeningInterfacesArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetListeningInterfacesArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listeninginterfaces = AsnListeningInterfaceList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listeningInterfaces"), errors, newContext, "listeningInterfaces");
			if (_listeninginterfaces)
				t.listeningInterfaces = _listeninginterfaces;
			TSConverter.fillASN1Param(s, t, "bDisconnectClients", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetListeningInterfacesArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnListeningInterfaceStatusList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnListeningInterfaceStatusList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnListeningInterfaceStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterfaceStatusList");

		const t = [] as ENetUC_Mgmt.AsnListeningInterfaceStatusList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnListeningInterfaceStatus_Converter.toJSON(se, errors, newContext, "AsnListeningInterfaceStatus");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatusList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterfaceStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterfaceStatusList");

		let t: ENetUC_Mgmt.AsnListeningInterfaceStatusList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnListeningInterfaceStatusList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnListeningInterfaceStatusList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnListeningInterfaceStatus_Converter.fromJSON(se, errors, newContext, "AsnListeningInterfaceStatus", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatusList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnListeningInterfaceStatusList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnListeningInterfaceStatusList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListeningInterfaceStatusList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnListeningInterfaceStatus_Converter.toBER(s[id], errors, newContext, "AsnListeningInterfaceStatus");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnListeningInterfaceStatusList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListeningInterfaceStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListeningInterfaceStatusList");

		let t: ENetUC_Mgmt.AsnListeningInterfaceStatusList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnListeningInterfaceStatusList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnListeningInterfaceStatusList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnListeningInterfaceStatus_Converter.fromBER(se, errors, newContext, "AsnListeningInterfaceStatus", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnListeningInterfaceStatusList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetListeningInterfaceStatusesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetListeningInterfaceStatusesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetListeningInterfaceStatusesResult";
		const _listeningInterfaceStatuses = AsnListeningInterfaceStatusList_Converter.toJSON(s.listeningInterfaceStatuses, errors, newContext, "listeningInterfaceStatuses");
		if (_listeningInterfaceStatuses)
			t.listeningInterfaceStatuses = _listeningInterfaceStatuses;

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfaceStatusesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetListeningInterfaceStatusesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listeninginterfacestatuses = AsnListeningInterfaceStatusList_Converter.fromJSON(s.listeningInterfaceStatuses, errors, newContext, "listeningInterfaceStatuses", false);
			if (_listeninginterfacestatuses)
				t.listeningInterfaceStatuses = _listeninginterfacestatuses;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfaceStatusesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetListeningInterfaceStatusesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetListeningInterfaceStatusesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _listeningInterfaceStatuses = AsnListeningInterfaceStatusList_Converter.toBER(s.listeningInterfaceStatuses, errors, newContext, "listeningInterfaceStatuses");
		if (!errors.hasNewErrors()) {
			if (_listeningInterfaceStatuses)
				t.push(_listeningInterfaceStatuses);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfaceStatusesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetListeningInterfaceStatusesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetListeningInterfaceStatusesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listeninginterfacestatuses = AsnListeningInterfaceStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listeningInterfaceStatuses"), errors, newContext, "listeningInterfaceStatuses");
			if (_listeninginterfacestatuses)
				t.listeningInterfaceStatuses = _listeninginterfacestatuses;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetListeningInterfaceStatusesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnListenInterfaceStatusesEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnListenInterfaceStatusesEventArgument";
		const _statuses = AsnListeningInterfaceStatusList_Converter.toJSON(s.statuses, errors, newContext, "statuses");
		if (_statuses)
			t.statuses = _statuses;

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _statuses = AsnListeningInterfaceStatusList_Converter.fromJSON(s.statuses, errors, newContext, "statuses", false);
			if (_statuses)
				t.statuses = _statuses;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnListenInterfaceStatusesEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _statuses = AsnListeningInterfaceStatusList_Converter.toBER(s.statuses, errors, newContext, "statuses");
		if (!errors.hasNewErrors()) {
			if (_statuses)
				t.push(_statuses);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _statuses = AsnListeningInterfaceStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "statuses"), errors, newContext, "statuses");
			if (_statuses)
				t.statuses = _statuses;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnListenInterfaceStatusesChangedEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnListenInterfaceStatusesChangedEventArgument";
		const _statusesAdded = AsnListeningInterfaceStatusList_Converter.toJSON(s.statusesAdded, errors, newContext, "statusesAdded");
		if (_statusesAdded)
			t.statusesAdded = _statusesAdded;
		const _statusesUpdated = AsnListeningInterfaceStatusList_Converter.toJSON(s.statusesUpdated, errors, newContext, "statusesUpdated");
		if (_statusesUpdated)
			t.statusesUpdated = _statusesUpdated;
		const _statusesRemoved = AsnListeningInterfaceStatusList_Converter.toJSON(s.statusesRemoved, errors, newContext, "statusesRemoved");
		if (_statusesRemoved)
			t.statusesRemoved = _statusesRemoved;

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _statusesadded = AsnListeningInterfaceStatusList_Converter.fromJSON(s.statusesAdded, errors, newContext, "statusesAdded", false);
			if (_statusesadded)
				t.statusesAdded = _statusesadded;
			const _statusesupdated = AsnListeningInterfaceStatusList_Converter.fromJSON(s.statusesUpdated, errors, newContext, "statusesUpdated", false);
			if (_statusesupdated)
				t.statusesUpdated = _statusesupdated;
			const _statusesremoved = AsnListeningInterfaceStatusList_Converter.fromJSON(s.statusesRemoved, errors, newContext, "statusesRemoved", false);
			if (_statusesremoved)
				t.statusesRemoved = _statusesremoved;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnListenInterfaceStatusesChangedEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _statusesAdded = AsnListeningInterfaceStatusList_Converter.toBER(s.statusesAdded, errors, newContext, "statusesAdded");
		const _statusesUpdated = AsnListeningInterfaceStatusList_Converter.toBER(s.statusesUpdated, errors, newContext, "statusesUpdated");
		const _statusesRemoved = AsnListeningInterfaceStatusList_Converter.toBER(s.statusesRemoved, errors, newContext, "statusesRemoved");
		if (!errors.hasNewErrors()) {
			if (_statusesAdded)
				t.push(_statusesAdded);
			if (_statusesUpdated)
				t.push(_statusesUpdated);
			if (_statusesRemoved)
				t.push(_statusesRemoved);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnListenInterfaceStatusesChangedEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _statusesadded = AsnListeningInterfaceStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "statusesAdded"), errors, newContext, "statusesAdded");
			if (_statusesadded)
				t.statusesAdded = _statusesadded;
			const _statusesupdated = AsnListeningInterfaceStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "statusesUpdated"), errors, newContext, "statusesUpdated");
			if (_statusesupdated)
				t.statusesUpdated = _statusesupdated;
			const _statusesremoved = AsnListeningInterfaceStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "statusesRemoved"), errors, newContext, "statusesRemoved");
			if (_statusesremoved)
				t.statusesRemoved = _statusesremoved;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnListenInterfaceStatusesChangedEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtLogFileSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtLogFileSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtLogFileSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLogFileSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtLogFileSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtLogFileSettings";
		TSConverter.fillJSONParam(s, t, "iWindowsEventLogLevel", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLogLevel", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNumberOfLogfilesToKeep", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMailToAdmin", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLogfileSize", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLogFilePath", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPerformanceMonitoring", "number", errors, newContext);
		const _mediaServerLogFileSettings = AsnMediaServerLogFile_Converter.toJSON(s.mediaServerLogFileSettings, errors, newContext, "mediaServerLogFileSettings");
		if (_mediaServerLogFileSettings)
			t.mediaServerLogFileSettings = _mediaServerLogFileSettings;

		if (errors.validateResult(newContext, "AsnMgmtLogFileSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLogFileSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLogFileSettings");

		let t: ENetUC_Mgmt.AsnMgmtLogFileSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtLogFileSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtLogFileSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iWindowsEventLogLevel", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLogLevel", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNumberOfLogfilesToKeep", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMailToAdmin", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLogfileSize", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLogFilePath", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPerformanceMonitoring", "number", errors, newContext, false);
			const _mediaserverlogfilesettings = AsnMediaServerLogFile_Converter.fromJSON(s.mediaServerLogFileSettings, errors, newContext, "mediaServerLogFileSettings", false);
			if (_mediaserverlogfilesettings)
				t.mediaServerLogFileSettings = _mediaserverlogfilesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtLogFileSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtLogFileSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtLogFileSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtLogFileSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iWindowsEventLogLevel", "number", errors, newContext);
		TSConverter.validateParam(s, "iLogLevel", "number", errors, newContext);
		TSConverter.validateParam(s, "iNumberOfLogfilesToKeep", "number", errors, newContext);
		TSConverter.validateParam(s, "iMailToAdmin", "number", errors, newContext);
		TSConverter.validateParam(s, "iLogfileSize", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLogFilePath", "string", errors, newContext);
		TSConverter.validateParam(s, "iPerformanceMonitoring", "number", errors, newContext);
		const _mediaServerLogFileSettings = AsnMediaServerLogFile_Converter.toBER(s.mediaServerLogFileSettings, errors, newContext, "mediaServerLogFileSettings");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iWindowsEventLogLevel, name: "iWindowsEventLogLevel" }));
			t.push(new asn1ts.Integer({ value: s.iLogLevel, name: "iLogLevel" }));
			t.push(new asn1ts.Integer({ value: s.iNumberOfLogfilesToKeep, name: "iNumberOfLogfilesToKeep" }));
			t.push(new asn1ts.Integer({ value: s.iMailToAdmin, name: "iMailToAdmin" }));
			t.push(new asn1ts.Integer({ value: s.iLogfileSize, name: "iLogfileSize" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLogFilePath, name: "u8sLogFilePath" }));
			t.push(new asn1ts.Integer({ value: s.iPerformanceMonitoring, name: "iPerformanceMonitoring" }));
			if (_mediaServerLogFileSettings)
				t.push(_mediaServerLogFileSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtLogFileSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtLogFileSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtLogFileSettings");

		let t: ENetUC_Mgmt.AsnMgmtLogFileSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtLogFileSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtLogFileSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iWindowsEventLogLevel", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLogLevel", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNumberOfLogfilesToKeep", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMailToAdmin", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLogfileSize", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLogFilePath", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPerformanceMonitoring", "Integer", errors, newContext);
			const _mediaserverlogfilesettings = AsnMediaServerLogFile_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "mediaServerLogFileSettings"), errors, newContext, "mediaServerLogFileSettings");
			if (_mediaserverlogfilesettings)
				t.mediaServerLogFileSettings = _mediaserverlogfilesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtLogFileSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLogFileSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLogFileSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLogFileSettingsResult";
		const _logfileSettings = AsnMgmtLogFileSettings_Converter.toJSON(s.logfileSettings, errors, newContext, "logfileSettings");
		if (_logfileSettings)
			t.logfileSettings = _logfileSettings;

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLogFileSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _logfilesettings = AsnMgmtLogFileSettings_Converter.fromJSON(s.logfileSettings, errors, newContext, "logfileSettings", false);
			if (_logfilesettings)
				t.logfileSettings = _logfilesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLogFileSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLogFileSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _logfileSettings = AsnMgmtLogFileSettings_Converter.toBER(s.logfileSettings, errors, newContext, "logfileSettings");
		if (!errors.hasNewErrors()) {
			if (_logfileSettings)
				t.push(_logfileSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLogFileSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLogFileSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _logfilesettings = AsnMgmtLogFileSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "logfileSettings"), errors, newContext, "logfileSettings");
			if (_logfilesettings)
				t.logfileSettings = _logfilesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLogFileSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLogFileSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLogFileSettingsArgument";
		const _logfileSettings = AsnMgmtLogFileSettings_Converter.toJSON(s.logfileSettings, errors, newContext, "logfileSettings");
		if (_logfileSettings)
			t.logfileSettings = _logfileSettings;

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLogFileSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _logfilesettings = AsnMgmtLogFileSettings_Converter.fromJSON(s.logfileSettings, errors, newContext, "logfileSettings", false);
			if (_logfilesettings)
				t.logfileSettings = _logfilesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLogFileSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLogFileSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _logfileSettings = AsnMgmtLogFileSettings_Converter.toBER(s.logfileSettings, errors, newContext, "logfileSettings");
		if (!errors.hasNewErrors()) {
			if (_logfileSettings)
				t.push(_logfileSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLogFileSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLogFileSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _logfilesettings = AsnMgmtLogFileSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "logfileSettings"), errors, newContext, "logfileSettings");
			if (_logfilesettings)
				t.logfileSettings = _logfilesettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLogFileSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNumberFormatRegExpressListMgmt_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressListMgmt");

		const t = [] as ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnNumberFormatRegExpressionMgmt_Converter.toJSON(se, errors, newContext, "AsnNumberFormatRegExpressionMgmt");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressListMgmt"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressListMgmt");

		let t: ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnNumberFormatRegExpressionMgmt_Converter.fromJSON(se, errors, newContext, "AsnNumberFormatRegExpressionMgmt", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressListMgmt"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNumberFormatRegExpressListMgmt";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressListMgmt");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnNumberFormatRegExpressionMgmt_Converter.toBER(s[id], errors, newContext, "AsnNumberFormatRegExpressionMgmt");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressListMgmt"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressListMgmt");

		let t: ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnNumberFormatRegExpressListMgmt();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnNumberFormatRegExpressionMgmt_Converter.fromBER(se, errors, newContext, "AsnNumberFormatRegExpressionMgmt", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressListMgmt"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNumberFormatRegExpressionsMgmt_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressionsMgmt");

		const t = {} as ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNumberFormatRegExpressionsMgmt";
		TSConverter.fillJSONParam(s, t, "bIsReadOnlyFromFile", "boolean", errors, newContext);
		const _formatRules = AsnNumberFormatRegExpressListMgmt_Converter.toJSON(s.formatRules, errors, newContext, "formatRules");
		if (_formatRules)
			t.formatRules = _formatRules;

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionsMgmt"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressionsMgmt");

		let t: ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bIsReadOnlyFromFile", "boolean", errors, newContext, false);
			const _formatrules = AsnNumberFormatRegExpressListMgmt_Converter.fromJSON(s.formatRules, errors, newContext, "formatRules", false);
			if (_formatrules)
				t.formatRules = _formatrules;
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionsMgmt"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNumberFormatRegExpressionsMgmt";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNumberFormatRegExpressionsMgmt");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bIsReadOnlyFromFile", "boolean", errors, newContext);
		const _formatRules = AsnNumberFormatRegExpressListMgmt_Converter.toBER(s.formatRules, errors, newContext, "formatRules");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bIsReadOnlyFromFile, name: "bIsReadOnlyFromFile" }));
			if (_formatRules)
				t.push(_formatRules);
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionsMgmt"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNumberFormatRegExpressionsMgmt");

		let t: ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnNumberFormatRegExpressionsMgmt["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bIsReadOnlyFromFile", "Boolean", errors, newContext);
			const _formatrules = AsnNumberFormatRegExpressListMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "formatRules"), errors, newContext, "formatRules");
			if (_formatrules)
				t.formatRules = _formatrules;
		}

		if (errors.validateResult(newContext, "AsnNumberFormatRegExpressionsMgmt"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnRuleSoftphoneEmergencyMgmtListMgmt_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmtListMgmt");

		const t = [] as ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnRuleSoftphoneEmergencyMgmt_Converter.toJSON(se, errors, newContext, "AsnRuleSoftphoneEmergencyMgmt");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmtListMgmt"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmtListMgmt");

		let t: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnRuleSoftphoneEmergencyMgmt_Converter.fromJSON(se, errors, newContext, "AsnRuleSoftphoneEmergencyMgmt", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmtListMgmt"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnRuleSoftphoneEmergencyMgmtListMgmt";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmtListMgmt");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnRuleSoftphoneEmergencyMgmt_Converter.toBER(s[id], errors, newContext, "AsnRuleSoftphoneEmergencyMgmt");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmtListMgmt"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnRuleSoftphoneEmergencyMgmtListMgmt");

		let t: ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnRuleSoftphoneEmergencyMgmtListMgmt();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnRuleSoftphoneEmergencyMgmt_Converter.fromBER(se, errors, newContext, "AsnRuleSoftphoneEmergencyMgmt", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnRuleSoftphoneEmergencyMgmtListMgmt"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnELocalDialingRuleForeignPNALocalCallItemList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItemList");

		const t = [] as ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnELocalDialingRuleForeignPNALocalCallItem_Converter.toJSON(se, errors, newContext, "AsnELocalDialingRuleForeignPNALocalCallItem");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItemList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItemList");

		let t: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnELocalDialingRuleForeignPNALocalCallItem_Converter.fromJSON(se, errors, newContext, "AsnELocalDialingRuleForeignPNALocalCallItem", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItemList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnELocalDialingRuleForeignPNALocalCallItemList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItemList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnELocalDialingRuleForeignPNALocalCallItem_Converter.toBER(s[id], errors, newContext, "AsnELocalDialingRuleForeignPNALocalCallItem");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItemList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELocalDialingRuleForeignPNALocalCallItemList");

		let t: ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnELocalDialingRuleForeignPNALocalCallItemList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnELocalDialingRuleForeignPNALocalCallItem_Converter.fromBER(se, errors, newContext, "AsnELocalDialingRuleForeignPNALocalCallItem", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnELocalDialingRuleForeignPNALocalCallItemList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnELCRProviderList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnELCRProviderList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnELCRProviderList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRProviderList");

		const t = [] as ENetUC_Mgmt.AsnELCRProviderList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnELCRProvider_Converter.toJSON(se, errors, newContext, "AsnELCRProvider");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnELCRProviderList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRProviderList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRProviderList");

		let t: ENetUC_Mgmt.AsnELCRProviderList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnELCRProviderList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnELCRProviderList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnELCRProvider_Converter.fromJSON(se, errors, newContext, "AsnELCRProvider", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnELCRProviderList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnELCRProviderList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnELCRProviderList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRProviderList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnELCRProvider_Converter.toBER(s[id], errors, newContext, "AsnELCRProvider");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnELCRProviderList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRProviderList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRProviderList");

		let t: ENetUC_Mgmt.AsnELCRProviderList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnELCRProviderList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnELCRProviderList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnELCRProvider_Converter.fromBER(se, errors, newContext, "AsnELCRProvider", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnELCRProviderList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnELCRZoneList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnELCRZoneList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnELCRZoneList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRZoneList");

		const t = [] as ENetUC_Mgmt.AsnELCRZoneList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnELCRZone_Converter.toJSON(se, errors, newContext, "AsnELCRZone");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnELCRZoneList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRZoneList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRZoneList");

		let t: ENetUC_Mgmt.AsnELCRZoneList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnELCRZoneList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnELCRZoneList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnELCRZone_Converter.fromJSON(se, errors, newContext, "AsnELCRZone", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnELCRZoneList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnELCRZoneList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnELCRZoneList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnELCRZoneList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnELCRZone_Converter.toBER(s[id], errors, newContext, "AsnELCRZone");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnELCRZoneList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnELCRZoneList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnELCRZoneList");

		let t: ENetUC_Mgmt.AsnELCRZoneList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnELCRZoneList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnELCRZoneList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnELCRZone_Converter.fromBER(se, errors, newContext, "AsnELCRZone", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnELCRZoneList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnLocationInformationMgmt_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnLocationInformationMgmt, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnLocationInformationMgmt & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLocationInformationMgmt");

		const t = {} as ENetUC_Mgmt.AsnLocationInformationMgmt & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnLocationInformationMgmt";
		TSConverter.fillJSONParam(s, t, "u8sLocationCheckSum", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iCountryID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCountryCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNationalPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sInternationalPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalDialingRule", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sNationalDialingRule", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sInternationalDialingRule", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalDialingRuleHomePNALocal", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalDialingRuleHomePNAToll", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalDialingRuleForeignPNALocal", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCityCodeNoPrefix", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bNoLocalDialing", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sVanityNumbers", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseVanity", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRemoteTapiNumberFormat", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRemoteTapiDialFormat", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRemoteTapiLineNames", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDialingNumberFormat", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bFixedNumberLenExtensionDTMFDialing", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMobileDeviceLocation", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bShowExtendedSettings", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bMultiLocationSupport", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAutoCreateOtherLocationRules", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bAllowNumberSearchOtherLocations", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bShortenOtherLocationSCNumbersForDialing", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUseTkSystem", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKAnschlussNr", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDDIRangeBegin", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDDIRangeEnd", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKLocalAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKLongDistanceAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKInternationalAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKPrivateAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTKForwardingAccessCode", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTKMinLenInternalNumbers", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iTKMaxLenInternalNumbers", "number", errors, newContext);
		const _u8slistTKAkzListRemoveIn = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTKAkzListRemoveIn, errors, newContext, "u8slistTKAkzListRemoveIn");
		if (_u8slistTKAkzListRemoveIn)
			t.u8slistTKAkzListRemoveIn = _u8slistTKAkzListRemoveIn;
		const _u8slistTKAkzListRemoveOut = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTKAkzListRemoveOut, errors, newContext, "u8slistTKAkzListRemoveOut");
		if (_u8slistTKAkzListRemoveOut)
			t.u8slistTKAkzListRemoveOut = _u8slistTKAkzListRemoveOut;
		const _u8slistTKAkzListRemoveForwarding = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTKAkzListRemoveForwarding, errors, newContext, "u8slistTKAkzListRemoveForwarding");
		if (_u8slistTKAkzListRemoveForwarding)
			t.u8slistTKAkzListRemoveForwarding = _u8slistTKAkzListRemoveForwarding;
		TSConverter.fillJSONParam(s, t, "iConnectedIDDealing", "number", errors, newContext);
		const _u8slistTKAkzListRemoveConnectedIDIn = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTKAkzListRemoveConnectedIDIn, errors, newContext, "u8slistTKAkzListRemoveConnectedIDIn");
		if (_u8slistTKAkzListRemoveConnectedIDIn)
			t.u8slistTKAkzListRemoveConnectedIDIn = _u8slistTKAkzListRemoveConnectedIDIn;
		const _u8slistTKAkzListRemoveConnectedIDOut = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistTKAkzListRemoveConnectedIDOut, errors, newContext, "u8slistTKAkzListRemoveConnectedIDOut");
		if (_u8slistTKAkzListRemoveConnectedIDOut)
			t.u8slistTKAkzListRemoveConnectedIDOut = _u8slistTKAkzListRemoveConnectedIDOut;
		const _numberFormatInternal = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatInternal, errors, newContext, "numberFormatInternal");
		if (_numberFormatInternal)
			t.numberFormatInternal = _numberFormatInternal;
		const _numberFormatExternal = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatExternal, errors, newContext, "numberFormatExternal");
		if (_numberFormatExternal)
			t.numberFormatExternal = _numberFormatExternal;
		const _numberFormatAutomaticOtherLocationsDDItoSC = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatAutomaticOtherLocationsDDItoSC, errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC");
		if (_numberFormatAutomaticOtherLocationsDDItoSC)
			t.numberFormatAutomaticOtherLocationsDDItoSC = _numberFormatAutomaticOtherLocationsDDItoSC;
		const _numberFormatAutomaticOtherLocationsSCtoDDI = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatAutomaticOtherLocationsSCtoDDI, errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI");
		if (_numberFormatAutomaticOtherLocationsSCtoDDI)
			t.numberFormatAutomaticOtherLocationsSCtoDDI = _numberFormatAutomaticOtherLocationsSCtoDDI;
		const _numberFormatRegExpressListIn = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatRegExpressListIn, errors, newContext, "numberFormatRegExpressListIn");
		if (_numberFormatRegExpressListIn)
			t.numberFormatRegExpressListIn = _numberFormatRegExpressListIn;
		const _numberFormatRegExpressListOut = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatRegExpressListOut, errors, newContext, "numberFormatRegExpressListOut");
		if (_numberFormatRegExpressListOut)
			t.numberFormatRegExpressListOut = _numberFormatRegExpressListOut;
		const _numberFormatRegExpressListDial = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatRegExpressListDial, errors, newContext, "numberFormatRegExpressListDial");
		if (_numberFormatRegExpressListDial)
			t.numberFormatRegExpressListDial = _numberFormatRegExpressListDial;
		const _numberFormatRegExpressListFinalDial = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatRegExpressListFinalDial, errors, newContext, "numberFormatRegExpressListFinalDial");
		if (_numberFormatRegExpressListFinalDial)
			t.numberFormatRegExpressListFinalDial = _numberFormatRegExpressListFinalDial;
		const _numberFormatRegExpressLinePhoneNumbers = AsnNumberFormatRegExpressionsMgmt_Converter.toJSON(s.numberFormatRegExpressLinePhoneNumbers, errors, newContext, "numberFormatRegExpressLinePhoneNumbers");
		if (_numberFormatRegExpressLinePhoneNumbers)
			t.numberFormatRegExpressLinePhoneNumbers = _numberFormatRegExpressLinePhoneNumbers;
		TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iLocalDialingRuleHomePNAFlag", "number", errors, newContext);
		const _u8slistLocalDialingRulesHomePNALocalCalls = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistLocalDialingRulesHomePNALocalCalls, errors, newContext, "u8slistLocalDialingRulesHomePNALocalCalls");
		if (_u8slistLocalDialingRulesHomePNALocalCalls)
			t.u8slistLocalDialingRulesHomePNALocalCalls = _u8slistLocalDialingRulesHomePNALocalCalls;
		const _u8slistLocalDialingRulesHomePNATollCalls = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistLocalDialingRulesHomePNATollCalls, errors, newContext, "u8slistLocalDialingRulesHomePNATollCalls");
		if (_u8slistLocalDialingRulesHomePNATollCalls)
			t.u8slistLocalDialingRulesHomePNATollCalls = _u8slistLocalDialingRulesHomePNATollCalls;
		TSConverter.fillJSONParam(s, t, "iLocalDialingRuleForeignPNAFlag", "number", errors, newContext);
		const _localDialingRuleForeignPNALocalCallItemList = AsnELocalDialingRuleForeignPNALocalCallItemList_Converter.toJSON(s.localDialingRuleForeignPNALocalCallItemList, errors, newContext, "localDialingRuleForeignPNALocalCallItemList");
		if (_localDialingRuleForeignPNALocalCallItemList)
			t.localDialingRuleForeignPNALocalCallItemList = _localDialingRuleForeignPNALocalCallItemList;
		TSConverter.fillJSONParam(s, t, "bUseAdvancedLCR", "boolean", errors, newContext);
		const _lCRProviderVector = AsnELCRProviderList_Converter.toJSON(s.lCRProviderVector, errors, newContext, "lCRProviderVector");
		if (_lCRProviderVector)
			t.lCRProviderVector = _lCRProviderVector;
		const _lCRZoneList = AsnELCRZoneList_Converter.toJSON(s.lCRZoneList, errors, newContext, "lCRZoneList");
		if (_lCRZoneList)
			t.lCRZoneList = _lCRZoneList;
		const _projectPINRules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.toJSON(s.projectPINRules, errors, newContext, "projectPINRules");
		if (_projectPINRules)
			t.projectPINRules = _projectPINRules;
		TSConverter.fillJSONParam(s, t, "bRulesSoftphoneEmergencyEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRulesSoftphoneEmergencyClientWarningEnabled", "boolean", errors, newContext);
		const _rulesSoftphoneEmergency = AsnRuleSoftphoneEmergencyMgmtListMgmt_Converter.toJSON(s.rulesSoftphoneEmergency, errors, newContext, "rulesSoftphoneEmergency");
		if (_rulesSoftphoneEmergency)
			t.rulesSoftphoneEmergency = _rulesSoftphoneEmergency;

		if (errors.validateResult(newContext, "AsnLocationInformationMgmt"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnLocationInformationMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLocationInformationMgmt");

		let t: ENetUC_Mgmt.AsnLocationInformationMgmt | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnLocationInformationMgmt>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnLocationInformationMgmt["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sLocationCheckSum", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iCountryID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCountryCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNationalPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sInternationalPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalDialingRule", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sNationalDialingRule", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sInternationalDialingRule", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalDialingRuleHomePNALocal", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalDialingRuleHomePNAToll", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalDialingRuleForeignPNALocal", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCityCodeNoPrefix", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bNoLocalDialing", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sVanityNumbers", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseVanity", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRemoteTapiNumberFormat", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRemoteTapiDialFormat", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRemoteTapiLineNames", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDialingNumberFormat", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bFixedNumberLenExtensionDTMFDialing", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMobileDeviceLocation", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bShowExtendedSettings", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bMultiLocationSupport", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAutoCreateOtherLocationRules", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bAllowNumberSearchOtherLocations", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bShortenOtherLocationSCNumbersForDialing", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUseTkSystem", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKAnschlussNr", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDDIRangeBegin", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDDIRangeEnd", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKLocalAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKLongDistanceAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKInternationalAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKPrivateAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTKForwardingAccessCode", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTKMinLenInternalNumbers", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iTKMaxLenInternalNumbers", "number", errors, newContext, false);
			const _u8slisttkakzlistremovein = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTKAkzListRemoveIn, errors, newContext, "u8slistTKAkzListRemoveIn", false);
			if (_u8slisttkakzlistremovein)
				t.u8slistTKAkzListRemoveIn = _u8slisttkakzlistremovein;
			const _u8slisttkakzlistremoveout = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTKAkzListRemoveOut, errors, newContext, "u8slistTKAkzListRemoveOut", false);
			if (_u8slisttkakzlistremoveout)
				t.u8slistTKAkzListRemoveOut = _u8slisttkakzlistremoveout;
			const _u8slisttkakzlistremoveforwarding = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTKAkzListRemoveForwarding, errors, newContext, "u8slistTKAkzListRemoveForwarding", false);
			if (_u8slisttkakzlistremoveforwarding)
				t.u8slistTKAkzListRemoveForwarding = _u8slisttkakzlistremoveforwarding;
			TSConverter.fillJSONParam(s, t, "iConnectedIDDealing", "number", errors, newContext, false);
			const _u8slisttkakzlistremoveconnectedidin = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTKAkzListRemoveConnectedIDIn, errors, newContext, "u8slistTKAkzListRemoveConnectedIDIn", false);
			if (_u8slisttkakzlistremoveconnectedidin)
				t.u8slistTKAkzListRemoveConnectedIDIn = _u8slisttkakzlistremoveconnectedidin;
			const _u8slisttkakzlistremoveconnectedidout = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistTKAkzListRemoveConnectedIDOut, errors, newContext, "u8slistTKAkzListRemoveConnectedIDOut", false);
			if (_u8slisttkakzlistremoveconnectedidout)
				t.u8slistTKAkzListRemoveConnectedIDOut = _u8slisttkakzlistremoveconnectedidout;
			const _numberformatinternal = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatInternal, errors, newContext, "numberFormatInternal", false);
			if (_numberformatinternal)
				t.numberFormatInternal = _numberformatinternal;
			const _numberformatexternal = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatExternal, errors, newContext, "numberFormatExternal", false);
			if (_numberformatexternal)
				t.numberFormatExternal = _numberformatexternal;
			const _numberformatautomaticotherlocationsdditosc = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatAutomaticOtherLocationsDDItoSC, errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC", false);
			if (_numberformatautomaticotherlocationsdditosc)
				t.numberFormatAutomaticOtherLocationsDDItoSC = _numberformatautomaticotherlocationsdditosc;
			const _numberformatautomaticotherlocationssctoddi = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatAutomaticOtherLocationsSCtoDDI, errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI", false);
			if (_numberformatautomaticotherlocationssctoddi)
				t.numberFormatAutomaticOtherLocationsSCtoDDI = _numberformatautomaticotherlocationssctoddi;
			const _numberformatregexpresslistin = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatRegExpressListIn, errors, newContext, "numberFormatRegExpressListIn", false);
			if (_numberformatregexpresslistin)
				t.numberFormatRegExpressListIn = _numberformatregexpresslistin;
			const _numberformatregexpresslistout = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatRegExpressListOut, errors, newContext, "numberFormatRegExpressListOut", false);
			if (_numberformatregexpresslistout)
				t.numberFormatRegExpressListOut = _numberformatregexpresslistout;
			const _numberformatregexpresslistdial = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatRegExpressListDial, errors, newContext, "numberFormatRegExpressListDial", false);
			if (_numberformatregexpresslistdial)
				t.numberFormatRegExpressListDial = _numberformatregexpresslistdial;
			const _numberformatregexpresslistfinaldial = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatRegExpressListFinalDial, errors, newContext, "numberFormatRegExpressListFinalDial", false);
			if (_numberformatregexpresslistfinaldial)
				t.numberFormatRegExpressListFinalDial = _numberformatregexpresslistfinaldial;
			const _numberformatregexpresslinephonenumbers = AsnNumberFormatRegExpressionsMgmt_Converter.fromJSON(s.numberFormatRegExpressLinePhoneNumbers, errors, newContext, "numberFormatRegExpressLinePhoneNumbers", false);
			if (_numberformatregexpresslinephonenumbers)
				t.numberFormatRegExpressLinePhoneNumbers = _numberformatregexpresslinephonenumbers;
			TSConverter.fillJSONParam(s, t, "u8sLocationID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iLocalDialingRuleHomePNAFlag", "number", errors, newContext, false);
			const _u8slistlocaldialingruleshomepnalocalcalls = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistLocalDialingRulesHomePNALocalCalls, errors, newContext, "u8slistLocalDialingRulesHomePNALocalCalls", false);
			if (_u8slistlocaldialingruleshomepnalocalcalls)
				t.u8slistLocalDialingRulesHomePNALocalCalls = _u8slistlocaldialingruleshomepnalocalcalls;
			const _u8slistlocaldialingruleshomepnatollcalls = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistLocalDialingRulesHomePNATollCalls, errors, newContext, "u8slistLocalDialingRulesHomePNATollCalls", false);
			if (_u8slistlocaldialingruleshomepnatollcalls)
				t.u8slistLocalDialingRulesHomePNATollCalls = _u8slistlocaldialingruleshomepnatollcalls;
			TSConverter.fillJSONParam(s, t, "iLocalDialingRuleForeignPNAFlag", "number", errors, newContext, false);
			const _localdialingruleforeignpnalocalcallitemlist = AsnELocalDialingRuleForeignPNALocalCallItemList_Converter.fromJSON(s.localDialingRuleForeignPNALocalCallItemList, errors, newContext, "localDialingRuleForeignPNALocalCallItemList", false);
			if (_localdialingruleforeignpnalocalcallitemlist)
				t.localDialingRuleForeignPNALocalCallItemList = _localdialingruleforeignpnalocalcallitemlist;
			TSConverter.fillJSONParam(s, t, "bUseAdvancedLCR", "boolean", errors, newContext, false);
			const _lcrprovidervector = AsnELCRProviderList_Converter.fromJSON(s.lCRProviderVector, errors, newContext, "lCRProviderVector", false);
			if (_lcrprovidervector)
				t.lCRProviderVector = _lcrprovidervector;
			const _lcrzonelist = AsnELCRZoneList_Converter.fromJSON(s.lCRZoneList, errors, newContext, "lCRZoneList", false);
			if (_lcrzonelist)
				t.lCRZoneList = _lcrzonelist;
			const _projectpinrules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.fromJSON(s.projectPINRules, errors, newContext, "projectPINRules", false);
			if (_projectpinrules)
				t.projectPINRules = _projectpinrules;
			TSConverter.fillJSONParam(s, t, "bRulesSoftphoneEmergencyEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRulesSoftphoneEmergencyClientWarningEnabled", "boolean", errors, newContext, false);
			const _rulessoftphoneemergency = AsnRuleSoftphoneEmergencyMgmtListMgmt_Converter.fromJSON(s.rulesSoftphoneEmergency, errors, newContext, "rulesSoftphoneEmergency", false);
			if (_rulessoftphoneemergency)
				t.rulesSoftphoneEmergency = _rulessoftphoneemergency;
		}

		if (errors.validateResult(newContext, "AsnLocationInformationMgmt"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnLocationInformationMgmt | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnLocationInformationMgmt";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnLocationInformationMgmt");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sLocationCheckSum", "string", errors, newContext);
		TSConverter.validateParam(s, "iCountryID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCountryCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNationalPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sInternationalPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalDialingRule", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sNationalDialingRule", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sInternationalDialingRule", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalDialingRuleHomePNALocal", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalDialingRuleHomePNAToll", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalDialingRuleForeignPNALocal", "string", errors, newContext);
		TSConverter.validateParam(s, "iLanguage", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCityCodeNoPrefix", "string", errors, newContext);
		TSConverter.validateParam(s, "bNoLocalDialing", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sVanityNumbers", "string", errors, newContext);
		TSConverter.validateParam(s, "bUseVanity", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iRemoteTapiNumberFormat", "number", errors, newContext);
		TSConverter.validateParam(s, "iRemoteTapiDialFormat", "number", errors, newContext);
		TSConverter.validateParam(s, "iRemoteTapiLineNames", "number", errors, newContext);
		TSConverter.validateParam(s, "iDialingNumberFormat", "number", errors, newContext);
		TSConverter.validateParam(s, "bFixedNumberLenExtensionDTMFDialing", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bMobileDeviceLocation", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bShowExtendedSettings", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bMultiLocationSupport", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAutoCreateOtherLocationRules", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bAllowNumberSearchOtherLocations", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bShortenOtherLocationSCNumbersForDialing", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bUseTkSystem", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sTKAnschlussNr", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDDIRangeBegin", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDDIRangeEnd", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKLocalAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKLongDistanceAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKInternationalAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKPrivateAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sTKForwardingAccessCode", "string", errors, newContext);
		TSConverter.validateParam(s, "iTKMinLenInternalNumbers", "number", errors, newContext);
		TSConverter.validateParam(s, "iTKMaxLenInternalNumbers", "number", errors, newContext);
		const _u8slistTKAkzListRemoveIn = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTKAkzListRemoveIn, errors, newContext, "u8slistTKAkzListRemoveIn");
		const _u8slistTKAkzListRemoveOut = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTKAkzListRemoveOut, errors, newContext, "u8slistTKAkzListRemoveOut");
		const _u8slistTKAkzListRemoveForwarding = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTKAkzListRemoveForwarding, errors, newContext, "u8slistTKAkzListRemoveForwarding");
		TSConverter.validateParam(s, "iConnectedIDDealing", "number", errors, newContext);
		const _u8slistTKAkzListRemoveConnectedIDIn = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTKAkzListRemoveConnectedIDIn, errors, newContext, "u8slistTKAkzListRemoveConnectedIDIn");
		const _u8slistTKAkzListRemoveConnectedIDOut = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistTKAkzListRemoveConnectedIDOut, errors, newContext, "u8slistTKAkzListRemoveConnectedIDOut");
		const _numberFormatInternal = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatInternal, errors, newContext, "numberFormatInternal");
		const _numberFormatExternal = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatExternal, errors, newContext, "numberFormatExternal");
		const _numberFormatAutomaticOtherLocationsDDItoSC = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatAutomaticOtherLocationsDDItoSC, errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC");
		const _numberFormatAutomaticOtherLocationsSCtoDDI = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatAutomaticOtherLocationsSCtoDDI, errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI");
		const _numberFormatRegExpressListIn = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatRegExpressListIn, errors, newContext, "numberFormatRegExpressListIn");
		const _numberFormatRegExpressListOut = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatRegExpressListOut, errors, newContext, "numberFormatRegExpressListOut");
		const _numberFormatRegExpressListDial = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatRegExpressListDial, errors, newContext, "numberFormatRegExpressListDial");
		const _numberFormatRegExpressListFinalDial = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatRegExpressListFinalDial, errors, newContext, "numberFormatRegExpressListFinalDial");
		const _numberFormatRegExpressLinePhoneNumbers = AsnNumberFormatRegExpressionsMgmt_Converter.toBER(s.numberFormatRegExpressLinePhoneNumbers, errors, newContext, "numberFormatRegExpressLinePhoneNumbers");
		TSConverter.validateParam(s, "u8sLocationID", "string", errors, newContext);
		TSConverter.validateParam(s, "iLocalDialingRuleHomePNAFlag", "number", errors, newContext);
		const _u8slistLocalDialingRulesHomePNALocalCalls = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistLocalDialingRulesHomePNALocalCalls, errors, newContext, "u8slistLocalDialingRulesHomePNALocalCalls");
		const _u8slistLocalDialingRulesHomePNATollCalls = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistLocalDialingRulesHomePNATollCalls, errors, newContext, "u8slistLocalDialingRulesHomePNATollCalls");
		TSConverter.validateParam(s, "iLocalDialingRuleForeignPNAFlag", "number", errors, newContext);
		const _localDialingRuleForeignPNALocalCallItemList = AsnELocalDialingRuleForeignPNALocalCallItemList_Converter.toBER(s.localDialingRuleForeignPNALocalCallItemList, errors, newContext, "localDialingRuleForeignPNALocalCallItemList");
		TSConverter.validateParam(s, "bUseAdvancedLCR", "boolean", errors, newContext);
		const _lCRProviderVector = AsnELCRProviderList_Converter.toBER(s.lCRProviderVector, errors, newContext, "lCRProviderVector");
		const _lCRZoneList = AsnELCRZoneList_Converter.toBER(s.lCRZoneList, errors, newContext, "lCRZoneList");
		const _projectPINRules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.toBER(s.projectPINRules, errors, newContext, "projectPINRules");
		TSConverter.validateParam(s, "bRulesSoftphoneEmergencyEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bRulesSoftphoneEmergencyClientWarningEnabled", "boolean", errors, newContext);
		const _rulesSoftphoneEmergency = AsnRuleSoftphoneEmergencyMgmtListMgmt_Converter.toBER(s.rulesSoftphoneEmergency, errors, newContext, "rulesSoftphoneEmergency");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationCheckSum, name: "u8sLocationCheckSum" }));
			t.push(new asn1ts.Integer({ value: s.iCountryID, name: "iCountryID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCountryCode, name: "u8sCountryCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalPrefix, name: "u8sLocalPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNationalPrefix, name: "u8sNationalPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sInternationalPrefix, name: "u8sInternationalPrefix" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalDialingRule, name: "u8sLocalDialingRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sNationalDialingRule, name: "u8sNationalDialingRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sInternationalDialingRule, name: "u8sInternationalDialingRule" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalDialingRuleHomePNALocal, name: "u8sLocalDialingRuleHomePNALocal" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalDialingRuleHomePNAToll, name: "u8sLocalDialingRuleHomePNAToll" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalDialingRuleForeignPNALocal, name: "u8sLocalDialingRuleForeignPNALocal" }));
			t.push(new asn1ts.Integer({ value: s.iLanguage, name: "iLanguage" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCityCodeNoPrefix, name: "u8sCityCodeNoPrefix" }));
			t.push(new asn1ts.Boolean({ value: s.bNoLocalDialing, name: "bNoLocalDialing" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sVanityNumbers, name: "u8sVanityNumbers" }));
			t.push(new asn1ts.Boolean({ value: s.bUseVanity, name: "bUseVanity" }));
			t.push(new asn1ts.Integer({ value: s.iRemoteTapiNumberFormat, name: "iRemoteTapiNumberFormat" }));
			t.push(new asn1ts.Integer({ value: s.iRemoteTapiDialFormat, name: "iRemoteTapiDialFormat" }));
			t.push(new asn1ts.Integer({ value: s.iRemoteTapiLineNames, name: "iRemoteTapiLineNames" }));
			t.push(new asn1ts.Integer({ value: s.iDialingNumberFormat, name: "iDialingNumberFormat" }));
			t.push(new asn1ts.Boolean({ value: s.bFixedNumberLenExtensionDTMFDialing, name: "bFixedNumberLenExtensionDTMFDialing" }));
			t.push(new asn1ts.Boolean({ value: s.bMobileDeviceLocation, name: "bMobileDeviceLocation" }));
			t.push(new asn1ts.Boolean({ value: s.bShowExtendedSettings, name: "bShowExtendedSettings" }));
			t.push(new asn1ts.Boolean({ value: s.bMultiLocationSupport, name: "bMultiLocationSupport" }));
			t.push(new asn1ts.Boolean({ value: s.bAutoCreateOtherLocationRules, name: "bAutoCreateOtherLocationRules" }));
			t.push(new asn1ts.Boolean({ value: s.bAllowNumberSearchOtherLocations, name: "bAllowNumberSearchOtherLocations" }));
			t.push(new asn1ts.Boolean({ value: s.bShortenOtherLocationSCNumbersForDialing, name: "bShortenOtherLocationSCNumbersForDialing" }));
			t.push(new asn1ts.Boolean({ value: s.bUseTkSystem, name: "bUseTkSystem" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKAnschlussNr, name: "u8sTKAnschlussNr" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDDIRangeBegin, name: "u8sDDIRangeBegin" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDDIRangeEnd, name: "u8sDDIRangeEnd" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKLocalAccessCode, name: "u8sTKLocalAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKLongDistanceAccessCode, name: "u8sTKLongDistanceAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKInternationalAccessCode, name: "u8sTKInternationalAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKPrivateAccessCode, name: "u8sTKPrivateAccessCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTKForwardingAccessCode, name: "u8sTKForwardingAccessCode" }));
			t.push(new asn1ts.Integer({ value: s.iTKMinLenInternalNumbers, name: "iTKMinLenInternalNumbers" }));
			t.push(new asn1ts.Integer({ value: s.iTKMaxLenInternalNumbers, name: "iTKMaxLenInternalNumbers" }));
			if (_u8slistTKAkzListRemoveIn)
				t.push(_u8slistTKAkzListRemoveIn);
			if (_u8slistTKAkzListRemoveOut)
				t.push(_u8slistTKAkzListRemoveOut);
			if (_u8slistTKAkzListRemoveForwarding)
				t.push(_u8slistTKAkzListRemoveForwarding);
			t.push(new asn1ts.Integer({ value: s.iConnectedIDDealing, name: "iConnectedIDDealing" }));
			if (_u8slistTKAkzListRemoveConnectedIDIn)
				t.push(_u8slistTKAkzListRemoveConnectedIDIn);
			if (_u8slistTKAkzListRemoveConnectedIDOut)
				t.push(_u8slistTKAkzListRemoveConnectedIDOut);
			if (_numberFormatInternal)
				t.push(_numberFormatInternal);
			if (_numberFormatExternal)
				t.push(_numberFormatExternal);
			if (_numberFormatAutomaticOtherLocationsDDItoSC)
				t.push(_numberFormatAutomaticOtherLocationsDDItoSC);
			if (_numberFormatAutomaticOtherLocationsSCtoDDI)
				t.push(_numberFormatAutomaticOtherLocationsSCtoDDI);
			if (_numberFormatRegExpressListIn)
				t.push(_numberFormatRegExpressListIn);
			if (_numberFormatRegExpressListOut)
				t.push(_numberFormatRegExpressListOut);
			if (_numberFormatRegExpressListDial)
				t.push(_numberFormatRegExpressListDial);
			if (_numberFormatRegExpressListFinalDial)
				t.push(_numberFormatRegExpressListFinalDial);
			if (_numberFormatRegExpressLinePhoneNumbers)
				t.push(_numberFormatRegExpressLinePhoneNumbers);
			t.push(new asn1ts.Utf8String({ value: s.u8sLocationID, name: "u8sLocationID" }));
			t.push(new asn1ts.Integer({ value: s.iLocalDialingRuleHomePNAFlag, name: "iLocalDialingRuleHomePNAFlag" }));
			if (_u8slistLocalDialingRulesHomePNALocalCalls)
				t.push(_u8slistLocalDialingRulesHomePNALocalCalls);
			if (_u8slistLocalDialingRulesHomePNATollCalls)
				t.push(_u8slistLocalDialingRulesHomePNATollCalls);
			t.push(new asn1ts.Integer({ value: s.iLocalDialingRuleForeignPNAFlag, name: "iLocalDialingRuleForeignPNAFlag" }));
			if (_localDialingRuleForeignPNALocalCallItemList)
				t.push(_localDialingRuleForeignPNALocalCallItemList);
			t.push(new asn1ts.Boolean({ value: s.bUseAdvancedLCR, name: "bUseAdvancedLCR" }));
			if (_lCRProviderVector)
				t.push(_lCRProviderVector);
			if (_lCRZoneList)
				t.push(_lCRZoneList);
			if (_projectPINRules)
				t.push(_projectPINRules);
			t.push(new asn1ts.Boolean({ value: s.bRulesSoftphoneEmergencyEnabled, name: "bRulesSoftphoneEmergencyEnabled" }));
			t.push(new asn1ts.Boolean({ value: s.bRulesSoftphoneEmergencyClientWarningEnabled, name: "bRulesSoftphoneEmergencyClientWarningEnabled" }));
			if (_rulesSoftphoneEmergency)
				t.push(_rulesSoftphoneEmergency);
		}

		if (errors.validateResult(newContext, "AsnLocationInformationMgmt"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnLocationInformationMgmt | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnLocationInformationMgmt");

		let t: ENetUC_Mgmt.AsnLocationInformationMgmt | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnLocationInformationMgmt.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnLocationInformationMgmt["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sLocationCheckSum", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iCountryID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCountryCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNationalPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sInternationalPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalDialingRule", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sNationalDialingRule", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sInternationalDialingRule", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalDialingRuleHomePNALocal", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalDialingRuleHomePNAToll", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalDialingRuleForeignPNALocal", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLanguage", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCityCodeNoPrefix", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bNoLocalDialing", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sVanityNumbers", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseVanity", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRemoteTapiNumberFormat", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRemoteTapiDialFormat", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRemoteTapiLineNames", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDialingNumberFormat", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bFixedNumberLenExtensionDTMFDialing", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMobileDeviceLocation", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bShowExtendedSettings", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bMultiLocationSupport", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAutoCreateOtherLocationRules", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bAllowNumberSearchOtherLocations", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bShortenOtherLocationSCNumbersForDialing", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUseTkSystem", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKAnschlussNr", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDDIRangeBegin", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDDIRangeEnd", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKLocalAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKLongDistanceAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKInternationalAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKPrivateAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTKForwardingAccessCode", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTKMinLenInternalNumbers", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iTKMaxLenInternalNumbers", "Integer", errors, newContext);
			const _u8slisttkakzlistremovein = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTKAkzListRemoveIn"), errors, newContext, "u8slistTKAkzListRemoveIn");
			if (_u8slisttkakzlistremovein)
				t.u8slistTKAkzListRemoveIn = _u8slisttkakzlistremovein;
			const _u8slisttkakzlistremoveout = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTKAkzListRemoveOut"), errors, newContext, "u8slistTKAkzListRemoveOut");
			if (_u8slisttkakzlistremoveout)
				t.u8slistTKAkzListRemoveOut = _u8slisttkakzlistremoveout;
			const _u8slisttkakzlistremoveforwarding = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTKAkzListRemoveForwarding"), errors, newContext, "u8slistTKAkzListRemoveForwarding");
			if (_u8slisttkakzlistremoveforwarding)
				t.u8slistTKAkzListRemoveForwarding = _u8slisttkakzlistremoveforwarding;
			TSConverter.fillASN1Param(s, t, "iConnectedIDDealing", "Integer", errors, newContext);
			const _u8slisttkakzlistremoveconnectedidin = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTKAkzListRemoveConnectedIDIn"), errors, newContext, "u8slistTKAkzListRemoveConnectedIDIn");
			if (_u8slisttkakzlistremoveconnectedidin)
				t.u8slistTKAkzListRemoveConnectedIDIn = _u8slisttkakzlistremoveconnectedidin;
			const _u8slisttkakzlistremoveconnectedidout = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistTKAkzListRemoveConnectedIDOut"), errors, newContext, "u8slistTKAkzListRemoveConnectedIDOut");
			if (_u8slisttkakzlistremoveconnectedidout)
				t.u8slistTKAkzListRemoveConnectedIDOut = _u8slisttkakzlistremoveconnectedidout;
			const _numberformatinternal = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatInternal"), errors, newContext, "numberFormatInternal");
			if (_numberformatinternal)
				t.numberFormatInternal = _numberformatinternal;
			const _numberformatexternal = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatExternal"), errors, newContext, "numberFormatExternal");
			if (_numberformatexternal)
				t.numberFormatExternal = _numberformatexternal;
			const _numberformatautomaticotherlocationsdditosc = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatAutomaticOtherLocationsDDItoSC"), errors, newContext, "numberFormatAutomaticOtherLocationsDDItoSC");
			if (_numberformatautomaticotherlocationsdditosc)
				t.numberFormatAutomaticOtherLocationsDDItoSC = _numberformatautomaticotherlocationsdditosc;
			const _numberformatautomaticotherlocationssctoddi = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatAutomaticOtherLocationsSCtoDDI"), errors, newContext, "numberFormatAutomaticOtherLocationsSCtoDDI");
			if (_numberformatautomaticotherlocationssctoddi)
				t.numberFormatAutomaticOtherLocationsSCtoDDI = _numberformatautomaticotherlocationssctoddi;
			const _numberformatregexpresslistin = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListIn"), errors, newContext, "numberFormatRegExpressListIn");
			if (_numberformatregexpresslistin)
				t.numberFormatRegExpressListIn = _numberformatregexpresslistin;
			const _numberformatregexpresslistout = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListOut"), errors, newContext, "numberFormatRegExpressListOut");
			if (_numberformatregexpresslistout)
				t.numberFormatRegExpressListOut = _numberformatregexpresslistout;
			const _numberformatregexpresslistdial = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListDial"), errors, newContext, "numberFormatRegExpressListDial");
			if (_numberformatregexpresslistdial)
				t.numberFormatRegExpressListDial = _numberformatregexpresslistdial;
			const _numberformatregexpresslistfinaldial = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressListFinalDial"), errors, newContext, "numberFormatRegExpressListFinalDial");
			if (_numberformatregexpresslistfinaldial)
				t.numberFormatRegExpressListFinalDial = _numberformatregexpresslistfinaldial;
			const _numberformatregexpresslinephonenumbers = AsnNumberFormatRegExpressionsMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "numberFormatRegExpressLinePhoneNumbers"), errors, newContext, "numberFormatRegExpressLinePhoneNumbers");
			if (_numberformatregexpresslinephonenumbers)
				t.numberFormatRegExpressLinePhoneNumbers = _numberformatregexpresslinephonenumbers;
			TSConverter.fillASN1Param(s, t, "u8sLocationID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iLocalDialingRuleHomePNAFlag", "Integer", errors, newContext);
			const _u8slistlocaldialingruleshomepnalocalcalls = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistLocalDialingRulesHomePNALocalCalls"), errors, newContext, "u8slistLocalDialingRulesHomePNALocalCalls");
			if (_u8slistlocaldialingruleshomepnalocalcalls)
				t.u8slistLocalDialingRulesHomePNALocalCalls = _u8slistlocaldialingruleshomepnalocalcalls;
			const _u8slistlocaldialingruleshomepnatollcalls = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistLocalDialingRulesHomePNATollCalls"), errors, newContext, "u8slistLocalDialingRulesHomePNATollCalls");
			if (_u8slistlocaldialingruleshomepnatollcalls)
				t.u8slistLocalDialingRulesHomePNATollCalls = _u8slistlocaldialingruleshomepnatollcalls;
			TSConverter.fillASN1Param(s, t, "iLocalDialingRuleForeignPNAFlag", "Integer", errors, newContext);
			const _localdialingruleforeignpnalocalcallitemlist = AsnELocalDialingRuleForeignPNALocalCallItemList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "localDialingRuleForeignPNALocalCallItemList"), errors, newContext, "localDialingRuleForeignPNALocalCallItemList");
			if (_localdialingruleforeignpnalocalcallitemlist)
				t.localDialingRuleForeignPNALocalCallItemList = _localdialingruleforeignpnalocalcallitemlist;
			TSConverter.fillASN1Param(s, t, "bUseAdvancedLCR", "Boolean", errors, newContext);
			const _lcrprovidervector = AsnELCRProviderList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lCRProviderVector"), errors, newContext, "lCRProviderVector");
			if (_lcrprovidervector)
				t.lCRProviderVector = _lcrprovidervector;
			const _lcrzonelist = AsnELCRZoneList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lCRZoneList"), errors, newContext, "lCRZoneList");
			if (_lcrzonelist)
				t.lCRZoneList = _lcrzonelist;
			const _projectpinrules = ENetUC_Common_SIPCTI_Converter.AsnProjectPinRuleList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "projectPINRules"), errors, newContext, "projectPINRules");
			if (_projectpinrules)
				t.projectPINRules = _projectpinrules;
			TSConverter.fillASN1Param(s, t, "bRulesSoftphoneEmergencyEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRulesSoftphoneEmergencyClientWarningEnabled", "Boolean", errors, newContext);
			const _rulessoftphoneemergency = AsnRuleSoftphoneEmergencyMgmtListMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "rulesSoftphoneEmergency"), errors, newContext, "rulesSoftphoneEmergency");
			if (_rulessoftphoneemergency)
				t.rulesSoftphoneEmergency = _rulessoftphoneemergency;
		}

		if (errors.validateResult(newContext, "AsnLocationInformationMgmt"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLocationInformationMgmtResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLocationInformationMgmtResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLocationInformationMgmtResult";
		const _asnLocationData = AsnLocationInformationMgmt_Converter.toJSON(s.asnLocationData, errors, newContext, "asnLocationData");
		if (_asnLocationData)
			t.asnLocationData = _asnLocationData;

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLocationInformationMgmtResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformationMgmt_Converter.fromJSON(s.asnLocationData, errors, newContext, "asnLocationData", false);
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLocationInformationMgmtResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLocationInformationMgmtResult");

		// [Print_BER_EncoderSeqDefCode]
		const _asnLocationData = AsnLocationInformationMgmt_Converter.toBER(s.asnLocationData, errors, newContext, "asnLocationData");
		if (!errors.hasNewErrors()) {
			if (_asnLocationData)
				t.push(_asnLocationData);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLocationInformationMgmtResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLocationInformationMgmtResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformationMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnLocationData"), errors, newContext, "asnLocationData");
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLocationInformationMgmtResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLocationInformationMgmtArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLocationInformationMgmtArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLocationInformationMgmtArgument";
		const _asnLocationData = AsnLocationInformationMgmt_Converter.toJSON(s.asnLocationData, errors, newContext, "asnLocationData");
		if (_asnLocationData)
			t.asnLocationData = _asnLocationData;

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLocationInformationMgmtArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformationMgmt_Converter.fromJSON(s.asnLocationData, errors, newContext, "asnLocationData", false);
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLocationInformationMgmtArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLocationInformationMgmtArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _asnLocationData = AsnLocationInformationMgmt_Converter.toBER(s.asnLocationData, errors, newContext, "asnLocationData");
		if (!errors.hasNewErrors()) {
			if (_asnLocationData)
				t.push(_asnLocationData);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLocationInformationMgmtArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLocationInformationMgmtArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnlocationdata = AsnLocationInformationMgmt_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnLocationData"), errors, newContext, "asnLocationData");
			if (_asnlocationdata)
				t.asnLocationData = _asnlocationdata;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLocationInformationMgmtArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetCSTAServerSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCSTAServerSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetCSTAServerSettingsResult";
		const _settings = AsnCSTAServerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetCSTAServerSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCSTAServerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnCSTAServerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCSTAServerSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetCSTAServerSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCSTAServerSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnCSTAServerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCSTAServerSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCSTAServerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetCSTAServerSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnCSTAServerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCSTAServerSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetCSTAServerSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetCSTAServerSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetCSTAServerSettingsArgument";
		const _settings = AsnCSTAServerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetCSTAServerSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetCSTAServerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnCSTAServerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetCSTAServerSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetCSTAServerSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetCSTAServerSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnCSTAServerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetCSTAServerSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetCSTAServerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetCSTAServerSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnCSTAServerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetCSTAServerSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAVStunOrTurnServerList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnAVStunOrTurnServerList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnAVStunOrTurnServerList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAVStunOrTurnServerList");

		const t = [] as ENetUC_Mgmt.AsnAVStunOrTurnServerList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnAVStunOrTurnServer_Converter.toJSON(se, errors, newContext, "AsnAVStunOrTurnServer");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServerList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnAVStunOrTurnServerList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAVStunOrTurnServerList");

		let t: ENetUC_Mgmt.AsnAVStunOrTurnServerList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnAVStunOrTurnServerList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnAVStunOrTurnServerList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnAVStunOrTurnServer_Converter.fromJSON(se, errors, newContext, "AsnAVStunOrTurnServer", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServerList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnAVStunOrTurnServerList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAVStunOrTurnServerList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAVStunOrTurnServerList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnAVStunOrTurnServer_Converter.toBER(s[id], errors, newContext, "AsnAVStunOrTurnServer");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnAVStunOrTurnServerList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnAVStunOrTurnServerList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAVStunOrTurnServerList");

		let t: ENetUC_Mgmt.AsnAVStunOrTurnServerList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnAVStunOrTurnServerList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnAVStunOrTurnServerList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnAVStunOrTurnServer_Converter.fromBER(se, errors, newContext, "AsnAVStunOrTurnServer", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnServerList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnAVStunOrTurnSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnAVStunOrTurnSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnAVStunOrTurnSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAVStunOrTurnSettings");

		const t = {} as ENetUC_Mgmt.AsnAVStunOrTurnSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnAVStunOrTurnSettings";
		TSConverter.fillJSONParam(s, t, "iTurnProviderType", "number", errors, newContext);
		const _listOwnServers = AsnAVStunOrTurnServerList_Converter.toJSON(s.listOwnServers, errors, newContext, "listOwnServers");
		if (_listOwnServers)
			t.listOwnServers = _listOwnServers;
		TSConverter.fillJSONParam(s, t, "u8sTURNProvider", "string", errors, newContext);
		const _u8spairlistProviderParams = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.u8spairlistProviderParams, errors, newContext, "u8spairlistProviderParams");
		if (_u8spairlistProviderParams)
			t.u8spairlistProviderParams = _u8spairlistProviderParams;

		if (errors.validateResult(newContext, "AsnAVStunOrTurnSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnAVStunOrTurnSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAVStunOrTurnSettings");

		let t: ENetUC_Mgmt.AsnAVStunOrTurnSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnAVStunOrTurnSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnAVStunOrTurnSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iTurnProviderType", "number", errors, newContext, false);
			const _listownservers = AsnAVStunOrTurnServerList_Converter.fromJSON(s.listOwnServers, errors, newContext, "listOwnServers", false);
			if (_listownservers)
				t.listOwnServers = _listownservers;
			TSConverter.fillJSONParam(s, t, "u8sTURNProvider", "string", errors, newContext, false);
			const _u8spairlistproviderparams = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.u8spairlistProviderParams, errors, newContext, "u8spairlistProviderParams", false);
			if (_u8spairlistproviderparams)
				t.u8spairlistProviderParams = _u8spairlistproviderparams;
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnAVStunOrTurnSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnAVStunOrTurnSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnAVStunOrTurnSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iTurnProviderType", "number", errors, newContext);
		const _listOwnServers = AsnAVStunOrTurnServerList_Converter.toBER(s.listOwnServers, errors, newContext, "listOwnServers");
		TSConverter.validateParam(s, "u8sTURNProvider", "string", errors, newContext);
		const _u8spairlistProviderParams = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.u8spairlistProviderParams, errors, newContext, "u8spairlistProviderParams");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iTurnProviderType, name: "iTurnProviderType" }));
			if (_listOwnServers)
				t.push(_listOwnServers);
			t.push(new asn1ts.Utf8String({ value: s.u8sTURNProvider, name: "u8sTURNProvider" }));
			if (_u8spairlistProviderParams)
				t.push(_u8spairlistProviderParams);
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnAVStunOrTurnSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnAVStunOrTurnSettings");

		let t: ENetUC_Mgmt.AsnAVStunOrTurnSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnAVStunOrTurnSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnAVStunOrTurnSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iTurnProviderType", "Integer", errors, newContext);
			const _listownservers = AsnAVStunOrTurnServerList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listOwnServers"), errors, newContext, "listOwnServers");
			if (_listownservers)
				t.listOwnServers = _listownservers;
			TSConverter.fillASN1Param(s, t, "u8sTURNProvider", "Utf8String", errors, newContext);
			const _u8spairlistproviderparams = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8spairlistProviderParams"), errors, newContext, "u8spairlistProviderParams");
			if (_u8spairlistproviderparams)
				t.u8spairlistProviderParams = _u8spairlistproviderparams;
		}

		if (errors.validateResult(newContext, "AsnAVStunOrTurnSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSTUNandTURNSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSTUNandTURNSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSTUNandTURNSettingsResult";
		const _settings = AsnAVStunOrTurnSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSTUNandTURNSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnAVStunOrTurnSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSTUNandTURNSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSTUNandTURNSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnAVStunOrTurnSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSTUNandTURNSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSTUNandTURNSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnAVStunOrTurnSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetSTUNandTURNSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSTUNandTURNSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetSTUNandTURNSettingsArgument";
		const _settings = AsnAVStunOrTurnSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetSTUNandTURNSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSTUNandTURNSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnAVStunOrTurnSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSTUNandTURNSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetSTUNandTURNSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSTUNandTURNSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnAVStunOrTurnSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSTUNandTURNSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSTUNandTURNSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetSTUNandTURNSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnAVStunOrTurnSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSTUNandTURNSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSTUNandTURNConsumerConfigArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSTUNandTURNConsumerConfigArgument";
		const _settings = AsnAVStunOrTurnSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnAVStunOrTurnSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSTUNandTURNConsumerConfigArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnAVStunOrTurnSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSTUNandTURNConsumerConfigArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSTUNandTURNConsumerConfigArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnAVStunOrTurnSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSTUNandTURNConsumerConfigArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetDBManSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetDBManSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetDBManSettingsResult";
		const _settings = AsnMgmtDBManSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetDBManSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtDBManSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetDBManSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetDBManSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtDBManSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetDBManSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetDBManSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtDBManSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetDBManSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetDBManSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetDBManSettingsArgument";
		const _settings = AsnMgmtDBManSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetDBManSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtDBManSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetDBManSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetDBManSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtDBManSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetDBManSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetDBManSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtDBManSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetDBManSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetXmppSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetXmppSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetXmppSettingsResult";
		const _settings = AsnXMPPSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetXmppSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetXmppSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnXMPPSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetXmppSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetXmppSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetXmppSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnXMPPSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetXmppSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetXmppSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetXmppSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnXMPPSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetXmppSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetXmppSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetXmppSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetXmppSettingsArgument";
		const _settings = AsnXMPPSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetXmppSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetXmppSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnXMPPSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetXmppSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetXmppSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetXmppSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnXMPPSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetXmppSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetXmppSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetXmppSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnXMPPSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetXmppSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnListenInterfaceDescriptionList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnListenInterfaceDescriptionList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnListenInterfaceDescriptionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListenInterfaceDescriptionList");

		const t = [] as ENetUC_Mgmt.AsnListenInterfaceDescriptionList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnListenInterfaceDescription_Converter.toJSON(se, errors, newContext, "AsnListenInterfaceDescription");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnListenInterfaceDescriptionList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListenInterfaceDescriptionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListenInterfaceDescriptionList");

		let t: ENetUC_Mgmt.AsnListenInterfaceDescriptionList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnListenInterfaceDescriptionList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnListenInterfaceDescriptionList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnListenInterfaceDescription_Converter.fromJSON(se, errors, newContext, "AsnListenInterfaceDescription", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnListenInterfaceDescriptionList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnListenInterfaceDescriptionList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnListenInterfaceDescriptionList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnListenInterfaceDescriptionList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnListenInterfaceDescription_Converter.toBER(s[id], errors, newContext, "AsnListenInterfaceDescription");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnListenInterfaceDescriptionList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnListenInterfaceDescriptionList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnListenInterfaceDescriptionList");

		let t: ENetUC_Mgmt.AsnListenInterfaceDescriptionList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnListenInterfaceDescriptionList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnListenInterfaceDescriptionList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnListenInterfaceDescription_Converter.fromBER(se, errors, newContext, "AsnListenInterfaceDescription", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnListenInterfaceDescriptionList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSIPFEDSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSIPFEDSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSIPFEDSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPFEDSettings");

		const t = {} as ENetUC_Mgmt.AsnSIPFEDSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSIPFEDSettings";
		TSConverter.fillJSONParam(s, t, "u8sFederationServiceURL", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext);
		const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toJSON(s.networkInterfaces, errors, newContext, "networkInterfaces");
		if (_networkInterfaces)
			t.networkInterfaces = _networkInterfaces;
		TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iFederationEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sFederationBindAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProxyEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProxyPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEdgeServerEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEdgeServerPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEdgeServerProtocol", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEdgeServerCertificate", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEdgeServerUsername", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEdgeServerAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEdgeServerPassword", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOpenFederationEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStaticRoutesEnabled", "number", errors, newContext);
		const _u8slistStaticRoutes = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistStaticRoutes, errors, newContext, "u8slistStaticRoutes");
		if (_u8slistStaticRoutes)
			t.u8slistStaticRoutes = _u8slistStaticRoutes;
		const _u8slistDomainsAllow = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistDomainsAllow, errors, newContext, "u8slistDomainsAllow");
		if (_u8slistDomainsAllow)
			t.u8slistDomainsAllow = _u8slistDomainsAllow;
		TSConverter.fillJSONParam(s, t, "iGlobalAllow", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iGlobalAllowPresenceLevel", "number", errors, newContext);
		const _u8slistDomainsDeny = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistDomainsDeny, errors, newContext, "u8slistDomainsDeny");
		if (_u8slistDomainsDeny)
			t.u8slistDomainsDeny = _u8slistDomainsDeny;
		TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bServerRestartRequiredFlag", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnSIPFEDSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPFEDSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPFEDSettings");

		let t: ENetUC_Mgmt.AsnSIPFEDSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSIPFEDSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnSIPFEDSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sFederationServiceURL", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, false);
			const _networkinterfaces = AsnListenInterfaceDescriptionList_Converter.fromJSON(s.networkInterfaces, errors, newContext, "networkInterfaces", false);
			if (_networkinterfaces)
				t.networkInterfaces = _networkinterfaces;
			TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iFederationEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sFederationBindAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProxyEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProxyPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEdgeServerEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEdgeServerPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEdgeServerProtocol", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEdgeServerCertificate", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEdgeServerUsername", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEdgeServerAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEdgeServerPassword", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOpenFederationEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStaticRoutesEnabled", "number", errors, newContext, false);
			const _u8sliststaticroutes = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistStaticRoutes, errors, newContext, "u8slistStaticRoutes", false);
			if (_u8sliststaticroutes)
				t.u8slistStaticRoutes = _u8sliststaticroutes;
			const _u8slistdomainsallow = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistDomainsAllow, errors, newContext, "u8slistDomainsAllow", false);
			if (_u8slistdomainsallow)
				t.u8slistDomainsAllow = _u8slistdomainsallow;
			TSConverter.fillJSONParam(s, t, "iGlobalAllow", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iGlobalAllowPresenceLevel", "number", errors, newContext, false);
			const _u8slistdomainsdeny = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistDomainsDeny, errors, newContext, "u8slistDomainsDeny", false);
			if (_u8slistdomainsdeny)
				t.u8slistDomainsDeny = _u8slistdomainsdeny;
			TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bServerRestartRequiredFlag", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnSIPFEDSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSIPFEDSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSIPFEDSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPFEDSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sFederationServiceURL", "string", errors, newContext);
		TSConverter.validateParam(s, "iNetworkInterfacesEnabled", "number", errors, newContext);
		const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toBER(s.networkInterfaces, errors, newContext, "networkInterfaces");
		TSConverter.validateParam(s, "iUsePublicIP", "number", errors, newContext);
		TSConverter.validateParam(s, "iPublicPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sPublicIP", "string", errors, newContext);
		TSConverter.validateParam(s, "iFederationEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sFederationBindAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "iProxyEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProxyPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iEdgeServerEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iEdgeServerPort", "number", errors, newContext);
		TSConverter.validateParam(s, "iEdgeServerProtocol", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sEdgeServerCertificate", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEdgeServerUsername", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEdgeServerAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEdgeServerPassword", "string", errors, newContext);
		TSConverter.validateParam(s, "iOpenFederationEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "iStaticRoutesEnabled", "number", errors, newContext);
		const _u8slistStaticRoutes = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistStaticRoutes, errors, newContext, "u8slistStaticRoutes");
		const _u8slistDomainsAllow = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistDomainsAllow, errors, newContext, "u8slistDomainsAllow");
		TSConverter.validateParam(s, "iGlobalAllow", "number", errors, newContext);
		TSConverter.validateParam(s, "iGlobalAllowPresenceLevel", "number", errors, newContext);
		const _u8slistDomainsDeny = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistDomainsDeny, errors, newContext, "u8slistDomainsDeny");
		TSConverter.validateParam(s, "iRegistrarEnabled", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sSipServerCertHash", "string", errors, newContext);
		TSConverter.validateParam(s, "bServerRestartRequiredFlag", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sFederationServiceURL, name: "u8sFederationServiceURL" }));
			t.push(new asn1ts.Integer({ value: s.iNetworkInterfacesEnabled, name: "iNetworkInterfacesEnabled" }));
			if (_networkInterfaces)
				t.push(_networkInterfaces);
			t.push(new asn1ts.Integer({ value: s.iUsePublicIP, name: "iUsePublicIP" }));
			t.push(new asn1ts.Integer({ value: s.iPublicPort, name: "iPublicPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPublicIP, name: "u8sPublicIP" }));
			t.push(new asn1ts.Integer({ value: s.iFederationEnabled, name: "iFederationEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sFederationBindAddress, name: "u8sFederationBindAddress" }));
			t.push(new asn1ts.Integer({ value: s.iProxyEnabled, name: "iProxyEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyUsername, name: "u8sProxyUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProxyPassword, name: "u8sProxyPassword" }));
			t.push(new asn1ts.Integer({ value: s.iEdgeServerEnabled, name: "iEdgeServerEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iEdgeServerPort, name: "iEdgeServerPort" }));
			t.push(new asn1ts.Integer({ value: s.iEdgeServerProtocol, name: "iEdgeServerProtocol" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEdgeServerCertificate, name: "u8sEdgeServerCertificate" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEdgeServerUsername, name: "u8sEdgeServerUsername" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEdgeServerAddress, name: "u8sEdgeServerAddress" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sEdgeServerPassword, name: "u8sEdgeServerPassword" }));
			t.push(new asn1ts.Integer({ value: s.iOpenFederationEnabled, name: "iOpenFederationEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iStaticRoutesEnabled, name: "iStaticRoutesEnabled" }));
			if (_u8slistStaticRoutes)
				t.push(_u8slistStaticRoutes);
			if (_u8slistDomainsAllow)
				t.push(_u8slistDomainsAllow);
			t.push(new asn1ts.Integer({ value: s.iGlobalAllow, name: "iGlobalAllow" }));
			t.push(new asn1ts.Integer({ value: s.iGlobalAllowPresenceLevel, name: "iGlobalAllowPresenceLevel" }));
			if (_u8slistDomainsDeny)
				t.push(_u8slistDomainsDeny);
			t.push(new asn1ts.Integer({ value: s.iRegistrarEnabled, name: "iRegistrarEnabled" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSipServerCertHash, name: "u8sSipServerCertHash" }));
			t.push(new asn1ts.Boolean({ value: s.bServerRestartRequiredFlag, name: "bServerRestartRequiredFlag" }));
		}

		if (errors.validateResult(newContext, "AsnSIPFEDSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPFEDSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPFEDSettings");

		let t: ENetUC_Mgmt.AsnSIPFEDSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSIPFEDSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnSIPFEDSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sFederationServiceURL", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNetworkInterfacesEnabled", "Integer", errors, newContext);
			const _networkinterfaces = AsnListenInterfaceDescriptionList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "networkInterfaces"), errors, newContext, "networkInterfaces");
			if (_networkinterfaces)
				t.networkInterfaces = _networkinterfaces;
			TSConverter.fillASN1Param(s, t, "iUsePublicIP", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPublicPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPublicIP", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iFederationEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sFederationBindAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProxyEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProxyPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEdgeServerEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEdgeServerPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEdgeServerProtocol", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEdgeServerCertificate", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEdgeServerUsername", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEdgeServerAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEdgeServerPassword", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOpenFederationEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStaticRoutesEnabled", "Integer", errors, newContext);
			const _u8sliststaticroutes = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistStaticRoutes"), errors, newContext, "u8slistStaticRoutes");
			if (_u8sliststaticroutes)
				t.u8slistStaticRoutes = _u8sliststaticroutes;
			const _u8slistdomainsallow = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistDomainsAllow"), errors, newContext, "u8slistDomainsAllow");
			if (_u8slistdomainsallow)
				t.u8slistDomainsAllow = _u8slistdomainsallow;
			TSConverter.fillASN1Param(s, t, "iGlobalAllow", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iGlobalAllowPresenceLevel", "Integer", errors, newContext);
			const _u8slistdomainsdeny = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistDomainsDeny"), errors, newContext, "u8slistDomainsDeny");
			if (_u8slistdomainsdeny)
				t.u8slistDomainsDeny = _u8slistdomainsdeny;
			TSConverter.fillASN1Param(s, t, "iRegistrarEnabled", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSipServerCertHash", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bServerRestartRequiredFlag", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnSIPFEDSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSIPFEDSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSIPFEDSettingsResult";
		const _settings = AsnSIPFEDSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnSIPFEDSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSIPFEDSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPFEDSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnSIPFEDSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPFEDSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPFEDSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnSIPFEDSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPFEDSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetSIPFEDSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPFEDSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetSIPFEDSettingsArgument";
		const _settings = AsnSIPFEDSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetSIPFEDSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPFEDSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnSIPFEDSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPFEDSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetSIPFEDSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPFEDSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnSIPFEDSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPFEDSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPFEDSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPFEDSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnSIPFEDSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPFEDSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSIPGatewaySettingsRegisteredUserList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUserList");

		const t = [] as ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnSIPGatewaySettingsRegisteredUser_Converter.toJSON(se, errors, newContext, "AsnSIPGatewaySettingsRegisteredUser");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUserList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUserList");

		let t: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnSIPGatewaySettingsRegisteredUser_Converter.fromJSON(se, errors, newContext, "AsnSIPGatewaySettingsRegisteredUser", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUserList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSIPGatewaySettingsRegisteredUserList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUserList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnSIPGatewaySettingsRegisteredUser_Converter.toBER(s[id], errors, newContext, "AsnSIPGatewaySettingsRegisteredUser");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUserList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewaySettingsRegisteredUserList");

		let t: ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnSIPGatewaySettingsRegisteredUserList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnSIPGatewaySettingsRegisteredUser_Converter.fromBER(se, errors, newContext, "AsnSIPGatewaySettingsRegisteredUser", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnSIPGatewaySettingsRegisteredUserList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSIPGatewayUASettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSIPGatewayUASettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSIPGatewayUASettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewayUASettings");

		const t = {} as ENetUC_Mgmt.AsnSIPGatewayUASettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSIPGatewayUASettings";
		TSConverter.fillJSONParam(s, t, "iGatewayModel", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iGatewayType", "number", errors, newContext);
		const _registeredUsers = AsnSIPGatewaySettingsRegisteredUserList_Converter.toJSON(s.registeredUsers, errors, newContext, "registeredUsers");
		if (_registeredUsers)
			t.registeredUsers = _registeredUsers;
		TSConverter.fillJSONParam(s, t, "bTrunkRegistration", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sRegistrar", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRegistrarPort", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSTUNServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDomainRealm", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRegisterInterval", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iConnectionType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLocalInterfaceGUID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineGroupName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDoRegister", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMediaGatewayName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMediaMode", "number", errors, newContext);
		const _ilistAudioCodecs = ENetUC_Common_Converter.SEQInteger_Converter.toJSON(s.ilistAudioCodecs, errors, newContext, "ilistAudioCodecs");
		if (_ilistAudioCodecs)
			t.ilistAudioCodecs = _ilistAudioCodecs;
		TSConverter.fillJSONParam(s, t, "iPBXProperties", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPCAPTrace", "number", errors, newContext);
		const _u8slistPCAPTraceLines = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8slistPCAPTraceLines, errors, newContext, "u8slistPCAPTraceLines");
		if (_u8slistPCAPTraceLines)
			t.u8slistPCAPTraceLines = _u8slistPCAPTraceLines;
		const _objFeatureCodes = AsnMgmtCtiFeatureCodeList_Converter.toJSON(s.objFeatureCodes, errors, newContext, "objFeatureCodes");
		if (_objFeatureCodes)
			t.objFeatureCodes = _objFeatureCodes;
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.customProps, errors, newContext, "customProps");
		if (_customProps)
			t.customProps = _customProps;
		TSConverter.fillJSONParam(s, t, "iRegisterDelay", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iPBXTransferProperties", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iRegisterNatRefreshInterval", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProvider", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMinPorts", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxPorts", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNoEarlyMedia", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRegisteredUsersSendChanges", "boolean", errors, newContext, true);
		if (s.registeredUsersAdded) {
			const _registeredUsersAdded = AsnSIPGatewaySettingsRegisteredUserList_Converter.toJSON(s.registeredUsersAdded, errors, newContext, "registeredUsersAdded");
			if (_registeredUsersAdded)
				t.registeredUsersAdded = _registeredUsersAdded;
		}
		if (s.registeredUsersChanged) {
			const _registeredUsersChanged = AsnSIPGatewaySettingsRegisteredUserList_Converter.toJSON(s.registeredUsersChanged, errors, newContext, "registeredUsersChanged");
			if (_registeredUsersChanged)
				t.registeredUsersChanged = _registeredUsersChanged;
		}
		if (s.registeredUsersRemoved) {
			const _registeredUsersRemoved = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.registeredUsersRemoved, errors, newContext, "registeredUsersRemoved");
			if (_registeredUsersRemoved)
				t.registeredUsersRemoved = _registeredUsersRemoved;
		}
		TSConverter.fillJSONParam(s, t, "u8sLineGroupNameOld", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewayUASettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewayUASettings");

		let t: ENetUC_Mgmt.AsnSIPGatewayUASettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSIPGatewayUASettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnSIPGatewayUASettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iGatewayModel", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iGatewayType", "number", errors, newContext, false);
			const _registeredusers = AsnSIPGatewaySettingsRegisteredUserList_Converter.fromJSON(s.registeredUsers, errors, newContext, "registeredUsers", false);
			if (_registeredusers)
				t.registeredUsers = _registeredusers;
			TSConverter.fillJSONParam(s, t, "bTrunkRegistration", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sRegistrar", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRegistrarPort", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSTUNServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDomainRealm", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRegisterInterval", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iConnectionType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLocalInterfaceGUID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineGroupName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDoRegister", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMediaGatewayName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMediaMode", "number", errors, newContext, false);
			const _ilistaudiocodecs = ENetUC_Common_Converter.SEQInteger_Converter.fromJSON(s.ilistAudioCodecs, errors, newContext, "ilistAudioCodecs", false);
			if (_ilistaudiocodecs)
				t.ilistAudioCodecs = _ilistaudiocodecs;
			TSConverter.fillJSONParam(s, t, "iPBXProperties", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPCAPTrace", "number", errors, newContext, false);
			const _u8slistpcaptracelines = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8slistPCAPTraceLines, errors, newContext, "u8slistPCAPTraceLines", false);
			if (_u8slistpcaptracelines)
				t.u8slistPCAPTraceLines = _u8slistpcaptracelines;
			const _objfeaturecodes = AsnMgmtCtiFeatureCodeList_Converter.fromJSON(s.objFeatureCodes, errors, newContext, "objFeatureCodes", false);
			if (_objfeaturecodes)
				t.objFeatureCodes = _objfeaturecodes;
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.customProps, errors, newContext, "customProps", false);
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillJSONParam(s, t, "iRegisterDelay", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iPBXTransferProperties", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iRegisterNatRefreshInterval", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProvider", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMinPorts", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxPorts", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNoEarlyMedia", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRegisteredUsersSendChanges", "boolean", errors, newContext, true);
			const _registeredusersadded = AsnSIPGatewaySettingsRegisteredUserList_Converter.fromJSON(s.registeredUsersAdded, errors, newContext, "registeredUsersAdded", true);
			if (_registeredusersadded)
				t.registeredUsersAdded = _registeredusersadded;
			const _registereduserschanged = AsnSIPGatewaySettingsRegisteredUserList_Converter.fromJSON(s.registeredUsersChanged, errors, newContext, "registeredUsersChanged", true);
			if (_registereduserschanged)
				t.registeredUsersChanged = _registereduserschanged;
			const _registeredusersremoved = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.registeredUsersRemoved, errors, newContext, "registeredUsersRemoved", true);
			if (_registeredusersremoved)
				t.registeredUsersRemoved = _registeredusersremoved;
			TSConverter.fillJSONParam(s, t, "u8sLineGroupNameOld", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSIPGatewayUASettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSIPGatewayUASettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewayUASettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iGatewayModel", "number", errors, newContext);
		TSConverter.validateParam(s, "iGatewayType", "number", errors, newContext);
		const _registeredUsers = AsnSIPGatewaySettingsRegisteredUserList_Converter.toBER(s.registeredUsers, errors, newContext, "registeredUsers");
		TSConverter.validateParam(s, "bTrunkRegistration", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sRegistrar", "string", errors, newContext);
		TSConverter.validateParam(s, "iRegistrarPort", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sSTUNServer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sDomainRealm", "string", errors, newContext);
		TSConverter.validateParam(s, "iRegisterInterval", "number", errors, newContext);
		TSConverter.validateParam(s, "iConnectionType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLocalInterfaceGUID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sLineGroupName", "string", errors, newContext);
		TSConverter.validateParam(s, "bDoRegister", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sMediaGatewayName", "string", errors, newContext);
		TSConverter.validateParam(s, "iMediaMode", "number", errors, newContext);
		const _ilistAudioCodecs = ENetUC_Common_Converter.SEQInteger_Converter.toBER(s.ilistAudioCodecs, errors, newContext, "ilistAudioCodecs");
		TSConverter.validateParam(s, "iPBXProperties", "number", errors, newContext);
		TSConverter.validateParam(s, "iPCAPTrace", "number", errors, newContext);
		const _u8slistPCAPTraceLines = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8slistPCAPTraceLines, errors, newContext, "u8slistPCAPTraceLines");
		const _objFeatureCodes = AsnMgmtCtiFeatureCodeList_Converter.toBER(s.objFeatureCodes, errors, newContext, "objFeatureCodes");
		const _customProps = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.customProps, errors, newContext, "customProps");
		TSConverter.validateParam(s, "iRegisterDelay", "number", errors, newContext);
		TSConverter.validateParam(s, "iPBXTransferProperties", "number", errors, newContext);
		TSConverter.validateParam(s, "iRegisterNatRefreshInterval", "number", errors, newContext);
		TSConverter.validateParam(s, "iProvider", "number", errors, newContext);
		TSConverter.validateParam(s, "iMinPorts", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxPorts", "number", errors, newContext);
		TSConverter.validateParam(s, "iNoEarlyMedia", "number", errors, newContext);
		TSConverter.validateParam(s, "bRegisteredUsersSendChanges", "boolean", errors, newContext, true);
		const _registeredUsersAdded = AsnSIPGatewaySettingsRegisteredUserList_Converter.toBER(s.registeredUsersAdded, errors, newContext, "registeredUsersAdded", 1);
		const _registeredUsersChanged = AsnSIPGatewaySettingsRegisteredUserList_Converter.toBER(s.registeredUsersChanged, errors, newContext, "registeredUsersChanged", 2);
		const _registeredUsersRemoved = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.registeredUsersRemoved, errors, newContext, "registeredUsersRemoved", 3);
		TSConverter.validateParam(s, "u8sLineGroupNameOld", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iGatewayModel, name: "iGatewayModel" }));
			t.push(new asn1ts.Integer({ value: s.iGatewayType, name: "iGatewayType" }));
			if (_registeredUsers)
				t.push(_registeredUsers);
			t.push(new asn1ts.Boolean({ value: s.bTrunkRegistration, name: "bTrunkRegistration" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sRegistrar, name: "u8sRegistrar" }));
			t.push(new asn1ts.Integer({ value: s.iRegistrarPort, name: "iRegistrarPort" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSTUNServer, name: "u8sSTUNServer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDomainRealm, name: "u8sDomainRealm" }));
			t.push(new asn1ts.Integer({ value: s.iRegisterInterval, name: "iRegisterInterval" }));
			t.push(new asn1ts.Integer({ value: s.iConnectionType, name: "iConnectionType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLocalInterfaceGUID, name: "u8sLocalInterfaceGUID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineGroupName, name: "u8sLineGroupName" }));
			t.push(new asn1ts.Boolean({ value: s.bDoRegister, name: "bDoRegister" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMediaGatewayName, name: "u8sMediaGatewayName" }));
			t.push(new asn1ts.Integer({ value: s.iMediaMode, name: "iMediaMode" }));
			if (_ilistAudioCodecs)
				t.push(_ilistAudioCodecs);
			t.push(new asn1ts.Integer({ value: s.iPBXProperties, name: "iPBXProperties" }));
			t.push(new asn1ts.Integer({ value: s.iPCAPTrace, name: "iPCAPTrace" }));
			if (_u8slistPCAPTraceLines)
				t.push(_u8slistPCAPTraceLines);
			if (_objFeatureCodes)
				t.push(_objFeatureCodes);
			if (_customProps)
				t.push(_customProps);
			t.push(new asn1ts.Integer({ value: s.iRegisterDelay, name: "iRegisterDelay" }));
			t.push(new asn1ts.Integer({ value: s.iPBXTransferProperties, name: "iPBXTransferProperties" }));
			t.push(new asn1ts.Integer({ value: s.iRegisterNatRefreshInterval, name: "iRegisterNatRefreshInterval" }));
			t.push(new asn1ts.Integer({ value: s.iProvider, name: "iProvider" }));
			t.push(new asn1ts.Integer({ value: s.iMinPorts, name: "iMinPorts" }));
			t.push(new asn1ts.Integer({ value: s.iMaxPorts, name: "iMaxPorts" }));
			t.push(new asn1ts.Integer({ value: s.iNoEarlyMedia, name: "iNoEarlyMedia" }));
			if (s.bRegisteredUsersSendChanges !== undefined)
				t.push(new asn1ts.Boolean({ value: s.bRegisteredUsersSendChanges, name: "bRegisteredUsersSendChanges", idBlock: { optionalID: 0 } }));
			if (_registeredUsersAdded)
				t.push(_registeredUsersAdded);
			if (_registeredUsersChanged)
				t.push(_registeredUsersChanged);
			if (_registeredUsersRemoved)
				t.push(_registeredUsersRemoved);
			if (s.u8sLineGroupNameOld !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sLineGroupNameOld, name: "u8sLineGroupNameOld", idBlock: { optionalID: 4 } }));
		}

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewayUASettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewayUASettings");

		let t: ENetUC_Mgmt.AsnSIPGatewayUASettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSIPGatewayUASettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnSIPGatewayUASettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iGatewayModel", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iGatewayType", "Integer", errors, newContext);
			const _registeredusers = AsnSIPGatewaySettingsRegisteredUserList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "registeredUsers"), errors, newContext, "registeredUsers");
			if (_registeredusers)
				t.registeredUsers = _registeredusers;
			TSConverter.fillASN1Param(s, t, "bTrunkRegistration", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sRegistrar", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRegistrarPort", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSTUNServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDomainRealm", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRegisterInterval", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iConnectionType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLocalInterfaceGUID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineGroupName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDoRegister", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMediaGatewayName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMediaMode", "Integer", errors, newContext);
			const _ilistaudiocodecs = ENetUC_Common_Converter.SEQInteger_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "ilistAudioCodecs"), errors, newContext, "ilistAudioCodecs");
			if (_ilistaudiocodecs)
				t.ilistAudioCodecs = _ilistaudiocodecs;
			TSConverter.fillASN1Param(s, t, "iPBXProperties", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPCAPTrace", "Integer", errors, newContext);
			const _u8slistpcaptracelines = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8slistPCAPTraceLines"), errors, newContext, "u8slistPCAPTraceLines");
			if (_u8slistpcaptracelines)
				t.u8slistPCAPTraceLines = _u8slistpcaptracelines;
			const _objfeaturecodes = AsnMgmtCtiFeatureCodeList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "objFeatureCodes"), errors, newContext, "objFeatureCodes");
			if (_objfeaturecodes)
				t.objFeatureCodes = _objfeaturecodes;
			const _customprops = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "customProps"), errors, newContext, "customProps");
			if (_customprops)
				t.customProps = _customprops;
			TSConverter.fillASN1Param(s, t, "iRegisterDelay", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iPBXTransferProperties", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iRegisterNatRefreshInterval", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProvider", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMinPorts", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxPorts", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNoEarlyMedia", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRegisteredUsersSendChanges", "Boolean", errors, newContext, true);
			t.registeredUsersAdded = AsnSIPGatewaySettingsRegisteredUserList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "registeredUsersAdded"), errors, newContext, "registeredUsersAdded", true);
			t.registeredUsersChanged = AsnSIPGatewaySettingsRegisteredUserList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "registeredUsersChanged"), errors, newContext, "registeredUsersChanged", true);
			t.registeredUsersRemoved = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "registeredUsersRemoved"), errors, newContext, "registeredUsersRemoved", true);
			TSConverter.fillASN1Param(s, t, "u8sLineGroupNameOld", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSIPGatewayUASettingsList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSIPGatewayUASettingsList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSIPGatewayUASettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewayUASettingsList");

		const t = [] as ENetUC_Mgmt.AsnSIPGatewayUASettingsList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnSIPGatewayUASettings_Converter.toJSON(se, errors, newContext, "AsnSIPGatewayUASettings");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettingsList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewayUASettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewayUASettingsList");

		let t: ENetUC_Mgmt.AsnSIPGatewayUASettingsList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSIPGatewayUASettingsList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnSIPGatewayUASettingsList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnSIPGatewayUASettings_Converter.fromJSON(se, errors, newContext, "AsnSIPGatewayUASettings", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettingsList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSIPGatewayUASettingsList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSIPGatewayUASettingsList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSIPGatewayUASettingsList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnSIPGatewayUASettings_Converter.toBER(s[id], errors, newContext, "AsnSIPGatewayUASettings");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnSIPGatewayUASettingsList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSIPGatewayUASettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSIPGatewayUASettingsList");

		let t: ENetUC_Mgmt.AsnSIPGatewayUASettingsList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSIPGatewayUASettingsList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnSIPGatewayUASettingsList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnSIPGatewayUASettings_Converter.fromBER(se, errors, newContext, "AsnSIPGatewayUASettings", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnSIPGatewayUASettingsList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetSIPGatewaySettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPGatewaySettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetSIPGatewaySettingsResult";
		const _settings = AsnSIPGatewayUASettingsList_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;
		TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
		if (s.networkInterfaces) {
			const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toJSON(s.networkInterfaces, errors, newContext, "networkInterfaces");
			if (_networkInterfaces)
				t.networkInterfaces = _networkInterfaces;
		}
		TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtGetSIPGatewaySettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPGatewaySettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnSIPGatewayUASettingsList_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
			TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
			const _networkinterfaces = AsnListenInterfaceDescriptionList_Converter.fromJSON(s.networkInterfaces, errors, newContext, "networkInterfaces", true);
			if (_networkinterfaces)
				t.networkInterfaces = _networkinterfaces;
			TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPGatewaySettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetSIPGatewaySettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetSIPGatewaySettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnSIPGatewayUASettingsList_Converter.toBER(s.settings, errors, newContext, "settings");
		TSConverter.validateParam(s, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
		const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toBER(s.networkInterfaces, errors, newContext, "networkInterfaces", 1);
		TSConverter.validateParam(s, "iUsePublicIP", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iPublicPort", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sPublicIP", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iRegistrarEnabled", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sSipServerCertHash", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
			if (s.iNetworkInterfacesEnabled !== undefined)
				t.push(new asn1ts.Integer({ value: s.iNetworkInterfacesEnabled, name: "iNetworkInterfacesEnabled", idBlock: { optionalID: 0 } }));
			if (_networkInterfaces)
				t.push(_networkInterfaces);
			if (s.iUsePublicIP !== undefined)
				t.push(new asn1ts.Integer({ value: s.iUsePublicIP, name: "iUsePublicIP", idBlock: { optionalID: 2 } }));
			if (s.iPublicPort !== undefined)
				t.push(new asn1ts.Integer({ value: s.iPublicPort, name: "iPublicPort", idBlock: { optionalID: 3 } }));
			if (s.u8sPublicIP !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sPublicIP, name: "u8sPublicIP", idBlock: { optionalID: 4 } }));
			if (s.iRegistrarEnabled !== undefined)
				t.push(new asn1ts.Integer({ value: s.iRegistrarEnabled, name: "iRegistrarEnabled", idBlock: { optionalID: 5 } }));
			if (s.u8sSipServerCertHash !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sSipServerCertHash, name: "u8sSipServerCertHash", idBlock: { optionalID: 6 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPGatewaySettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetSIPGatewaySettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetSIPGatewaySettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnSIPGatewayUASettingsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
			TSConverter.fillASN1Param(s, t, "iNetworkInterfacesEnabled", "Integer", errors, newContext, true);
			t.networkInterfaces = AsnListenInterfaceDescriptionList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "networkInterfaces"), errors, newContext, "networkInterfaces", true);
			TSConverter.fillASN1Param(s, t, "iUsePublicIP", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iPublicPort", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sPublicIP", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iRegistrarEnabled", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sSipServerCertHash", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetSIPGatewaySettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetSIPGatewaySettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetSIPGatewaySettingsArgument";
		const _settingsNew = AsnSIPGatewayUASettingsList_Converter.toJSON(s.settingsNew, errors, newContext, "settingsNew");
		if (_settingsNew)
			t.settingsNew = _settingsNew;
		if (s.settingsOld) {
			const _settingsOld = AsnSIPGatewayUASettingsList_Converter.toJSON(s.settingsOld, errors, newContext, "settingsOld");
			if (_settingsOld)
				t.settingsOld = _settingsOld;
		}
		TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
		if (s.networkInterfaces) {
			const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toJSON(s.networkInterfaces, errors, newContext, "networkInterfaces");
			if (_networkInterfaces)
				t.networkInterfaces = _networkInterfaces;
		}
		TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settingsnew = AsnSIPGatewayUASettingsList_Converter.fromJSON(s.settingsNew, errors, newContext, "settingsNew", false);
			if (_settingsnew)
				t.settingsNew = _settingsnew;
			const _settingsold = AsnSIPGatewayUASettingsList_Converter.fromJSON(s.settingsOld, errors, newContext, "settingsOld", true);
			if (_settingsold)
				t.settingsOld = _settingsold;
			TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
			const _networkinterfaces = AsnListenInterfaceDescriptionList_Converter.fromJSON(s.networkInterfaces, errors, newContext, "networkInterfaces", true);
			if (_networkinterfaces)
				t.networkInterfaces = _networkinterfaces;
			TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetSIPGatewaySettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settingsNew = AsnSIPGatewayUASettingsList_Converter.toBER(s.settingsNew, errors, newContext, "settingsNew");
		const _settingsOld = AsnSIPGatewayUASettingsList_Converter.toBER(s.settingsOld, errors, newContext, "settingsOld", 0);
		TSConverter.validateParam(s, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
		const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toBER(s.networkInterfaces, errors, newContext, "networkInterfaces", 2);
		TSConverter.validateParam(s, "iUsePublicIP", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iPublicPort", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sPublicIP", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iRegistrarEnabled", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sSipServerCertHash", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_settingsNew)
				t.push(_settingsNew);
			if (_settingsOld)
				t.push(_settingsOld);
			if (s.iNetworkInterfacesEnabled !== undefined)
				t.push(new asn1ts.Integer({ value: s.iNetworkInterfacesEnabled, name: "iNetworkInterfacesEnabled", idBlock: { optionalID: 1 } }));
			if (_networkInterfaces)
				t.push(_networkInterfaces);
			if (s.iUsePublicIP !== undefined)
				t.push(new asn1ts.Integer({ value: s.iUsePublicIP, name: "iUsePublicIP", idBlock: { optionalID: 3 } }));
			if (s.iPublicPort !== undefined)
				t.push(new asn1ts.Integer({ value: s.iPublicPort, name: "iPublicPort", idBlock: { optionalID: 4 } }));
			if (s.u8sPublicIP !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sPublicIP, name: "u8sPublicIP", idBlock: { optionalID: 5 } }));
			if (s.iRegistrarEnabled !== undefined)
				t.push(new asn1ts.Integer({ value: s.iRegistrarEnabled, name: "iRegistrarEnabled", idBlock: { optionalID: 6 } }));
			if (s.u8sSipServerCertHash !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sSipServerCertHash, name: "u8sSipServerCertHash", idBlock: { optionalID: 7 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settingsnew = AsnSIPGatewayUASettingsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settingsNew"), errors, newContext, "settingsNew");
			if (_settingsnew)
				t.settingsNew = _settingsnew;
			t.settingsOld = AsnSIPGatewayUASettingsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settingsOld"), errors, newContext, "settingsOld", true);
			TSConverter.fillASN1Param(s, t, "iNetworkInterfacesEnabled", "Integer", errors, newContext, true);
			t.networkInterfaces = AsnListenInterfaceDescriptionList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "networkInterfaces"), errors, newContext, "networkInterfaces", true);
			TSConverter.fillASN1Param(s, t, "iUsePublicIP", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iPublicPort", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sPublicIP", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iRegistrarEnabled", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sSipServerCertHash", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetSIPGatewaySettingsV2Argument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Argument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetSIPGatewaySettingsV2Argument";
		if (s.uaSettingsAdded) {
			const _uaSettingsAdded = AsnSIPGatewayUASettingsList_Converter.toJSON(s.uaSettingsAdded, errors, newContext, "uaSettingsAdded");
			if (_uaSettingsAdded)
				t.uaSettingsAdded = _uaSettingsAdded;
		}
		if (s.uaSettingsChanged) {
			const _uaSettingsChanged = AsnSIPGatewayUASettingsList_Converter.toJSON(s.uaSettingsChanged, errors, newContext, "uaSettingsChanged");
			if (_uaSettingsChanged)
				t.uaSettingsChanged = _uaSettingsChanged;
		}
		if (s.uaSettingsRemoved) {
			const _uaSettingsRemoved = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.uaSettingsRemoved, errors, newContext, "uaSettingsRemoved");
			if (_uaSettingsRemoved)
				t.uaSettingsRemoved = _uaSettingsRemoved;
		}
		TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
		if (s.networkInterfaces) {
			const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toJSON(s.networkInterfaces, errors, newContext, "networkInterfaces");
			if (_networkInterfaces)
				t.networkInterfaces = _networkInterfaces;
		}
		TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Argument");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _uasettingsadded = AsnSIPGatewayUASettingsList_Converter.fromJSON(s.uaSettingsAdded, errors, newContext, "uaSettingsAdded", true);
			if (_uasettingsadded)
				t.uaSettingsAdded = _uasettingsadded;
			const _uasettingschanged = AsnSIPGatewayUASettingsList_Converter.fromJSON(s.uaSettingsChanged, errors, newContext, "uaSettingsChanged", true);
			if (_uasettingschanged)
				t.uaSettingsChanged = _uasettingschanged;
			const _uasettingsremoved = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.uaSettingsRemoved, errors, newContext, "uaSettingsRemoved", true);
			if (_uasettingsremoved)
				t.uaSettingsRemoved = _uasettingsremoved;
			TSConverter.fillJSONParam(s, t, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
			const _networkinterfaces = AsnListenInterfaceDescriptionList_Converter.fromJSON(s.networkInterfaces, errors, newContext, "networkInterfaces", true);
			if (_networkinterfaces)
				t.networkInterfaces = _networkinterfaces;
			TSConverter.fillJSONParam(s, t, "iUsePublicIP", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iPublicPort", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sPublicIP", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iRegistrarEnabled", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sSipServerCertHash", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetSIPGatewaySettingsV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		const _uaSettingsAdded = AsnSIPGatewayUASettingsList_Converter.toBER(s.uaSettingsAdded, errors, newContext, "uaSettingsAdded", 0);
		const _uaSettingsChanged = AsnSIPGatewayUASettingsList_Converter.toBER(s.uaSettingsChanged, errors, newContext, "uaSettingsChanged", 1);
		const _uaSettingsRemoved = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.uaSettingsRemoved, errors, newContext, "uaSettingsRemoved", 2);
		TSConverter.validateParam(s, "iNetworkInterfacesEnabled", "number", errors, newContext, true);
		const _networkInterfaces = AsnListenInterfaceDescriptionList_Converter.toBER(s.networkInterfaces, errors, newContext, "networkInterfaces", 4);
		TSConverter.validateParam(s, "iUsePublicIP", "number", errors, newContext, true);
		TSConverter.validateParam(s, "iPublicPort", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sPublicIP", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iRegistrarEnabled", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sSipServerCertHash", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_uaSettingsAdded)
				t.push(_uaSettingsAdded);
			if (_uaSettingsChanged)
				t.push(_uaSettingsChanged);
			if (_uaSettingsRemoved)
				t.push(_uaSettingsRemoved);
			if (s.iNetworkInterfacesEnabled !== undefined)
				t.push(new asn1ts.Integer({ value: s.iNetworkInterfacesEnabled, name: "iNetworkInterfacesEnabled", idBlock: { optionalID: 3 } }));
			if (_networkInterfaces)
				t.push(_networkInterfaces);
			if (s.iUsePublicIP !== undefined)
				t.push(new asn1ts.Integer({ value: s.iUsePublicIP, name: "iUsePublicIP", idBlock: { optionalID: 5 } }));
			if (s.iPublicPort !== undefined)
				t.push(new asn1ts.Integer({ value: s.iPublicPort, name: "iPublicPort", idBlock: { optionalID: 6 } }));
			if (s.u8sPublicIP !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sPublicIP, name: "u8sPublicIP", idBlock: { optionalID: 7 } }));
			if (s.iRegistrarEnabled !== undefined)
				t.push(new asn1ts.Integer({ value: s.iRegistrarEnabled, name: "iRegistrarEnabled", idBlock: { optionalID: 8 } }));
			if (s.u8sSipServerCertHash !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sSipServerCertHash, name: "u8sSipServerCertHash", idBlock: { optionalID: 9 } }));
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetSIPGatewaySettingsV2Argument");

		let t: ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetSIPGatewaySettingsV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			t.uaSettingsAdded = AsnSIPGatewayUASettingsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "uaSettingsAdded"), errors, newContext, "uaSettingsAdded", true);
			t.uaSettingsChanged = AsnSIPGatewayUASettingsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "uaSettingsChanged"), errors, newContext, "uaSettingsChanged", true);
			t.uaSettingsRemoved = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "uaSettingsRemoved"), errors, newContext, "uaSettingsRemoved", true);
			TSConverter.fillASN1Param(s, t, "iNetworkInterfacesEnabled", "Integer", errors, newContext, true);
			t.networkInterfaces = AsnListenInterfaceDescriptionList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "networkInterfaces"), errors, newContext, "networkInterfaces", true);
			TSConverter.fillASN1Param(s, t, "iUsePublicIP", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iPublicPort", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sPublicIP", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iRegistrarEnabled", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sSipServerCertHash", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetSIPGatewaySettingsV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetCallRecorderSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetCallRecorderSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetCallRecorderSettingsArgument";
		const _settings = AsnCallRecorderSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetCallRecorderSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetCallRecorderSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnCallRecorderSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetCallRecorderSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetCallRecorderSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetCallRecorderSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnCallRecorderSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetCallRecorderSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetCallRecorderSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetCallRecorderSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnCallRecorderSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetCallRecorderSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetCallRecorderSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCallRecorderSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetCallRecorderSettingsResult";
		const _settings = AsnCallRecorderSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetCallRecorderSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCallRecorderSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnCallRecorderSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCallRecorderSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetCallRecorderSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCallRecorderSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnCallRecorderSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCallRecorderSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCallRecorderSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetCallRecorderSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnCallRecorderSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCallRecorderSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtServerStatistics4AdminList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtServerStatistics4AdminList");

		const t = [] as ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtServerStatistics4Admin_Converter.toJSON(se, errors, newContext, "AsnMgmtServerStatistics4Admin");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4AdminList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtServerStatistics4AdminList");

		let t: ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtServerStatistics4Admin_Converter.fromJSON(se, errors, newContext, "AsnMgmtServerStatistics4Admin", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4AdminList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtServerStatistics4AdminList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtServerStatistics4AdminList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtServerStatistics4Admin_Converter.toBER(s[id], errors, newContext, "AsnMgmtServerStatistics4Admin");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4AdminList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtServerStatistics4AdminList");

		let t: ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtServerStatistics4AdminList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtServerStatistics4Admin_Converter.fromBER(se, errors, newContext, "AsnMgmtServerStatistics4Admin", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtServerStatistics4AdminList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMonGetServerStatisticsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMonGetServerStatisticsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtMonGetServerStatisticsResult";
		const _serverStatistics = AsnMgmtServerStatistics4AdminList_Converter.toJSON(s.serverStatistics, errors, newContext, "serverStatistics");
		if (_serverStatistics)
			t.serverStatistics = _serverStatistics;

		if (errors.validateResult(newContext, "AsnMgmtMonGetServerStatisticsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMonGetServerStatisticsResult");

		let t: ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _serverstatistics = AsnMgmtServerStatistics4AdminList_Converter.fromJSON(s.serverStatistics, errors, newContext, "serverStatistics", false);
			if (_serverstatistics)
				t.serverStatistics = _serverstatistics;
		}

		if (errors.validateResult(newContext, "AsnMgmtMonGetServerStatisticsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMonGetServerStatisticsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMonGetServerStatisticsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _serverStatistics = AsnMgmtServerStatistics4AdminList_Converter.toBER(s.serverStatistics, errors, newContext, "serverStatistics");
		if (!errors.hasNewErrors()) {
			if (_serverStatistics)
				t.push(_serverStatistics);
		}

		if (errors.validateResult(newContext, "AsnMgmtMonGetServerStatisticsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMonGetServerStatisticsResult");

		let t: ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtMonGetServerStatisticsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _serverstatistics = AsnMgmtServerStatistics4AdminList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "serverStatistics"), errors, newContext, "serverStatistics");
			if (_serverstatistics)
				t.serverStatistics = _serverstatistics;
		}

		if (errors.validateResult(newContext, "AsnMgmtMonGetServerStatisticsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetCtiServerTypeResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCtiServerTypeResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetCtiServerTypeResult";
		TSConverter.fillJSONParam(s, t, "iServerType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iServerFeatures", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCtiServerTypeResult");

		let t: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iServerType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iServerFeatures", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetCtiServerTypeResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetCtiServerTypeResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iServerType", "number", errors, newContext);
		TSConverter.validateParam(s, "iServerFeatures", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Enumerated({ value: s.iServerType, name: "iServerType" }));
			t.push(new asn1ts.Integer({ value: s.iServerFeatures, name: "iServerFeatures" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetCtiServerTypeResult");

		let t: ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetCtiServerTypeResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iServerType", "Enumerated", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iServerFeatures", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetCtiServerTypeResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtNotificationSettings_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtNotificationSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtNotificationSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtNotificationSettings");

		const t = {} as ENetUC_Mgmt.AsnMgmtNotificationSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtNotificationSettings";
		TSConverter.fillJSONParam(s, t, "iUnansweredCallEMailNotification", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEMailNotificationUseCallerMailAddress", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEMailNotificationSendEMailsClientSide", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEMailNotificationAttacheVCard", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEMailNotificationSendEMailsThirdPartyPickup", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEMailNotificationUseTelephonyLinkPrefix", "boolean", errors, newContext);
		const _emailNotificationExclusions = AsnMgmtNotificationSettingsExclusions_Converter.toJSON(s.emailNotificationExclusions, errors, newContext, "emailNotificationExclusions");
		if (_emailNotificationExclusions)
			t.emailNotificationExclusions = _emailNotificationExclusions;
		TSConverter.fillJSONParam(s, t, "iUnansweredCallSMSNotification", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bSMSNotificationUseCallerNumberAsOriginator", "boolean", errors, newContext);
		const _objSMSNotificationExclusions = AsnMgmtNotificationSettingsExclusions_Converter.toJSON(s.objSMSNotificationExclusions, errors, newContext, "objSMSNotificationExclusions");
		if (_objSMSNotificationExclusions)
			t.objSMSNotificationExclusions = _objSMSNotificationExclusions;
		TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUserDefinedTelephonyLinkPrefix", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtNotificationSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtNotificationSettings");

		let t: ENetUC_Mgmt.AsnMgmtNotificationSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtNotificationSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtNotificationSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iUnansweredCallEMailNotification", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEMailNotificationUseCallerMailAddress", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEMailNotificationSendEMailsClientSide", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEMailNotificationAttacheVCard", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEMailNotificationSendEMailsThirdPartyPickup", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEMailNotificationUseTelephonyLinkPrefix", "boolean", errors, newContext, false);
			const _emailnotificationexclusions = AsnMgmtNotificationSettingsExclusions_Converter.fromJSON(s.emailNotificationExclusions, errors, newContext, "emailNotificationExclusions", false);
			if (_emailnotificationexclusions)
				t.emailNotificationExclusions = _emailnotificationexclusions;
			TSConverter.fillJSONParam(s, t, "iUnansweredCallSMSNotification", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bSMSNotificationUseCallerNumberAsOriginator", "boolean", errors, newContext, false);
			const _objsmsnotificationexclusions = AsnMgmtNotificationSettingsExclusions_Converter.fromJSON(s.objSMSNotificationExclusions, errors, newContext, "objSMSNotificationExclusions", false);
			if (_objsmsnotificationexclusions)
				t.objSMSNotificationExclusions = _objsmsnotificationexclusions;
			TSConverter.fillJSONParam(s, t, "iLanguage", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUserDefinedTelephonyLinkPrefix", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtNotificationSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtNotificationSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtNotificationSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iUnansweredCallEMailNotification", "number", errors, newContext);
		TSConverter.validateParam(s, "bEMailNotificationUseCallerMailAddress", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEMailNotificationSendEMailsClientSide", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEMailNotificationAttacheVCard", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEMailNotificationSendEMailsThirdPartyPickup", "boolean", errors, newContext);
		TSConverter.validateParam(s, "bEMailNotificationUseTelephonyLinkPrefix", "boolean", errors, newContext);
		const _emailNotificationExclusions = AsnMgmtNotificationSettingsExclusions_Converter.toBER(s.emailNotificationExclusions, errors, newContext, "emailNotificationExclusions");
		TSConverter.validateParam(s, "iUnansweredCallSMSNotification", "number", errors, newContext);
		TSConverter.validateParam(s, "bSMSNotificationUseCallerNumberAsOriginator", "boolean", errors, newContext);
		const _objSMSNotificationExclusions = AsnMgmtNotificationSettingsExclusions_Converter.toBER(s.objSMSNotificationExclusions, errors, newContext, "objSMSNotificationExclusions");
		TSConverter.validateParam(s, "iLanguage", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sUserDefinedTelephonyLinkPrefix", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iUnansweredCallEMailNotification, name: "iUnansweredCallEMailNotification" }));
			t.push(new asn1ts.Boolean({ value: s.bEMailNotificationUseCallerMailAddress, name: "bEMailNotificationUseCallerMailAddress" }));
			t.push(new asn1ts.Boolean({ value: s.bEMailNotificationSendEMailsClientSide, name: "bEMailNotificationSendEMailsClientSide" }));
			t.push(new asn1ts.Boolean({ value: s.bEMailNotificationAttacheVCard, name: "bEMailNotificationAttacheVCard" }));
			t.push(new asn1ts.Boolean({ value: s.bEMailNotificationSendEMailsThirdPartyPickup, name: "bEMailNotificationSendEMailsThirdPartyPickup" }));
			t.push(new asn1ts.Boolean({ value: s.bEMailNotificationUseTelephonyLinkPrefix, name: "bEMailNotificationUseTelephonyLinkPrefix" }));
			if (_emailNotificationExclusions)
				t.push(_emailNotificationExclusions);
			t.push(new asn1ts.Integer({ value: s.iUnansweredCallSMSNotification, name: "iUnansweredCallSMSNotification" }));
			t.push(new asn1ts.Boolean({ value: s.bSMSNotificationUseCallerNumberAsOriginator, name: "bSMSNotificationUseCallerNumberAsOriginator" }));
			if (_objSMSNotificationExclusions)
				t.push(_objSMSNotificationExclusions);
			t.push(new asn1ts.Integer({ value: s.iLanguage, name: "iLanguage" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUserDefinedTelephonyLinkPrefix, name: "u8sUserDefinedTelephonyLinkPrefix" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtNotificationSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtNotificationSettings");

		let t: ENetUC_Mgmt.AsnMgmtNotificationSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtNotificationSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtNotificationSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iUnansweredCallEMailNotification", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEMailNotificationUseCallerMailAddress", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEMailNotificationSendEMailsClientSide", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEMailNotificationAttacheVCard", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEMailNotificationSendEMailsThirdPartyPickup", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEMailNotificationUseTelephonyLinkPrefix", "Boolean", errors, newContext);
			const _emailnotificationexclusions = AsnMgmtNotificationSettingsExclusions_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "emailNotificationExclusions"), errors, newContext, "emailNotificationExclusions");
			if (_emailnotificationexclusions)
				t.emailNotificationExclusions = _emailnotificationexclusions;
			TSConverter.fillASN1Param(s, t, "iUnansweredCallSMSNotification", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bSMSNotificationUseCallerNumberAsOriginator", "Boolean", errors, newContext);
			const _objsmsnotificationexclusions = AsnMgmtNotificationSettingsExclusions_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "objSMSNotificationExclusions"), errors, newContext, "objSMSNotificationExclusions");
			if (_objsmsnotificationexclusions)
				t.objSMSNotificationExclusions = _objsmsnotificationexclusions;
			TSConverter.fillASN1Param(s, t, "iLanguage", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUserDefinedTelephonyLinkPrefix", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtNotificationSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetNotificationSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetNotificationSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetNotificationSettingsResult";
		const _settings = AsnMgmtNotificationSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetNotificationSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetNotificationSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtNotificationSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetNotificationSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetNotificationSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetNotificationSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtNotificationSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetNotificationSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetNotificationSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetNotificationSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtNotificationSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetNotificationSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetNotificationSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetNotificationSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetNotificationSettingsArgument";
		const _settings = AsnMgmtNotificationSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetNotificationSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetNotificationSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtNotificationSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetNotificationSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetNotificationSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetNotificationSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtNotificationSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetNotificationSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetNotificationSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetNotificationSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtNotificationSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetNotificationSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSSLCertificateDetailsList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnSSLCertificateDetailsList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnSSLCertificateDetailsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSSLCertificateDetailsList");

		const t = [] as ENetUC_Mgmt.AsnSSLCertificateDetailsList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnSSLCertificateDetails_Converter.toJSON(se, errors, newContext, "AsnSSLCertificateDetails");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnSSLCertificateDetailsList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSSLCertificateDetailsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSSLCertificateDetailsList");

		let t: ENetUC_Mgmt.AsnSSLCertificateDetailsList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnSSLCertificateDetailsList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnSSLCertificateDetailsList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnSSLCertificateDetails_Converter.fromJSON(se, errors, newContext, "AsnSSLCertificateDetails", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnSSLCertificateDetailsList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnSSLCertificateDetailsList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSSLCertificateDetailsList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSSLCertificateDetailsList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnSSLCertificateDetails_Converter.toBER(s[id], errors, newContext, "AsnSSLCertificateDetails");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnSSLCertificateDetailsList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnSSLCertificateDetailsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSSLCertificateDetailsList");

		let t: ENetUC_Mgmt.AsnSSLCertificateDetailsList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnSSLCertificateDetailsList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnSSLCertificateDetailsList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnSSLCertificateDetails_Converter.fromBER(se, errors, newContext, "AsnSSLCertificateDetails", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnSSLCertificateDetailsList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAvailableCertificatesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableCertificatesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAvailableCertificatesResult";
		const _certificateDetailsList = AsnSSLCertificateDetailsList_Converter.toJSON(s.certificateDetailsList, errors, newContext, "certificateDetailsList");
		if (_certificateDetailsList)
			t.certificateDetailsList = _certificateDetailsList;

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableCertificatesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableCertificatesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _certificatedetailslist = AsnSSLCertificateDetailsList_Converter.fromJSON(s.certificateDetailsList, errors, newContext, "certificateDetailsList", false);
			if (_certificatedetailslist)
				t.certificateDetailsList = _certificatedetailslist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableCertificatesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAvailableCertificatesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAvailableCertificatesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _certificateDetailsList = AsnSSLCertificateDetailsList_Converter.toBER(s.certificateDetailsList, errors, newContext, "certificateDetailsList");
		if (!errors.hasNewErrors()) {
			if (_certificateDetailsList)
				t.push(_certificateDetailsList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableCertificatesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAvailableCertificatesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAvailableCertificatesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _certificatedetailslist = AsnSSLCertificateDetailsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "certificateDetailsList"), errors, newContext, "certificateDetailsList");
			if (_certificatedetailslist)
				t.certificateDetailsList = _certificatedetailslist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAvailableCertificatesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtCtiForwardEntryList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtCtiForwardEntryList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtCtiForwardEntryList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiForwardEntryList");

		const t = [] as ENetUC_Mgmt.AsnMgmtCtiForwardEntryList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtCtiForwardEntry_Converter.toJSON(se, errors, newContext, "AsnMgmtCtiForwardEntry");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntryList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiForwardEntryList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiForwardEntryList");

		let t: ENetUC_Mgmt.AsnMgmtCtiForwardEntryList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtCtiForwardEntryList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtCtiForwardEntryList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtCtiForwardEntry_Converter.fromJSON(se, errors, newContext, "AsnMgmtCtiForwardEntry", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntryList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtCtiForwardEntryList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtCtiForwardEntryList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtCtiForwardEntryList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtCtiForwardEntry_Converter.toBER(s[id], errors, newContext, "AsnMgmtCtiForwardEntry");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntryList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtCtiForwardEntryList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtCtiForwardEntryList");

		let t: ENetUC_Mgmt.AsnMgmtCtiForwardEntryList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtCtiForwardEntryList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtCtiForwardEntryList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtCtiForwardEntry_Converter.fromBER(se, errors, newContext, "AsnMgmtCtiForwardEntry", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtCtiForwardEntryList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineForwardingResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineForwardingResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineForwardingResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineForwardingResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineForwardingResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineForwardingResult";
		TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext);
		const _entryList = AsnMgmtCtiForwardEntryList_Converter.toJSON(s.entryList, errors, newContext, "entryList");
		if (_entryList)
			t.entryList = _entryList;

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineForwardingResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineForwardingResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineForwardingResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineForwardingResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineForwardingResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext, false);
			const _entrylist = AsnMgmtCtiForwardEntryList_Converter.fromJSON(s.entryList, errors, newContext, "entryList", false);
			if (_entrylist)
				t.entryList = _entrylist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineForwardingResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineForwardingResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineForwardingResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iEnabled", "number", errors, newContext);
		const _entryList = AsnMgmtCtiForwardEntryList_Converter.toBER(s.entryList, errors, newContext, "entryList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iEnabled, name: "iEnabled" }));
			if (_entryList)
				t.push(_entryList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineForwardingResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineForwardingResult");

		let t: ENetUC_Mgmt.AsnMgmtGetLineForwardingResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineForwardingResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineForwardingResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iEnabled", "Integer", errors, newContext);
			const _entrylist = AsnMgmtCtiForwardEntryList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "entryList"), errors, newContext, "entryList");
			if (_entrylist)
				t.entryList = _entrylist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineForwardingResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetLineForwardingArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLineForwardingArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetLineForwardingArgument";
		TSConverter.fillJSONParam(s, t, "iFWController", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext);
		const _entryList = AsnMgmtCtiForwardEntryList_Converter.toJSON(s.entryList, errors, newContext, "entryList");
		if (_entryList)
			t.entryList = _entryList;

		if (errors.validateResult(newContext, "AsnMgmtSetLineForwardingArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLineForwardingArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iFWController", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iEnabled", "number", errors, newContext, false);
			const _entrylist = AsnMgmtCtiForwardEntryList_Converter.fromJSON(s.entryList, errors, newContext, "entryList", false);
			if (_entrylist)
				t.entryList = _entrylist;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineForwardingArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetLineForwardingArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetLineForwardingArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iFWController", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		TSConverter.validateParam(s, "iEnabled", "number", errors, newContext);
		const _entryList = AsnMgmtCtiForwardEntryList_Converter.toBER(s.entryList, errors, newContext, "entryList");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iFWController, name: "iFWController" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
			t.push(new asn1ts.Integer({ value: s.iEnabled, name: "iEnabled" }));
			if (_entryList)
				t.push(_entryList);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineForwardingArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetLineForwardingArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetLineForwardingArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iFWController", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iEnabled", "Integer", errors, newContext);
			const _entrylist = AsnMgmtCtiForwardEntryList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "entryList"), errors, newContext, "entryList");
			if (_entrylist)
				t.entryList = _entrylist;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetLineForwardingArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAvailableLanguageList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAvailableLanguageList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAvailableLanguageList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAvailableLanguageList");

		const t = [] as ENetUC_Mgmt.AsnMgmtAvailableLanguageList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtAvailableLanguage_Converter.toJSON(se, errors, newContext, "AsnMgmtAvailableLanguage");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguageList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAvailableLanguageList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAvailableLanguageList");

		let t: ENetUC_Mgmt.AsnMgmtAvailableLanguageList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAvailableLanguageList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtAvailableLanguageList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtAvailableLanguage_Converter.fromJSON(se, errors, newContext, "AsnMgmtAvailableLanguage", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguageList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAvailableLanguageList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAvailableLanguageList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAvailableLanguageList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtAvailableLanguage_Converter.toBER(s[id], errors, newContext, "AsnMgmtAvailableLanguage");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguageList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAvailableLanguageList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAvailableLanguageList");

		let t: ENetUC_Mgmt.AsnMgmtAvailableLanguageList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAvailableLanguageList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtAvailableLanguageList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtAvailableLanguage_Converter.fromBER(se, errors, newContext, "AsnMgmtAvailableLanguage", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtAvailableLanguageList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetXMLAvailableLanguagesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetXMLAvailableLanguagesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetXMLAvailableLanguagesResult";
		const _availLanguages = AsnMgmtAvailableLanguageList_Converter.toJSON(s.availLanguages, errors, newContext, "availLanguages");
		if (_availLanguages)
			t.availLanguages = _availLanguages;

		if (errors.validateResult(newContext, "AsnMgmtGetXMLAvailableLanguagesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetXMLAvailableLanguagesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _availlanguages = AsnMgmtAvailableLanguageList_Converter.fromJSON(s.availLanguages, errors, newContext, "availLanguages", false);
			if (_availlanguages)
				t.availLanguages = _availlanguages;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetXMLAvailableLanguagesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetXMLAvailableLanguagesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetXMLAvailableLanguagesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _availLanguages = AsnMgmtAvailableLanguageList_Converter.toBER(s.availLanguages, errors, newContext, "availLanguages");
		if (!errors.hasNewErrors()) {
			if (_availLanguages)
				t.push(_availLanguages);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetXMLAvailableLanguagesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetXMLAvailableLanguagesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetXMLAvailableLanguagesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _availlanguages = AsnMgmtAvailableLanguageList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "availLanguages"), errors, newContext, "availLanguages");
			if (_availlanguages)
				t.availLanguages = _availlanguages;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetXMLAvailableLanguagesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtPushServiceDevicePropsList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDevicePropsList");

		const t = [] as ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtPushServiceDeviceProps_Converter.toJSON(se, errors, newContext, "AsnMgmtPushServiceDeviceProps");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicePropsList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDevicePropsList");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtPushServiceDeviceProps_Converter.fromJSON(se, errors, newContext, "AsnMgmtPushServiceDeviceProps", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicePropsList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtPushServiceDevicePropsList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDevicePropsList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtPushServiceDeviceProps_Converter.toBER(s[id], errors, newContext, "AsnMgmtPushServiceDeviceProps");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicePropsList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDevicePropsList");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtPushServiceDevicePropsList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtPushServiceDeviceProps_Converter.fromBER(se, errors, newContext, "AsnMgmtPushServiceDeviceProps", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicePropsList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtPushServiceDevicesResultArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDevicesResultArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtPushServiceDevicesResultArgument";
		const _listPushDevices = AsnMgmtPushServiceDevicePropsList_Converter.toJSON(s.listPushDevices, errors, newContext, "listPushDevices");
		if (_listPushDevices)
			t.listPushDevices = _listPushDevices;
		TSConverter.fillJSONParam(s, t, "u8sCrossRefID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bLastSegment", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicesResultArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDevicesResultArgument");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listpushdevices = AsnMgmtPushServiceDevicePropsList_Converter.fromJSON(s.listPushDevices, errors, newContext, "listPushDevices", false);
			if (_listpushdevices)
				t.listPushDevices = _listpushdevices;
			TSConverter.fillJSONParam(s, t, "u8sCrossRefID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bLastSegment", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicesResultArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtPushServiceDevicesResultArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDevicesResultArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _listPushDevices = AsnMgmtPushServiceDevicePropsList_Converter.toBER(s.listPushDevices, errors, newContext, "listPushDevices");
		TSConverter.validateParam(s, "u8sCrossRefID", "string", errors, newContext);
		TSConverter.validateParam(s, "bLastSegment", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_listPushDevices)
				t.push(_listPushDevices);
			t.push(new asn1ts.Utf8String({ value: s.u8sCrossRefID, name: "u8sCrossRefID" }));
			t.push(new asn1ts.Boolean({ value: s.bLastSegment, name: "bLastSegment" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicesResultArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDevicesResultArgument");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtPushServiceDevicesResultArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listpushdevices = AsnMgmtPushServiceDevicePropsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listPushDevices"), errors, newContext, "listPushDevices");
			if (_listpushdevices)
				t.listPushDevices = _listpushdevices;
			TSConverter.fillASN1Param(s, t, "u8sCrossRefID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bLastSegment", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDevicesResultArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtPushServiceDeviceChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDeviceChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtPushServiceDeviceChangedArgument";
		TSConverter.fillJSONParam(s, t, "iWhat", "number", errors, newContext);
		const _deviceProps = AsnMgmtPushServiceDeviceProps_Converter.toJSON(s.deviceProps, errors, newContext, "deviceProps");
		if (_deviceProps)
			t.deviceProps = _deviceProps;

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDeviceChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iWhat", "number", errors, newContext, false);
			const _deviceprops = AsnMgmtPushServiceDeviceProps_Converter.fromJSON(s.deviceProps, errors, newContext, "deviceProps", false);
			if (_deviceprops)
				t.deviceProps = _deviceprops;
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtPushServiceDeviceChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtPushServiceDeviceChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iWhat", "number", errors, newContext);
		const _deviceProps = AsnMgmtPushServiceDeviceProps_Converter.toBER(s.deviceProps, errors, newContext, "deviceProps");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iWhat, name: "iWhat" }));
			if (_deviceProps)
				t.push(_deviceProps);
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtPushServiceDeviceChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtPushServiceDeviceChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iWhat", "Integer", errors, newContext);
			const _deviceprops = AsnMgmtPushServiceDeviceProps_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "deviceProps"), errors, newContext, "deviceProps");
			if (_deviceprops)
				t.deviceProps = _deviceprops;
		}

		if (errors.validateResult(newContext, "AsnMgmtPushServiceDeviceChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetPhoneJournalSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetPhoneJournalSettingsResult";
		const _phoneJournalSettings = AsnMgmtPhoneJournalSettings_Converter.toJSON(s.phoneJournalSettings, errors, newContext, "phoneJournalSettings");
		if (_phoneJournalSettings)
			t.phoneJournalSettings = _phoneJournalSettings;

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _phonejournalsettings = AsnMgmtPhoneJournalSettings_Converter.fromJSON(s.phoneJournalSettings, errors, newContext, "phoneJournalSettings", false);
			if (_phonejournalsettings)
				t.phoneJournalSettings = _phonejournalsettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetPhoneJournalSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _phoneJournalSettings = AsnMgmtPhoneJournalSettings_Converter.toBER(s.phoneJournalSettings, errors, newContext, "phoneJournalSettings");
		if (!errors.hasNewErrors()) {
			if (_phoneJournalSettings)
				t.push(_phoneJournalSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetPhoneJournalSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetPhoneJournalSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _phonejournalsettings = AsnMgmtPhoneJournalSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "phoneJournalSettings"), errors, newContext, "phoneJournalSettings");
			if (_phonejournalsettings)
				t.phoneJournalSettings = _phonejournalsettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetPhoneJournalSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetPhoneJournalSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetPhoneJournalSettingsArgument";
		const _phoneJournalSettings = AsnMgmtPhoneJournalSettings_Converter.toJSON(s.phoneJournalSettings, errors, newContext, "phoneJournalSettings");
		if (_phoneJournalSettings)
			t.phoneJournalSettings = _phoneJournalSettings;

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _phonejournalsettings = AsnMgmtPhoneJournalSettings_Converter.fromJSON(s.phoneJournalSettings, errors, newContext, "phoneJournalSettings", false);
			if (_phonejournalsettings)
				t.phoneJournalSettings = _phonejournalsettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetPhoneJournalSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _phoneJournalSettings = AsnMgmtPhoneJournalSettings_Converter.toBER(s.phoneJournalSettings, errors, newContext, "phoneJournalSettings");
		if (!errors.hasNewErrors()) {
			if (_phoneJournalSettings)
				t.push(_phoneJournalSettings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetPhoneJournalSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetPhoneJournalSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _phonejournalsettings = AsnMgmtPhoneJournalSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "phoneJournalSettings"), errors, newContext, "phoneJournalSettings");
			if (_phonejournalsettings)
				t.phoneJournalSettings = _phonejournalsettings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetPhoneJournalSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMeshNodeConfigs_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMeshNodeConfigs, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMeshNodeConfigs | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeConfigs");

		const t = [] as ENetUC_Mgmt.AsnMgmtMeshNodeConfigs;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtMeshNodeConfig_Converter.toJSON(se, errors, newContext, "AsnMgmtMeshNodeConfig");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfigs"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeConfigs | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeConfigs");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeConfigs | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMeshNodeConfigs>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtMeshNodeConfigs();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtMeshNodeConfig_Converter.fromJSON(se, errors, newContext, "AsnMgmtMeshNodeConfig", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfigs"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMeshNodeConfigs | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMeshNodeConfigs";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeConfigs");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtMeshNodeConfig_Converter.toBER(s[id], errors, newContext, "AsnMgmtMeshNodeConfig");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfigs"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeConfigs | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeConfigs");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeConfigs | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMeshNodeConfigs.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtMeshNodeConfigs();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtMeshNodeConfig_Converter.fromBER(se, errors, newContext, "AsnMgmtMeshNodeConfig", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeConfigs"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetMeshNodeConfigsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetMeshNodeConfigsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetMeshNodeConfigsArgument";
		const _configs = AsnMgmtMeshNodeConfigs_Converter.toJSON(s.configs, errors, newContext, "configs");
		if (_configs)
			t.configs = _configs;

		if (errors.validateResult(newContext, "AsnMgmtSetMeshNodeConfigsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetMeshNodeConfigsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _configs = AsnMgmtMeshNodeConfigs_Converter.fromJSON(s.configs, errors, newContext, "configs", false);
			if (_configs)
				t.configs = _configs;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetMeshNodeConfigsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetMeshNodeConfigsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetMeshNodeConfigsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _configs = AsnMgmtMeshNodeConfigs_Converter.toBER(s.configs, errors, newContext, "configs");
		if (!errors.hasNewErrors()) {
			if (_configs)
				t.push(_configs);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetMeshNodeConfigsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetMeshNodeConfigsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetMeshNodeConfigsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _configs = AsnMgmtMeshNodeConfigs_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "configs"), errors, newContext, "configs");
			if (_configs)
				t.configs = _configs;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetMeshNodeConfigsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetMeshNodeConfigsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetMeshNodeConfigsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetMeshNodeConfigsResult";
		const _configs = AsnMgmtMeshNodeConfigs_Converter.toJSON(s.configs, errors, newContext, "configs");
		if (_configs)
			t.configs = _configs;

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeConfigsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetMeshNodeConfigsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _configs = AsnMgmtMeshNodeConfigs_Converter.fromJSON(s.configs, errors, newContext, "configs", false);
			if (_configs)
				t.configs = _configs;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeConfigsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetMeshNodeConfigsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetMeshNodeConfigsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _configs = AsnMgmtMeshNodeConfigs_Converter.toBER(s.configs, errors, newContext, "configs");
		if (!errors.hasNewErrors()) {
			if (_configs)
				t.push(_configs);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeConfigsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetMeshNodeConfigsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetMeshNodeConfigsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _configs = AsnMgmtMeshNodeConfigs_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "configs"), errors, newContext, "configs");
			if (_configs)
				t.configs = _configs;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeConfigsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMeshNodeStatus_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMeshNodeStatus, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMeshNodeStatus & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeStatus");

		const t = {} as ENetUC_Mgmt.AsnMgmtMeshNodeStatus & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtMeshNodeStatus";
		TSConverter.fillJSONParam(s, t, "u8sMeshNodeID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timeLastConnected", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "timeLastStatusUpdate", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServerVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sIPAddress", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bOutbound", "boolean", errors, newContext);
		const _tlsStatus = AsnMgmtMeshNodeStatusTLS_Converter.toJSON(s.tlsStatus, errors, newContext, "tlsStatus");
		if (_tlsStatus)
			t.tlsStatus = _tlsStatus;

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatus"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeStatus");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeStatus | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMeshNodeStatus>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtMeshNodeStatus["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMeshNodeID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iStatus", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "timeLastConnected", "string", errors, newContext, false))
				t.timeLastConnected = new Date(s.timeLastConnected);
			if (TSConverter.validateParam(s, "timeLastStatusUpdate", "string", errors, newContext, false))
				t.timeLastStatusUpdate = new Date(s.timeLastStatusUpdate);
			TSConverter.fillJSONParam(s, t, "u8sServerVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sIPAddress", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bOutbound", "boolean", errors, newContext, false);
			const _tlsstatus = AsnMgmtMeshNodeStatusTLS_Converter.fromJSON(s.tlsStatus, errors, newContext, "tlsStatus", false);
			if (_tlsstatus)
				t.tlsStatus = _tlsstatus;
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatus"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMeshNodeStatus | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMeshNodeStatus";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeStatus");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMeshNodeID", "string", errors, newContext);
		TSConverter.validateParam(s, "iStatus", "number", errors, newContext);
		TSConverter.validateParam(s, "timeLastConnected", "Date", errors, newContext);
		TSConverter.validateParam(s, "timeLastStatusUpdate", "Date", errors, newContext);
		TSConverter.validateParam(s, "u8sServerVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sIPAddress", "string", errors, newContext);
		TSConverter.validateParam(s, "bOutbound", "boolean", errors, newContext);
		const _tlsStatus = AsnMgmtMeshNodeStatusTLS_Converter.toBER(s.tlsStatus, errors, newContext, "tlsStatus");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMeshNodeID, name: "u8sMeshNodeID" }));
			t.push(new asn1ts.Integer({ value: s.iStatus, name: "iStatus" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timeLastConnected), name: "timeLastConnected" }));
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.timeLastStatusUpdate), name: "timeLastStatusUpdate" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServerVersion, name: "u8sServerVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sIPAddress, name: "u8sIPAddress" }));
			t.push(new asn1ts.Boolean({ value: s.bOutbound, name: "bOutbound" }));
			if (_tlsStatus)
				t.push(_tlsStatus);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatus"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeStatus | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeStatus");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeStatus | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMeshNodeStatus.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtMeshNodeStatus["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMeshNodeID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iStatus", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timeLastConnected", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "timeLastStatusUpdate", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServerVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sIPAddress", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bOutbound", "Boolean", errors, newContext);
			const _tlsstatus = AsnMgmtMeshNodeStatusTLS_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "tlsStatus"), errors, newContext, "tlsStatus");
			if (_tlsstatus)
				t.tlsStatus = _tlsstatus;
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatus"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtMeshNodeStatuses_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtMeshNodeStatuses, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtMeshNodeStatuses | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeStatuses");

		const t = [] as ENetUC_Mgmt.AsnMgmtMeshNodeStatuses;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtMeshNodeStatus_Converter.toJSON(se, errors, newContext, "AsnMgmtMeshNodeStatus");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatuses"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeStatuses | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeStatuses");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeStatuses | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtMeshNodeStatuses>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtMeshNodeStatuses();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtMeshNodeStatus_Converter.fromJSON(se, errors, newContext, "AsnMgmtMeshNodeStatus", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatuses"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtMeshNodeStatuses | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtMeshNodeStatuses";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtMeshNodeStatuses");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtMeshNodeStatus_Converter.toBER(s[id], errors, newContext, "AsnMgmtMeshNodeStatus");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatuses"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtMeshNodeStatuses | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtMeshNodeStatuses");

		let t: ENetUC_Mgmt.AsnMgmtMeshNodeStatuses | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtMeshNodeStatuses.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtMeshNodeStatuses();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtMeshNodeStatus_Converter.fromBER(se, errors, newContext, "AsnMgmtMeshNodeStatus", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtMeshNodeStatuses"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetMeshNodeStatusesResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetMeshNodeStatusesResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetMeshNodeStatusesResult";
		const _statuses = AsnMgmtMeshNodeStatuses_Converter.toJSON(s.statuses, errors, newContext, "statuses");
		if (_statuses)
			t.statuses = _statuses;

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeStatusesResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetMeshNodeStatusesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _statuses = AsnMgmtMeshNodeStatuses_Converter.fromJSON(s.statuses, errors, newContext, "statuses", false);
			if (_statuses)
				t.statuses = _statuses;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeStatusesResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetMeshNodeStatusesResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetMeshNodeStatusesResult");

		// [Print_BER_EncoderSeqDefCode]
		const _statuses = AsnMgmtMeshNodeStatuses_Converter.toBER(s.statuses, errors, newContext, "statuses");
		if (!errors.hasNewErrors()) {
			if (_statuses)
				t.push(_statuses);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeStatusesResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetMeshNodeStatusesResult");

		let t: ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetMeshNodeStatusesResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _statuses = AsnMgmtMeshNodeStatuses_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "statuses"), errors, newContext, "statuses");
			if (_statuses)
				t.statuses = _statuses;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetMeshNodeStatusesResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConnectionInformationChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConnectionInformationChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConnectionInformationChangedArgument";
		TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext);
		const _conInfo = AsnMgmtClientConnectionInformation_Converter.toJSON(s.conInfo, errors, newContext, "conInfo");
		if (_conInfo)
			t.conInfo = _conInfo;

		if (errors.validateResult(newContext, "AsnMgmtConnectionInformationChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConnectionInformationChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sContactID", "string", errors, newContext, false);
			const _coninfo = AsnMgmtClientConnectionInformation_Converter.fromJSON(s.conInfo, errors, newContext, "conInfo", false);
			if (_coninfo)
				t.conInfo = _coninfo;
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionInformationChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConnectionInformationChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConnectionInformationChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sContactID", "string", errors, newContext);
		const _conInfo = AsnMgmtClientConnectionInformation_Converter.toBER(s.conInfo, errors, newContext, "conInfo");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sContactID, name: "u8sContactID" }));
			if (_conInfo)
				t.push(_conInfo);
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionInformationChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConnectionInformationChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConnectionInformationChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sContactID", "Utf8String", errors, newContext);
			const _coninfo = AsnMgmtClientConnectionInformation_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "conInfo"), errors, newContext, "conInfo");
			if (_coninfo)
				t.conInfo = _coninfo;
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionInformationChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConnectionOptions_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConnectionOptions, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConnectionOptions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConnectionOptions");

		const t = [] as ENetUC_Mgmt.AsnMgmtConnectionOptions;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtConnectionOption_Converter.toJSON(se, errors, newContext, "AsnMgmtConnectionOption");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionOptions"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConnectionOptions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConnectionOptions");

		let t: ENetUC_Mgmt.AsnMgmtConnectionOptions | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConnectionOptions>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtConnectionOptions();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtConnectionOption_Converter.fromJSON(se, errors, newContext, "AsnMgmtConnectionOption", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionOptions"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConnectionOptions | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConnectionOptions";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConnectionOptions");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtConnectionOption_Converter.toBER(s[id], errors, newContext, "AsnMgmtConnectionOption");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtConnectionOptions"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConnectionOptions | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConnectionOptions");

		let t: ENetUC_Mgmt.AsnMgmtConnectionOptions | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConnectionOptions.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtConnectionOptions();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtConnectionOption_Converter.fromBER(se, errors, newContext, "AsnMgmtConnectionOption", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtConnectionOptions"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConnectionOptionsDNSResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConnectionOptionsDNSResult";
		const _listConnectionOptions = AsnMgmtConnectionOptions_Converter.toJSON(s.listConnectionOptions, errors, newContext, "listConnectionOptions");
		if (_listConnectionOptions)
			t.listConnectionOptions = _listConnectionOptions;

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _listconnectionoptions = AsnMgmtConnectionOptions_Converter.fromJSON(s.listConnectionOptions, errors, newContext, "listConnectionOptions", false);
			if (_listconnectionoptions)
				t.listConnectionOptions = _listconnectionoptions;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConnectionOptionsDNSResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSResult");

		// [Print_BER_EncoderSeqDefCode]
		const _listConnectionOptions = AsnMgmtConnectionOptions_Converter.toBER(s.listConnectionOptions, errors, newContext, "listConnectionOptions");
		if (!errors.hasNewErrors()) {
			if (_listConnectionOptions)
				t.push(_listConnectionOptions);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConnectionOptionsDNSResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConnectionOptionsDNSResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _listconnectionoptions = AsnMgmtConnectionOptions_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "listConnectionOptions"), errors, newContext, "listConnectionOptions");
			if (_listconnectionoptions)
				t.listConnectionOptions = _listconnectionoptions;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConnectionOptionsDNSResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConfigurationManagerSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConfigurationManagerSettingsResult";
		const _settings = AsnMgmtConfigurationManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtConfigurationManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConfigurationManagerSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtConfigurationManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtConfigurationManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetConfigurationManagerSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetConfigurationManagerSettingsArgument";
		const _settings = AsnMgmtConfigurationManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtConfigurationManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetConfigurationManagerSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtConfigurationManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetConfigurationManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetConfigurationManagerSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtConfigurationManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetConfigurationManagerSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUserManagerConnectionStatusResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUserManagerConnectionStatusResult";
		const _status = AsnMgmtUserManagerConnectionStatus_Converter.toJSON(s.status, errors, newContext, "status");
		if (_status)
			t.status = _status;

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _status = AsnMgmtUserManagerConnectionStatus_Converter.fromJSON(s.status, errors, newContext, "status", false);
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUserManagerConnectionStatusResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusResult");

		// [Print_BER_EncoderSeqDefCode]
		const _status = AsnMgmtUserManagerConnectionStatus_Converter.toBER(s.status, errors, newContext, "status");
		if (!errors.hasNewErrors()) {
			if (_status)
				t.push(_status);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUserManagerConnectionStatusResult");

		let t: ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUserManagerConnectionStatusResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _status = AsnMgmtUserManagerConnectionStatus_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "status"), errors, newContext, "status");
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUserManagerConnectionStatusResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserManagerConnectionStatusChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerConnectionStatusChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtUserManagerConnectionStatusChangedArgument";
		const _status = AsnMgmtUserManagerConnectionStatus_Converter.toJSON(s.status, errors, newContext, "status");
		if (_status)
			t.status = _status;

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerConnectionStatusChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _status = AsnMgmtUserManagerConnectionStatus_Converter.fromJSON(s.status, errors, newContext, "status", false);
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserManagerConnectionStatusChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerConnectionStatusChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _status = AsnMgmtUserManagerConnectionStatus_Converter.toBER(s.status, errors, newContext, "status");
		if (!errors.hasNewErrors()) {
			if (_status)
				t.push(_status);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerConnectionStatusChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _status = AsnMgmtUserManagerConnectionStatus_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "status"), errors, newContext, "status");
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConfigurationManagerStatusResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConfigurationManagerStatusResult";
		const _status = AsnMgmtConfigurationManagerStatus_Converter.toJSON(s.status, errors, newContext, "status");
		if (_status)
			t.status = _status;

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _status = AsnMgmtConfigurationManagerStatus_Converter.fromJSON(s.status, errors, newContext, "status", false);
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConfigurationManagerStatusResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusResult");

		// [Print_BER_EncoderSeqDefCode]
		const _status = AsnMgmtConfigurationManagerStatus_Converter.toBER(s.status, errors, newContext, "status");
		if (!errors.hasNewErrors()) {
			if (_status)
				t.push(_status);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerStatusResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerStatusResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _status = AsnMgmtConfigurationManagerStatus_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "status"), errors, newContext, "status");
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerStatusResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerStatusChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerStatusChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConfigurationManagerStatusChangedArgument";
		const _status = AsnMgmtConfigurationManagerStatus_Converter.toJSON(s.status, errors, newContext, "status");
		if (_status)
			t.status = _status;

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerStatusChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _status = AsnMgmtConfigurationManagerStatus_Converter.fromJSON(s.status, errors, newContext, "status", false);
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerStatusChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerStatusChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _status = AsnMgmtConfigurationManagerStatus_Converter.toBER(s.status, errors, newContext, "status");
		if (!errors.hasNewErrors()) {
			if (_status)
				t.push(_status);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerStatusChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _status = AsnMgmtConfigurationManagerStatus_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "status"), errors, newContext, "status");
			if (_status)
				t.status = _status;
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerServerList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerServerList");

		const t = [] as ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtConfigurationManagerServerListItem_Converter.toJSON(se, errors, newContext, "AsnMgmtConfigurationManagerServerListItem");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerServerList");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtConfigurationManagerServerListItem_Converter.fromJSON(se, errors, newContext, "AsnMgmtConfigurationManagerServerListItem", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerServerList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerServerList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtConfigurationManagerServerListItem_Converter.toBER(s[id], errors, newContext, "AsnMgmtConfigurationManagerServerListItem");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerServerList");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtConfigurationManagerServerList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtConfigurationManagerServerListItem_Converter.fromBER(se, errors, newContext, "AsnMgmtConfigurationManagerServerListItem", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetConfigurationManagerServerListResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerServerListResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetConfigurationManagerServerListResult";
		const _serverList = AsnMgmtConfigurationManagerServerList_Converter.toJSON(s.serverList, errors, newContext, "serverList");
		if (_serverList)
			t.serverList = _serverList;

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerServerListResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerServerListResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _serverlist = AsnMgmtConfigurationManagerServerList_Converter.fromJSON(s.serverList, errors, newContext, "serverList", false);
			if (_serverlist)
				t.serverList = _serverlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerServerListResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetConfigurationManagerServerListResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetConfigurationManagerServerListResult");

		// [Print_BER_EncoderSeqDefCode]
		const _serverList = AsnMgmtConfigurationManagerServerList_Converter.toBER(s.serverList, errors, newContext, "serverList");
		if (!errors.hasNewErrors()) {
			if (_serverList)
				t.push(_serverList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerServerListResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetConfigurationManagerServerListResult");

		let t: ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetConfigurationManagerServerListResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _serverlist = AsnMgmtConfigurationManagerServerList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "serverList"), errors, newContext, "serverList");
			if (_serverlist)
				t.serverList = _serverlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetConfigurationManagerServerListResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerServerListChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerServerListChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtConfigurationManagerServerListChangedArgument";
		const _serverList = AsnMgmtConfigurationManagerServerList_Converter.toJSON(s.serverList, errors, newContext, "serverList");
		if (_serverList)
			t.serverList = _serverList;

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerServerListChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _serverlist = AsnMgmtConfigurationManagerServerList_Converter.fromJSON(s.serverList, errors, newContext, "serverList", false);
			if (_serverlist)
				t.serverList = _serverlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerServerListChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerServerListChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _serverList = AsnMgmtConfigurationManagerServerList_Converter.toBER(s.serverList, errors, newContext, "serverList");
		if (!errors.hasNewErrors()) {
			if (_serverList)
				t.push(_serverList);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerServerListChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtConfigurationManagerServerListChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _serverlist = AsnMgmtConfigurationManagerServerList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "serverList"), errors, newContext, "serverList");
			if (_serverlist)
				t.serverList = _serverlist;
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerServerListChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAdminUserManagerSettingsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAdminUserManagerSettingsResult";
		const _settings = AsnMgmtAdminUserManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;
		TSConverter.fillJSONParam(s, t, "iLastErrorCode", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtAdminUserManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
			TSConverter.fillJSONParam(s, t, "iLastErrorCode", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAdminUserManagerSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtAdminUserManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		TSConverter.validateParam(s, "iLastErrorCode", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
			t.push(new asn1ts.Integer({ value: s.iLastErrorCode, name: "iLastErrorCode" }));
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserManagerSettingsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserManagerSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtAdminUserManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
			TSConverter.fillASN1Param(s, t, "iLastErrorCode", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserManagerSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtSetAdminUserManagerSettingsArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtSetAdminUserManagerSettingsArgument";
		const _settings = AsnMgmtAdminUserManagerSettings_Converter.toJSON(s.settings, errors, newContext, "settings");
		if (_settings)
			t.settings = _settings;

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _settings = AsnMgmtAdminUserManagerSettings_Converter.fromJSON(s.settings, errors, newContext, "settings", false);
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtSetAdminUserManagerSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _settings = AsnMgmtAdminUserManagerSettings_Converter.toBER(s.settings, errors, newContext, "settings");
		if (!errors.hasNewErrors()) {
			if (_settings)
				t.push(_settings);
		}

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtSetAdminUserManagerSettingsArgument");

		let t: ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtSetAdminUserManagerSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _settings = AsnMgmtAdminUserManagerSettings_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "settings"), errors, newContext, "settings");
			if (_settings)
				t.settings = _settings;
		}

		if (errors.validateResult(newContext, "AsnMgmtSetAdminUserManagerSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAdminUserRightChoice_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAdminUserRightChoice, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAdminUserRightChoice & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRightChoice");

		const t = {} as ENetUC_Mgmt.AsnMgmtAdminUserRightChoice & INamedType;

		// [Print_JSON_EncoderChoiceDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAdminUserRightChoice";
		if (s.readwrite != null) {
			const _readwrite = AsnMgmtAdminUserRightStateReadWrite_Converter.toJSON(s.readwrite, errors, newContext, "readwrite");
			if (_readwrite)
				t.readwrite = _readwrite;
		} else if (s.execute != null) {
			const _execute = AsnMgmtAdminUserRightStateExecute_Converter.toJSON(s.execute, errors, newContext, "execute");
			if (_execute)
				t.execute = _execute;
		} else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightChoice"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRightChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRightChoice");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRightChoice | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAdminUserRightChoice>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRightChoice["initEmpty"].call(0);
			// [Print_JSON_DecoderChoiceDefCode]
			if (s.readwrite !== undefined)
				t.readwrite = AsnMgmtAdminUserRightStateReadWrite_Converter.fromJSON(s.readwrite, errors, newContext, "readwrite", false);
			else if (s.execute !== undefined)
				t.execute = AsnMgmtAdminUserRightStateExecute_Converter.fromJSON(s.execute, errors, newContext, "execute", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightChoice"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAdminUserRightChoice | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.BaseBlock | undefined {
		name ||= "AsnMgmtAdminUserRightChoice";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		let t: asn1ts.BaseBlock | undefined;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRightChoice");

		// [Print_BER_EncoderChoiceDefCode]
		if (s.readwrite)
			t = AsnMgmtAdminUserRightStateReadWrite_Converter.toBER(s.readwrite, errors, newContext, "readwrite", 0);
		else if (s.execute)
			t = AsnMgmtAdminUserRightStateExecute_Converter.toBER(s.execute, errors, newContext, "execute", 1);
		else
			errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "property missing"));

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightChoice"))
			return t;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRightChoice | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRightChoice");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRightChoice | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAdminUserRightChoice.getASN1Schema, data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRightChoice["initEmpty"].call(0);
			// [Print_BER_DecoderChoiceDefCode]
			if (s.choiceName === "readwrite" && asn1ts.Sequence.typeGuard(s))
				t.readwrite = AsnMgmtAdminUserRightStateReadWrite_Converter.fromBER(s, undefined, newContext, "readwrite", false);
			else if (s.choiceName === "execute" && asn1ts.Sequence.typeGuard(s))
				t.execute = AsnMgmtAdminUserRightStateExecute_Converter.fromBER(s, undefined, newContext, "execute", false);
			else if (!(optional === true))
				errors.push(new ConverterError(ConverterErrorType.PROPERTY_MISSING, newContext.context, "Property has not been filled"));
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRightChoice"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAdminUserRight_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAdminUserRight, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAdminUserRight & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRight");

		const t = {} as ENetUC_Mgmt.AsnMgmtAdminUserRight & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtAdminUserRight";
		TSConverter.fillJSONParam(s, t, "right", "number", errors, newContext);
		const _state = AsnMgmtAdminUserRightChoice_Converter.toJSON(s.state, errors, newContext, "state");
		if (_state)
			t.state = _state;

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRight"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRight | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRight");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRight | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAdminUserRight>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRight["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "right", "number", errors, newContext, false);
			const _state = AsnMgmtAdminUserRightChoice_Converter.fromJSON(s.state, errors, newContext, "state", false);
			if (_state)
				t.state = _state;
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRight"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAdminUserRight | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAdminUserRight";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRight");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "right", "number", errors, newContext);
		const _state = AsnMgmtAdminUserRightChoice_Converter.toBER(s.state, errors, newContext, "state");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Enumerated({ value: s.right, name: "right" }));
			if (_state)
				t.push(_state);
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRight"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRight | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRight");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRight | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAdminUserRight.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtAdminUserRight["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "right", "Enumerated", errors, newContext);
			const _state = AsnMgmtAdminUserRightChoice_Converter.fromBER(s.getValueByName("state"), errors, newContext, "state");
			if (_state)
				t.state = _state;
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRight"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtAdminUserRights_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtAdminUserRights, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtAdminUserRights | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRights");

		const t = [] as ENetUC_Mgmt.AsnMgmtAdminUserRights;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtAdminUserRight_Converter.toJSON(se, errors, newContext, "AsnMgmtAdminUserRight");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRights"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRights | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRights");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRights | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtAdminUserRights>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtAdminUserRights();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtAdminUserRight_Converter.fromJSON(se, errors, newContext, "AsnMgmtAdminUserRight", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRights"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtAdminUserRights | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtAdminUserRights";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtAdminUserRights");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtAdminUserRight_Converter.toBER(s[id], errors, newContext, "AsnMgmtAdminUserRight");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtAdminUserRights"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtAdminUserRights | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtAdminUserRights");

		let t: ENetUC_Mgmt.AsnMgmtAdminUserRights | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtAdminUserRights.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtAdminUserRights();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtAdminUserRight_Converter.fromBER(se, errors, newContext, "AsnMgmtAdminUserRight", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtAdminUserRights"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetAdminUserRightsResult_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserRightsResult");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetAdminUserRightsResult";
		const _rights = AsnMgmtAdminUserRights_Converter.toJSON(s.rights, errors, newContext, "rights");
		if (_rights)
			t.rights = _rights;

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserRightsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _rights = AsnMgmtAdminUserRights_Converter.fromJSON(s.rights, errors, newContext, "rights", false);
			if (_rights)
				t.rights = _rights;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetAdminUserRightsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetAdminUserRightsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _rights = AsnMgmtAdminUserRights_Converter.toBER(s.rights, errors, newContext, "rights");
		if (!errors.hasNewErrors()) {
			if (_rights)
				t.push(_rights);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetAdminUserRightsResult");

		let t: ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetAdminUserRightsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _rights = AsnMgmtAdminUserRights_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "rights"), errors, newContext, "rights");
			if (_rights)
				t.rights = _rights;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetAdminUserRightsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtComputerFoundEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtComputerFoundEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtComputerFoundEventArgument";
		const _computerProfile = ENetUC_Admin_Converter.AsnComputerProfile_Converter.toJSON(s.computerProfile, errors, newContext, "computerProfile");
		if (_computerProfile)
			t.computerProfile = _computerProfile;
		const _softwareStatusComputer = AsnMgmtSoftwareStatusComputer_Converter.toJSON(s.softwareStatusComputer, errors, newContext, "softwareStatusComputer");
		if (_softwareStatusComputer)
			t.softwareStatusComputer = _softwareStatusComputer;
		const _clientInstallProfileData = AsnMgmtClientInstallProfileData_Converter.toJSON(s.clientInstallProfileData, errors, newContext, "clientInstallProfileData");
		if (_clientInstallProfileData)
			t.clientInstallProfileData = _clientInstallProfileData;

		if (errors.validateResult(newContext, "AsnMgmtComputerFoundEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtComputerFoundEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _computerprofile = ENetUC_Admin_Converter.AsnComputerProfile_Converter.fromJSON(s.computerProfile, errors, newContext, "computerProfile", false);
			if (_computerprofile)
				t.computerProfile = _computerprofile;
			const _softwarestatuscomputer = AsnMgmtSoftwareStatusComputer_Converter.fromJSON(s.softwareStatusComputer, errors, newContext, "softwareStatusComputer", false);
			if (_softwarestatuscomputer)
				t.softwareStatusComputer = _softwarestatuscomputer;
			const _clientinstallprofiledata = AsnMgmtClientInstallProfileData_Converter.fromJSON(s.clientInstallProfileData, errors, newContext, "clientInstallProfileData", false);
			if (_clientinstallprofiledata)
				t.clientInstallProfileData = _clientinstallprofiledata;
		}

		if (errors.validateResult(newContext, "AsnMgmtComputerFoundEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtComputerFoundEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtComputerFoundEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _computerProfile = ENetUC_Admin_Converter.AsnComputerProfile_Converter.toBER(s.computerProfile, errors, newContext, "computerProfile");
		const _softwareStatusComputer = AsnMgmtSoftwareStatusComputer_Converter.toBER(s.softwareStatusComputer, errors, newContext, "softwareStatusComputer");
		const _clientInstallProfileData = AsnMgmtClientInstallProfileData_Converter.toBER(s.clientInstallProfileData, errors, newContext, "clientInstallProfileData");
		if (!errors.hasNewErrors()) {
			if (_computerProfile)
				t.push(_computerProfile);
			if (_softwareStatusComputer)
				t.push(_softwareStatusComputer);
			if (_clientInstallProfileData)
				t.push(_clientInstallProfileData);
		}

		if (errors.validateResult(newContext, "AsnMgmtComputerFoundEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtComputerFoundEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtComputerFoundEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _computerprofile = ENetUC_Admin_Converter.AsnComputerProfile_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "computerProfile"), errors, newContext, "computerProfile");
			if (_computerprofile)
				t.computerProfile = _computerprofile;
			const _softwarestatuscomputer = AsnMgmtSoftwareStatusComputer_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "softwareStatusComputer"), errors, newContext, "softwareStatusComputer");
			if (_softwarestatuscomputer)
				t.softwareStatusComputer = _softwarestatuscomputer;
			const _clientinstallprofiledata = AsnMgmtClientInstallProfileData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "clientInstallProfileData"), errors, newContext, "clientInstallProfileData");
			if (_clientinstallprofiledata)
				t.clientInstallProfileData = _clientinstallprofiledata;
		}

		if (errors.validateResult(newContext, "AsnMgmtComputerFoundEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetLineStatesEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineStatesEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetLineStatesEventArgument";
		TSConverter.fillJSONParam(s, t, "iDumpMessage", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDumpType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOpenState", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iNumCalls", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iSipResponseCode", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sReasonPhrase", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sEffectiveHomeServer", "string", errors, newContext, true);
		if (s.lineStatusList) {
			const _lineStatusList = AsnMgmtLineStatusList_Converter.toJSON(s.lineStatusList, errors, newContext, "lineStatusList");
			if (_lineStatusList)
				t.lineStatusList = _lineStatusList;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineStatesEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iDumpMessage", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDumpType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sLineID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOpenState", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iNumCalls", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iSipResponseCode", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sReasonPhrase", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sEffectiveHomeServer", "string", errors, newContext, true);
			const _linestatuslist = AsnMgmtLineStatusList_Converter.fromJSON(s.lineStatusList, errors, newContext, "lineStatusList", true);
			if (_linestatuslist)
				t.lineStatusList = _linestatuslist;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetLineStatesEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetLineStatesEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iDumpMessage", "number", errors, newContext);
		TSConverter.validateParam(s, "iDumpType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sLineID", "string", errors, newContext);
		TSConverter.validateParam(s, "iOpenState", "number", errors, newContext);
		TSConverter.validateParam(s, "iNumCalls", "number", errors, newContext);
		TSConverter.validateParam(s, "iSipResponseCode", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sReasonPhrase", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sEffectiveHomeServer", "string", errors, newContext, true);
		const _lineStatusList = AsnMgmtLineStatusList_Converter.toBER(s.lineStatusList, errors, newContext, "lineStatusList", 1);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iDumpMessage, name: "iDumpMessage" }));
			t.push(new asn1ts.Integer({ value: s.iDumpType, name: "iDumpType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sLineID, name: "u8sLineID" }));
			t.push(new asn1ts.Integer({ value: s.iOpenState, name: "iOpenState" }));
			t.push(new asn1ts.Integer({ value: s.iNumCalls, name: "iNumCalls" }));
			t.push(new asn1ts.Integer({ value: s.iSipResponseCode, name: "iSipResponseCode" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sReasonPhrase, name: "u8sReasonPhrase" }));
			if (s.u8sEffectiveHomeServer !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sEffectiveHomeServer, name: "u8sEffectiveHomeServer", idBlock: { optionalID: 0 } }));
			if (_lineStatusList)
				t.push(_lineStatusList);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetLineStatesEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetLineStatesEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iDumpMessage", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDumpType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sLineID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOpenState", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iNumCalls", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iSipResponseCode", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sReasonPhrase", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sEffectiveHomeServer", "Utf8String", errors, newContext, true);
			t.lineStatusList = AsnMgmtLineStatusList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "lineStatusList"), errors, newContext, "lineStatusList", true);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetLineStatesEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineGroupAddedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineGroupAddedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineGroupAddedArgument";
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupAddedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineGroupAddedArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupAddedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineGroupAddedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineGroupAddedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupAddedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineGroupAddedArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineGroupAddedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupAddedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtOnLineGroupChangedArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineGroupChangedArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtOnLineGroupChangedArgument";
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toJSON(s.config, errors, newContext, "config");
		if (_config)
			t.config = _config;

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupChangedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineGroupChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromJSON(s.config, errors, newContext, "config", false);
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupChangedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtOnLineGroupChangedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtOnLineGroupChangedArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _config = AsnMgmtTapiLineGroupConfiguration_Converter.toBER(s.config, errors, newContext, "config");
		if (!errors.hasNewErrors()) {
			if (_config)
				t.push(_config);
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupChangedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtOnLineGroupChangedArgument");

		let t: ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtOnLineGroupChangedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _config = AsnMgmtTapiLineGroupConfiguration_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "config"), errors, newContext, "config");
			if (_config)
				t.config = _config;
		}

		if (errors.validateResult(newContext, "AsnMgmtOnLineGroupChangedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtGetUsersEventArgument_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtGetUsersEventArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtGetUsersEventArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUsersEventArgument");

		const t = {} as ENetUC_Mgmt.AsnMgmtGetUsersEventArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnMgmtGetUsersEventArgument";
		const _userProfile = ENetUC_Admin_Converter.AsnUserProfile_Converter.toJSON(s.userProfile, errors, newContext, "userProfile");
		if (_userProfile)
			t.userProfile = _userProfile;
		const _clientConnectionInfo = AsnMgmtClientConnectionInformation_Converter.toJSON(s.clientConnectionInfo, errors, newContext, "clientConnectionInfo");
		if (_clientConnectionInfo)
			t.clientConnectionInfo = _clientConnectionInfo;

		if (errors.validateResult(newContext, "AsnMgmtGetUsersEventArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUsersEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUsersEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUsersEventArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtGetUsersEventArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Mgmt.AsnMgmtGetUsersEventArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _userprofile = ENetUC_Admin_Converter.AsnUserProfile_Converter.fromJSON(s.userProfile, errors, newContext, "userProfile", false);
			if (_userprofile)
				t.userProfile = _userprofile;
			const _clientconnectioninfo = AsnMgmtClientConnectionInformation_Converter.fromJSON(s.clientConnectionInfo, errors, newContext, "clientConnectionInfo", false);
			if (_clientconnectioninfo)
				t.clientConnectionInfo = _clientconnectioninfo;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersEventArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtGetUsersEventArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtGetUsersEventArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtGetUsersEventArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _userProfile = ENetUC_Admin_Converter.AsnUserProfile_Converter.toBER(s.userProfile, errors, newContext, "userProfile");
		const _clientConnectionInfo = AsnMgmtClientConnectionInformation_Converter.toBER(s.clientConnectionInfo, errors, newContext, "clientConnectionInfo");
		if (!errors.hasNewErrors()) {
			if (_userProfile)
				t.push(_userProfile);
			if (_clientConnectionInfo)
				t.push(_clientConnectionInfo);
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersEventArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtGetUsersEventArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtGetUsersEventArgument");

		let t: ENetUC_Mgmt.AsnMgmtGetUsersEventArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtGetUsersEventArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Mgmt.AsnMgmtGetUsersEventArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _userprofile = ENetUC_Admin_Converter.AsnUserProfile_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "userProfile"), errors, newContext, "userProfile");
			if (_userprofile)
				t.userProfile = _userprofile;
			const _clientconnectioninfo = AsnMgmtClientConnectionInformation_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "clientConnectionInfo"), errors, newContext, "clientConnectionInfo");
			if (_clientconnectioninfo)
				t.clientConnectionInfo = _clientconnectioninfo;
		}

		if (errors.validateResult(newContext, "AsnMgmtGetUsersEventArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtUserManagerConnectionStatusList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerConnectionStatusList");

		const t = [] as ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtUserManagerConnectionStatus_Converter.toJSON(se, errors, newContext, "AsnMgmtUserManagerConnectionStatus");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerConnectionStatusList");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtUserManagerConnectionStatus_Converter.fromJSON(se, errors, newContext, "AsnMgmtUserManagerConnectionStatus", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtUserManagerConnectionStatusList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtUserManagerConnectionStatusList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtUserManagerConnectionStatus_Converter.toBER(s[id], errors, newContext, "AsnMgmtUserManagerConnectionStatus");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtUserManagerConnectionStatusList");

		let t: ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtUserManagerConnectionStatusList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtUserManagerConnectionStatus_Converter.fromBER(se, errors, newContext, "AsnMgmtUserManagerConnectionStatus", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtUserManagerConnectionStatusList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnMgmtConfigurationManagerStatusList_Converter {
	public static toJSON(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerStatusList");

		const t = [] as ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnMgmtConfigurationManagerStatus_Converter.toJSON(se, errors, newContext, "AsnMgmtConfigurationManagerStatus");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerStatusList");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnMgmtConfigurationManagerStatus_Converter.fromJSON(se, errors, newContext, "AsnMgmtConfigurationManagerStatus", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnMgmtConfigurationManagerStatusList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnMgmtConfigurationManagerStatusList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnMgmtConfigurationManagerStatus_Converter.toBER(s[id], errors, newContext, "AsnMgmtConfigurationManagerStatus");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnMgmtConfigurationManagerStatusList");

		let t: ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_Mgmt.AsnMgmtConfigurationManagerStatusList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnMgmtConfigurationManagerStatus_Converter.fromBER(se, errors, newContext, "AsnMgmtConfigurationManagerStatus", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnMgmtConfigurationManagerStatusList"))
			return t;

		return undefined;
	}
}
