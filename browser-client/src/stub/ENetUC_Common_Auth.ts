// [PrintTSCodeOne]
// [PrintTSComments]
/*
 * ENetUC_Common_Auth.ts
 * "UC-Server-Access-Protocol-AuthCommon" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
/**
 * Common types used for authentication
 * ## Module description
 * This module contains structures that are mainly used in combination with the logon
 * There should not be any function\/operation defintions in this module.
 *
 * THERE SHOULD NOT BE ANY FUNCTION\/OPERATION DEFINTIONS IN THIS MODULE.
 */
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Common_Auth";
export const MODULE_LASTCHANGE = "2024-09-12T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240912;
export const MODULE_VERSION = "8.0.20240912";

// [PrintTSTypeDefCode]
// [PrintTSEnumDefCode]
export enum AsnLoginV2SupportedAuthMethod {
	/** do not use! Only exists to indicate an unknown type from conversion */
	noneOrUnknown = 0,
	/** Server supports basic */
	basic = 1,
	/** Server supports digest */
	digest = 2,
	/** Server supports ntlm */
	ntlm = 3,
	/** Server supports kerberos */
	kerberos = 4,
	/** Server supports bearer (JWT) */
	bearer = 5,
	/** Server supports openIDC */
	openidc = 6
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnAuthBasicCredential {
	public constructor(that: AsnAuthBasicCredential) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAuthBasicCredential {
		return new AsnAuthBasicCredential({
			credential: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"credential"
		];
		return p;
	}

	public static type = "AsnAuthBasicCredential";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAuthBasicCredential",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "credential" }),
				new asn1ts.Extension()
			]
		});
	}

	/** base64(username+\":\"+password) username and password in utf8! */
	public credential!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnAuthNTLMCredential {
	public constructor(that: AsnAuthNTLMCredential) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAuthNTLMCredential {
		return new AsnAuthNTLMCredential({
			authdata: new Uint8Array(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"authdata"
		];
		return p;
	}

	public static type = "AsnAuthNTLMCredential";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAuthNTLMCredential",
			...params,
			value: [
				new asn1ts.OctetString({ name: "authdata" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Request payload for the NTLM authentication. Containing NTLM Type 1 oder Type 3 message */
	public authdata!: Uint8Array;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnAuthKerberosCredential {
	public constructor(that: AsnAuthKerberosCredential) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAuthKerberosCredential {
		return new AsnAuthKerberosCredential({
			authdata: new Uint8Array(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"authdata"
		];
		return p;
	}

	public static type = "AsnAuthKerberosCredential";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAuthKerberosCredential",
			...params,
			value: [
				new asn1ts.OctetString({ name: "authdata" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Request payload for the AsnAuthKerberosCredential */
	public authdata!: Uint8Array;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * The information for a bearer auth request
 *
 * @added 12.09.2024
 */
export class AsnAuthBearer {
	public constructor(that: AsnAuthBearer) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAuthBearer {
		return new AsnAuthBearer({
			u8sJWT: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sJWT"
		];
		return p;
	}

	public static type = "AsnAuthBearer";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAuthBearer",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sJWT" }),
				new asn1ts.Extension()
			]
		});
	}

	/** The JWT payload */
	public u8sJWT!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * The information for an openidc auth request
 *
 * @added 12.09.2024
 */
export class AsnAuthOpenIDC {
	public constructor(that?: AsnAuthOpenIDC) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAuthOpenIDC {
		return new AsnAuthOpenIDC();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"u8sScope",
				"u8sIDToken"
			);
		}
		return p;
	}

	public static type = "AsnAuthOpenIDC";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAuthOpenIDC",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sScope", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sIDToken", idBlock: { optionalID: 1 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** This is send when we want to get a redirect link */
	public u8sScope?: string;
	/** This is send when we got a token from the redirect */
	public u8sIDToken?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Authentication method negotiation - parameters\/challenge for digest authentication
 */
export class AsnAuthDigestParams {
	public constructor(that: AsnAuthDigestParams) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnAuthDigestParams {
		return new AsnAuthDigestParams({
			nonce: "",
			opaque: "",
			qop: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"nonce",
			"opaque",
			"qop"
		];
		if (bIncludeOptionals) {
			p.push(
				"algorithm",
				"realm"
			);
		}
		return p;
	}

	public static type = "AsnAuthDigestParams";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnAuthDigestParams",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "nonce" }),
				new asn1ts.Utf8String({ name: "opaque" }),
				new asn1ts.Utf8String({ name: "qop" }),
				new asn1ts.Utf8String({ name: "algorithm", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "realm", idBlock: { optionalID: 1 } }),
				new asn1ts.Extension()
			]
		});
	}

	public nonce!: string;
	/** base64 or hex */
	public opaque!: string;
	public qop!: string;
	public algorithm?: string;
	public realm?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnLoginV2Token {
	public constructor(that?: AsnLoginV2Token) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2Token {
		return new AsnLoginV2Token();
	}

	public static type = "AsnLoginV2Token";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnLoginV2Token",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sJwt", idBlock: { optionalID: 0 } }),
				new asn1ts.Utf8String({ name: "u8sToken", idBlock: { optionalID: 1 } })
			]
		});
	}

	public u8sJwt?: string;
	public u8sToken?: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Return value when redirecting to another Server (i.e. another UCServer is responsible for these credentials)
 */
export class AsnLoginV2ResultServerRedirect {
	public constructor(that: AsnLoginV2ResultServerRedirect) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2ResultServerRedirect {
		return new AsnLoginV2ResultServerRedirect({
			u8sRedirectTo: ""
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"u8sRedirectTo"
		];
		return p;
	}

	public static type = "AsnLoginV2ResultServerRedirect";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLoginV2ResultServerRedirect",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sRedirectTo" }),
				new asn1ts.Extension()
			]
		});
	}

	/** the new target server to connect to */
	public u8sRedirectTo!: string;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Return value when the UCServer currently does not process login requests on this connection
 */
export class AsnLoginV2ResultServerBusy {
	public constructor(that: AsnLoginV2ResultServerBusy) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2ResultServerBusy {
		return new AsnLoginV2ResultServerBusy({
			iRetryInSeconds: 0
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"iRetryInSeconds"
		];
		return p;
	}

	public static type = "AsnLoginV2ResultServerBusy";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLoginV2ResultServerBusy",
			...params,
			value: [
				new asn1ts.Integer({ name: "iRetryInSeconds" }),
				new asn1ts.Extension()
			]
		});
	}

	public iRetryInSeconds!: number;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
export class AsnLoginV2ResultRenegotiateNTLM {
	public constructor(that: AsnLoginV2ResultRenegotiateNTLM) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2ResultRenegotiateNTLM {
		return new AsnLoginV2ResultRenegotiateNTLM({
			authdata: new Uint8Array(0)
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"authdata"
		];
		return p;
	}

	public static type = "AsnLoginV2ResultRenegotiateNTLM";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLoginV2ResultRenegotiateNTLM",
			...params,
			value: [
				new asn1ts.OctetString({ name: "authdata" }),
				new asn1ts.Extension()
			]
		});
	}

	/** Response payload for the NTLM authentication. Contains NTLM Type 2 message */
	public authdata!: Uint8Array;
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnLoginV2ChoiceArgument {
	public constructor(that?: AsnLoginV2ChoiceArgument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2ChoiceArgument {
		return new AsnLoginV2ChoiceArgument();
	}

	public static type = "AsnLoginV2ChoiceArgument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnLoginV2ChoiceArgument",
			...params,
			value: [
				AsnAuthBasicCredential.getASN1Schema({ name: "authBasic", idBlock: { optionalID: 0 } }),
				AsnAuthNTLMCredential.getASN1Schema({ name: "authNTLM", idBlock: { optionalID: 2 } }),
				AsnAuthKerberosCredential.getASN1Schema({ name: "authKerberos", idBlock: { optionalID: 3 } }),
				AsnAuthBearer.getASN1Schema({ name: "authBearer", idBlock: { optionalID: 4 } }),
				AsnAuthOpenIDC.getASN1Schema({ name: "authOpenIDC", idBlock: { optionalID: 5 } })
			]
		});
	}

	public authBasic?: AsnAuthBasicCredential;
	public authNTLM?: AsnAuthNTLMCredential;
	public authKerberos?: AsnAuthKerberosCredential;
	public authBearer?: AsnAuthBearer;
	public authOpenIDC?: AsnAuthOpenIDC;
}

// [PrintTSTypeDefCode]
// [PrintTSSetOfDefCode]
// [PrintTSListClass]
export class AsnLoginV2SupportedAuthMethods extends Array<AsnLoginV2SupportedAuthMethod> {
	public static getASN1Schema(params?: asn1ts.SequenceOfParams): asn1ts.SequenceOf {
		return new asn1ts.SequenceOf({
			...params,
			value: new asn1ts.Enumerated()
		});
	}
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Authentication method negotiation - ordered list of available auth methods and parameters to these auth methods
 */
export class AsnLoginV2ResultSupportedAuthMethods {
	public constructor(that: AsnLoginV2ResultSupportedAuthMethods) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2ResultSupportedAuthMethods {
		return new AsnLoginV2ResultSupportedAuthMethods({
			authMethodsOrdered: new AsnLoginV2SupportedAuthMethods()
		});
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p = [
			"authMethodsOrdered"
		];
		if (bIncludeOptionals)
			p.push("authDigest");
		return p;
	}

	public static type = "AsnLoginV2ResultSupportedAuthMethods";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLoginV2ResultSupportedAuthMethods",
			...params,
			value: [
				AsnLoginV2SupportedAuthMethods.getASN1Schema({ name: "authMethodsOrdered" }),
				AsnAuthDigestParams.getASN1Schema({ name: "authDigest", idBlock: { optionalID: 0 } }),
				new asn1ts.Extension()
			]
		});
	}

	/** ordered list, defines the order in which the client shall use the auth methods */
	public authMethodsOrdered!: AsnLoginV2SupportedAuthMethods;
	/** Server supports digest (object contains digest parameters) */
	public authDigest?: AsnAuthDigestParams;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * Return value for a successful login
 */
export class AsnLoginV2ResultSuccess {
	public constructor(that?: AsnLoginV2ResultSuccess) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2ResultSuccess {
		return new AsnLoginV2ResultSuccess();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals) {
			p.push(
				"u8sLoggedInUser",
				"token"
			);
		}
		return p;
	}

	public static type = "AsnLoginV2ResultSuccess";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLoginV2ResultSuccess",
			...params,
			value: [
				new asn1ts.Utf8String({ name: "u8sLoggedInUser", idBlock: { optionalID: 0 } }),
				AsnLoginV2Token.getASN1Schema({ name: "token", idBlock: { optionalID: 1 } }),
				new asn1ts.Extension()
			]
		});
	}

	public u8sLoggedInUser?: string;
	public token?: AsnLoginV2Token;
}

// [PrintTSTypeDefCode]
// [PrintTSSeqDefCode]
/**
 * This type is used as parameter for the asn**Login methods
 */
export class AsnLoginV2Argument {
	public constructor(that?: AsnLoginV2Argument) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2Argument {
		return new AsnLoginV2Argument();
	}

	public static getOwnPropertyNames(bIncludeOptionals: boolean = true): string[] {
		const p: string[] = [];
		if (bIncludeOptionals)
			p.push("auth");
		return p;
	}

	public static type = "AsnLoginV2Argument";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Sequence {
		return new asn1ts.Sequence({
			name: "AsnLoginV2Argument",
			...params,
			value: [
				AsnLoginV2ChoiceArgument.getASN1Schema({ name: "auth", idBlock: { optionalID: 0 } }),
				new asn1ts.Extension()
			]
		});
	}

	/**
	 * wenn nicht vorhanden,. schickt der server eine Antwort mit den unterstützen Methoden
	 * wenn vorhanden, wird die entsprechende Authentisierung durchgeführt
	 */
	public auth?: AsnLoginV2ChoiceArgument;
}

// [PrintTSTypeDefCode]
// [PrintTSChoiceDefCode]
export class AsnLoginV2Result {
	public constructor(that?: AsnLoginV2Result) {
		Object.assign(this, that);
	}

	private static initEmpty(): AsnLoginV2Result {
		return new AsnLoginV2Result();
	}

	public static type = "AsnLoginV2Result";

	public static getASN1Schema(params?: asn1ts.ConstructedParams): asn1ts.Choice {
		return new asn1ts.Choice({
			name: "AsnLoginV2Result",
			...params,
			value: [
				AsnLoginV2ResultSupportedAuthMethods.getASN1Schema({ name: "supportedAuthMethods", idBlock: { optionalID: 0 } }),
				AsnLoginV2ResultSuccess.getASN1Schema({ name: "succceeded", idBlock: { optionalID: 1 } }),
				AsnLoginV2ResultServerRedirect.getASN1Schema({ name: "serverRedirect", idBlock: { optionalID: 2 } }),
				AsnLoginV2ResultServerBusy.getASN1Schema({ name: "serverBusy", idBlock: { optionalID: 3 } }),
				AsnLoginV2ResultRenegotiateNTLM.getASN1Schema({ name: "ntlmRenegotiate", idBlock: { optionalID: 4 } })
			]
		});
	}

	public supportedAuthMethods?: AsnLoginV2ResultSupportedAuthMethods;
	public succceeded?: AsnLoginV2ResultSuccess;
	public serverRedirect?: AsnLoginV2ResultServerRedirect;
	public serverBusy?: AsnLoginV2ResultServerBusy;
	public ntlmRenegotiate?: AsnLoginV2ResultRenegotiateNTLM;
}
