// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_BinaryTransfer_Converter.ts
 * "UC-Server-Access-Protocol-BinaryTransfer" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_BinaryTransfer from "./ENetUC_BinaryTransfer";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_BinaryTransfer_Converter";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferSettings_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferSettings");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferSettings";
		TSConverter.fillJSONParam(s, t, "eServiceType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		const _u8sNotAllowedExtensions = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sNotAllowedExtensions, errors, newContext, "u8sNotAllowedExtensions");
		if (_u8sNotAllowedExtensions)
			t.u8sNotAllowedExtensions = _u8sNotAllowedExtensions;
		TSConverter.fillJSONParam(s, t, "iMaxChunkSizeDownload", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxChunkSizeUpload", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxPreviewSize", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxPreviewDimension", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxFileSizeMB", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnBinaryTransferSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferSettings");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eServiceType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			const _u8snotallowedextensions = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sNotAllowedExtensions, errors, newContext, "u8sNotAllowedExtensions", false);
			if (_u8snotallowedextensions)
				t.u8sNotAllowedExtensions = _u8snotallowedextensions;
			TSConverter.fillJSONParam(s, t, "iMaxChunkSizeDownload", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxChunkSizeUpload", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxPreviewSize", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxPreviewDimension", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxFileSizeMB", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eServiceType", "number", errors, newContext);
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		const _u8sNotAllowedExtensions = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sNotAllowedExtensions, errors, newContext, "u8sNotAllowedExtensions");
		TSConverter.validateParam(s, "iMaxChunkSizeDownload", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxChunkSizeUpload", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxPreviewSize", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxPreviewDimension", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxFileSizeMB", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.eServiceType, name: "eServiceType" }));
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			if (_u8sNotAllowedExtensions)
				t.push(_u8sNotAllowedExtensions);
			t.push(new asn1ts.Integer({ value: s.iMaxChunkSizeDownload, name: "iMaxChunkSizeDownload" }));
			t.push(new asn1ts.Integer({ value: s.iMaxChunkSizeUpload, name: "iMaxChunkSizeUpload" }));
			t.push(new asn1ts.Integer({ value: s.iMaxPreviewSize, name: "iMaxPreviewSize" }));
			t.push(new asn1ts.Integer({ value: s.iMaxPreviewDimension, name: "iMaxPreviewDimension" }));
			t.push(new asn1ts.Integer({ value: s.iMaxFileSizeMB, name: "iMaxFileSizeMB" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferSettings");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eServiceType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			const _u8snotallowedextensions = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sNotAllowedExtensions"), errors, newContext, "u8sNotAllowedExtensions");
			if (_u8snotallowedextensions)
				t.u8sNotAllowedExtensions = _u8snotallowedextensions;
			TSConverter.fillASN1Param(s, t, "iMaxChunkSizeDownload", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxChunkSizeUpload", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxPreviewSize", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxPreviewDimension", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxFileSizeMB", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferStorageSettings_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferStorageSettings");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferStorageSettings";
		TSConverter.fillJSONParam(s, t, "eStorageType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxFileSizeMB", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxStorageSizeMB", "number", errors, newContext);
		const _u8sAllowedMimeTypes = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sAllowedMimeTypes, errors, newContext, "u8sAllowedMimeTypes");
		if (_u8sAllowedMimeTypes)
			t.u8sAllowedMimeTypes = _u8sAllowedMimeTypes;
		const _u8sNotAllowedExtensions = ENetUC_Common_Converter.UTF8StringList_Converter.toJSON(s.u8sNotAllowedExtensions, errors, newContext, "u8sNotAllowedExtensions");
		if (_u8sNotAllowedExtensions)
			t.u8sNotAllowedExtensions = _u8sNotAllowedExtensions;
		TSConverter.fillJSONParam(s, t, "u8sRootFolder", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iMaxFileAgeDays", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bRemoveOutdatedFilesEnabled", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettings"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferStorageSettings");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eStorageType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bEnabled", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxFileSizeMB", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxStorageSizeMB", "number", errors, newContext, false);
			const _u8sallowedmimetypes = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sAllowedMimeTypes, errors, newContext, "u8sAllowedMimeTypes", false);
			if (_u8sallowedmimetypes)
				t.u8sAllowedMimeTypes = _u8sallowedmimetypes;
			const _u8snotallowedextensions = ENetUC_Common_Converter.UTF8StringList_Converter.fromJSON(s.u8sNotAllowedExtensions, errors, newContext, "u8sNotAllowedExtensions", false);
			if (_u8snotallowedextensions)
				t.u8sNotAllowedExtensions = _u8snotallowedextensions;
			TSConverter.fillJSONParam(s, t, "u8sRootFolder", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iMaxFileAgeDays", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bRemoveOutdatedFilesEnabled", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettings"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferStorageSettings";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferStorageSettings");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eStorageType", "number", errors, newContext);
		TSConverter.validateParam(s, "bEnabled", "boolean", errors, newContext);
		TSConverter.validateParam(s, "iMaxFileSizeMB", "number", errors, newContext);
		TSConverter.validateParam(s, "iMaxStorageSizeMB", "number", errors, newContext);
		const _u8sAllowedMimeTypes = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sAllowedMimeTypes, errors, newContext, "u8sAllowedMimeTypes");
		const _u8sNotAllowedExtensions = ENetUC_Common_Converter.UTF8StringList_Converter.toBER(s.u8sNotAllowedExtensions, errors, newContext, "u8sNotAllowedExtensions");
		TSConverter.validateParam(s, "u8sRootFolder", "string", errors, newContext);
		TSConverter.validateParam(s, "iMaxFileAgeDays", "number", errors, newContext);
		TSConverter.validateParam(s, "bRemoveOutdatedFilesEnabled", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.eStorageType, name: "eStorageType" }));
			t.push(new asn1ts.Boolean({ value: s.bEnabled, name: "bEnabled" }));
			t.push(new asn1ts.Integer({ value: s.iMaxFileSizeMB, name: "iMaxFileSizeMB" }));
			t.push(new asn1ts.Integer({ value: s.iMaxStorageSizeMB, name: "iMaxStorageSizeMB" }));
			if (_u8sAllowedMimeTypes)
				t.push(_u8sAllowedMimeTypes);
			if (_u8sNotAllowedExtensions)
				t.push(_u8sNotAllowedExtensions);
			t.push(new asn1ts.Utf8String({ value: s.u8sRootFolder, name: "u8sRootFolder" }));
			t.push(new asn1ts.Integer({ value: s.iMaxFileAgeDays, name: "iMaxFileAgeDays" }));
			t.push(new asn1ts.Boolean({ value: s.bRemoveOutdatedFilesEnabled, name: "bRemoveOutdatedFilesEnabled" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettings"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferStorageSettings");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettings["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eStorageType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bEnabled", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxFileSizeMB", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxStorageSizeMB", "Integer", errors, newContext);
			const _u8sallowedmimetypes = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sAllowedMimeTypes"), errors, newContext, "u8sAllowedMimeTypes");
			if (_u8sallowedmimetypes)
				t.u8sAllowedMimeTypes = _u8sallowedmimetypes;
			const _u8snotallowedextensions = ENetUC_Common_Converter.UTF8StringList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sNotAllowedExtensions"), errors, newContext, "u8sNotAllowedExtensions");
			if (_u8snotallowedextensions)
				t.u8sNotAllowedExtensions = _u8snotallowedextensions;
			TSConverter.fillASN1Param(s, t, "u8sRootFolder", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iMaxFileAgeDays", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bRemoveOutdatedFilesEnabled", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettings"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferMetaData_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferMetaData, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferMetaData & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferMetaData");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferMetaData & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferMetaData";
		TSConverter.fillJSONParam(s, t, "u8sFileNameWithExtension", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sMimeType", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iDataSize", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sChecksum", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "iMediaDuration", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "eMetaDataType", "number", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "osMetaData", "Uint8Array", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sDescriptionText", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sBinaryTransferID", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaData"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferMetaData | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferMetaData");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferMetaData | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferMetaData>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferMetaData["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sFileNameWithExtension", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sMimeType", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iDataSize", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sChecksum", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "iMediaDuration", "number", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "eMetaDataType", "number", errors, newContext, true);
			if (TSConverter.validateParam(s, "osMetaData", "string", errors, newContext, true) && s.osMetaData)
				t.osMetaData = TSConverter.decode64(s.osMetaData as unknown as string);
			TSConverter.fillJSONParam(s, t, "u8sDescriptionText", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sBinaryTransferID", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaData"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferMetaData | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferMetaData";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferMetaData");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sFileNameWithExtension", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sMimeType", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iDataSize", "number", errors, newContext, true);
		TSConverter.validateParam(s, "u8sChecksum", "string", errors, newContext, true);
		TSConverter.validateParam(s, "iMediaDuration", "number", errors, newContext, true);
		TSConverter.validateParam(s, "eMetaDataType", "number", errors, newContext, true);
		TSConverter.validateParam(s, "osMetaData", "Uint8Array", errors, newContext, true);
		TSConverter.validateParam(s, "u8sDescriptionText", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sBinaryTransferID", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (s.u8sFileNameWithExtension !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sFileNameWithExtension, name: "u8sFileNameWithExtension", idBlock: { optionalID: 0 } }));
			if (s.u8sMimeType !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sMimeType, name: "u8sMimeType", idBlock: { optionalID: 1 } }));
			if (s.iDataSize !== undefined)
				t.push(new asn1ts.Integer({ value: s.iDataSize, name: "iDataSize", idBlock: { optionalID: 2 } }));
			if (s.u8sChecksum !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sChecksum, name: "u8sChecksum", idBlock: { optionalID: 3 } }));
			if (s.iMediaDuration !== undefined)
				t.push(new asn1ts.Integer({ value: s.iMediaDuration, name: "iMediaDuration", idBlock: { optionalID: 4 } }));
			if (s.eMetaDataType !== undefined)
				t.push(new asn1ts.Integer({ value: s.eMetaDataType, name: "eMetaDataType", idBlock: { optionalID: 5 } }));
			if (s.osMetaData !== undefined)
				t.push(new asn1ts.OctetString({ valueHex: s.osMetaData, name: "osMetaData", idBlock: { optionalID: 6 } }));
			if (s.u8sDescriptionText !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sDescriptionText, name: "u8sDescriptionText", idBlock: { optionalID: 7 } }));
			if (s.u8sBinaryTransferID !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sBinaryTransferID, name: "u8sBinaryTransferID", idBlock: { optionalID: 8 } }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaData"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferMetaData | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferMetaData");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferMetaData | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferMetaData.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferMetaData["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sFileNameWithExtension", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sMimeType", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iDataSize", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sChecksum", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "iMediaDuration", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "eMetaDataType", "Integer", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "osMetaData", "OctetString", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sDescriptionText", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sBinaryTransferID", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaData"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetBinaryTransferSettingsArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferSettingsArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetBinaryTransferSettingsArgument";

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferSettingsArgument");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetBinaryTransferSettingsArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferSettingsArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferSettingsArgument");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnInitBinaryTransferUploadResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferUploadResult");

		const t = {} as ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnInitBinaryTransferUploadResult";
		TSConverter.fillJSONParam(s, t, "eTargetType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		if (s.u8sTargetServiceDetails) {
			const _u8sTargetServiceDetails = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.u8sTargetServiceDetails, errors, newContext, "u8sTargetServiceDetails");
			if (_u8sTargetServiceDetails)
				t.u8sTargetServiceDetails = _u8sTargetServiceDetails;
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferUploadResult");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eTargetType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			const _u8stargetservicedetails = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.u8sTargetServiceDetails, errors, newContext, "u8sTargetServiceDetails", true);
			if (_u8stargetservicedetails)
				t.u8sTargetServiceDetails = _u8stargetservicedetails;
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnInitBinaryTransferUploadResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferUploadResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eTargetType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		const _u8sTargetServiceDetails = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.u8sTargetServiceDetails, errors, newContext, "u8sTargetServiceDetails", 0);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.eTargetType, name: "eTargetType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			if (_u8sTargetServiceDetails)
				t.push(_u8sTargetServiceDetails);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferUploadResult");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eTargetType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			t.u8sTargetServiceDetails = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sTargetServiceDetails"), errors, newContext, "u8sTargetServiceDetails", true);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSendBinaryChunkArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSendBinaryChunkArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSendBinaryChunkArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDataOffset", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "osChunkData", "Uint8Array", errors, newContext);

		if (errors.validateResult(newContext, "AsnSendBinaryChunkArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSendBinaryChunkArgument");

		let t: ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDataOffset", "number", errors, newContext, false);
			if (TSConverter.validateParam(s, "osChunkData", "string", errors, newContext, false))
				t.osChunkData = TSConverter.decode64(s.osChunkData as unknown as string);
		}

		if (errors.validateResult(newContext, "AsnSendBinaryChunkArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSendBinaryChunkArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSendBinaryChunkArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "iDataOffset", "number", errors, newContext);
		TSConverter.validateParam(s, "osChunkData", "Uint8Array", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			t.push(new asn1ts.Integer({ value: s.iDataOffset, name: "iDataOffset" }));
			t.push(new asn1ts.OctetString({ valueHex: s.osChunkData, name: "osChunkData" }));
		}

		if (errors.validateResult(newContext, "AsnSendBinaryChunkArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSendBinaryChunkArgument");

		let t: ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnSendBinaryChunkArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDataOffset", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "osChunkData", "OctetString", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnSendBinaryChunkArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnSendBinaryChunkResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnSendBinaryChunkResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnSendBinaryChunkResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSendBinaryChunkResult");

		const t = {} as ENetUC_BinaryTransfer.AsnSendBinaryChunkResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnSendBinaryChunkResult";
		TSConverter.fillJSONParam(s, t, "iNewPosition", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnSendBinaryChunkResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnSendBinaryChunkResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSendBinaryChunkResult");

		let t: ENetUC_BinaryTransfer.AsnSendBinaryChunkResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnSendBinaryChunkResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnSendBinaryChunkResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "iNewPosition", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnSendBinaryChunkResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnSendBinaryChunkResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnSendBinaryChunkResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnSendBinaryChunkResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "iNewPosition", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.iNewPosition, name: "iNewPosition" }));
		}

		if (errors.validateResult(newContext, "AsnSendBinaryChunkResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnSendBinaryChunkResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnSendBinaryChunkResult");

		let t: ENetUC_BinaryTransfer.AsnSendBinaryChunkResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnSendBinaryChunkResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnSendBinaryChunkResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "iNewPosition", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnSendBinaryChunkResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferUploadCompletedArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferUploadCompletedArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferUploadCompletedArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bUploadCompleted", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8s3rdPartyFileReference", "string", errors, newContext, true);
		TSConverter.fillJSONParam(s, t, "u8sUploadError", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferUploadCompletedArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bUploadCompleted", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8s3rdPartyFileReference", "string", errors, newContext, true);
			TSConverter.fillJSONParam(s, t, "u8sUploadError", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferUploadCompletedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferUploadCompletedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "bUploadCompleted", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8s3rdPartyFileReference", "string", errors, newContext, true);
		TSConverter.validateParam(s, "u8sUploadError", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			t.push(new asn1ts.Boolean({ value: s.bUploadCompleted, name: "bUploadCompleted" }));
			if (s.u8s3rdPartyFileReference !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8s3rdPartyFileReference, name: "u8s3rdPartyFileReference", idBlock: { optionalID: 0 } }));
			if (s.u8sUploadError !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sUploadError, name: "u8sUploadError", idBlock: { optionalID: 1 } }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferUploadCompletedArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bUploadCompleted", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8s3rdPartyFileReference", "Utf8String", errors, newContext, true);
			TSConverter.fillASN1Param(s, t, "u8sUploadError", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferUploadCompletedResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferUploadCompletedResult");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferUploadCompletedResult";

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferUploadCompletedResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferUploadCompletedResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferUploadCompletedResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferUploadCompletedResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferUploadCompletedResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferUploadCompletedResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnInitBinaryTransferDownloadArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferDownloadArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnInitBinaryTransferDownloadArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bProvideMetaData", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferDownloadArgument");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bProvideMetaData", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnInitBinaryTransferDownloadArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferDownloadArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "bProvideMetaData", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			t.push(new asn1ts.Boolean({ value: s.bProvideMetaData, name: "bProvideMetaData" }));
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferDownloadArgument");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bProvideMetaData", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnReceiveBinaryChunkArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnReceiveBinaryChunkArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnReceiveBinaryChunkArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iDataOffset", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iChunkSize", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnReceiveBinaryChunkArgument");

		let t: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iDataOffset", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iChunkSize", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnReceiveBinaryChunkArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnReceiveBinaryChunkArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "iDataOffset", "number", errors, newContext);
		TSConverter.validateParam(s, "iChunkSize", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			t.push(new asn1ts.Integer({ value: s.iDataOffset, name: "iDataOffset" }));
			t.push(new asn1ts.Integer({ value: s.iChunkSize, name: "iChunkSize" }));
		}

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnReceiveBinaryChunkArgument");

		let t: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnReceiveBinaryChunkArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iDataOffset", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iChunkSize", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnReceiveBinaryChunkResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnReceiveBinaryChunkResult");

		const t = {} as ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnReceiveBinaryChunkResult";
		TSConverter.fillJSONParam(s, t, "osChunkData", "Uint8Array", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bCompleted", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnReceiveBinaryChunkResult");

		let t: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "osChunkData", "string", errors, newContext, false))
				t.osChunkData = TSConverter.decode64(s.osChunkData as unknown as string);
			TSConverter.fillJSONParam(s, t, "bCompleted", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnReceiveBinaryChunkResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnReceiveBinaryChunkResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "osChunkData", "Uint8Array", errors, newContext);
		TSConverter.validateParam(s, "bCompleted", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.OctetString({ valueHex: s.osChunkData, name: "osChunkData" }));
			t.push(new asn1ts.Boolean({ value: s.bCompleted, name: "bCompleted" }));
		}

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnReceiveBinaryChunkResult");

		let t: ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnReceiveBinaryChunkResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "osChunkData", "OctetString", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bCompleted", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnReceiveBinaryChunkResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferDownloadCompletedArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferDownloadCompletedArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferDownloadCompletedArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "bDownloadCompleted", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDownloadError", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferDownloadCompletedArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "bDownloadCompleted", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDownloadError", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferDownloadCompletedArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferDownloadCompletedArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "bDownloadCompleted", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sDownloadError", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
			t.push(new asn1ts.Boolean({ value: s.bDownloadCompleted, name: "bDownloadCompleted" }));
			if (s.u8sDownloadError !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8sDownloadError, name: "u8sDownloadError" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferDownloadCompletedArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "bDownloadCompleted", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDownloadError", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferDownloadCompletedResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferDownloadCompletedResult");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferDownloadCompletedResult";

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferDownloadCompletedResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferDownloadCompletedResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferDownloadCompletedResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferDownloadCompletedResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferDownloadCompletedResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferDownloadCompletedResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetBinaryTransferMetaDataArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferMetaDataArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetBinaryTransferMetaDataArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferMetaDataArgument");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetBinaryTransferMetaDataArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferMetaDataArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferMetaDataArgument");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferRemoveElementArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferRemoveElementArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferRemoveElementArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferRemoveElementArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferRemoveElementArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferRemoveElementArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferRemoveElementArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferRemoveElementResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferRemoveElementResult");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferRemoveElementResult";
		TSConverter.fillJSONParam(s, t, "bRemoved", "boolean", errors, newContext);

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferRemoveElementResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bRemoved", "boolean", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferRemoveElementResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferRemoveElementResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bRemoved", "boolean", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bRemoved, name: "bRemoved" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferRemoveElementResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferRemoveElementResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bRemoved", "Boolean", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferRemoveElementResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferForwardElementArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferForwardElementArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferForwardElementArgument";
		TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferForwardElementArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sTransferID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferForwardElementArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferForwardElementArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sTransferID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sTransferID, name: "u8sTransferID" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferForwardElementArgument");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sTransferID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferForwardElementResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferForwardElementResult");

		const t = {} as ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnBinaryTransferForwardElementResult";
		TSConverter.fillJSONParam(s, t, "u8sOrigTransferID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sForwardTransferID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferForwardElementResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sOrigTransferID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sForwardTransferID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferForwardElementResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferForwardElementResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sOrigTransferID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sForwardTransferID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sOrigTransferID, name: "u8sOrigTransferID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sForwardTransferID, name: "u8sForwardTransferID" }));
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferForwardElementResult");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnBinaryTransferForwardElementResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sOrigTransferID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sForwardTransferID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferForwardElementResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferSettingsList_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferSettingsList");

		const t = [] as ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnBinaryTransferSettings_Converter.toJSON(se, errors, newContext, "AsnBinaryTransferSettings");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferSettingsList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferSettingsList");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnBinaryTransferSettings_Converter.fromJSON(se, errors, newContext, "AsnBinaryTransferSettings", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferSettingsList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferSettingsList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferSettingsList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnBinaryTransferSettings_Converter.toBER(s[id], errors, newContext, "AsnBinaryTransferSettings");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnBinaryTransferSettingsList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferSettingsList");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_BinaryTransfer.AsnBinaryTransferSettingsList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnBinaryTransferSettings_Converter.fromBER(se, errors, newContext, "AsnBinaryTransferSettings", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferSettingsList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetBinaryTransferSettingsResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferSettingsResult");

		const t = {} as ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetBinaryTransferSettingsResult";
		const _asnBinaryTransferSettingsList = AsnBinaryTransferSettingsList_Converter.toJSON(s.asnBinaryTransferSettingsList, errors, newContext, "asnBinaryTransferSettingsList");
		if (_asnBinaryTransferSettingsList)
			t.asnBinaryTransferSettingsList = _asnBinaryTransferSettingsList;

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferSettingsResult");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnbinarytransfersettingslist = AsnBinaryTransferSettingsList_Converter.fromJSON(s.asnBinaryTransferSettingsList, errors, newContext, "asnBinaryTransferSettingsList", false);
			if (_asnbinarytransfersettingslist)
				t.asnBinaryTransferSettingsList = _asnbinarytransfersettingslist;
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetBinaryTransferSettingsResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferSettingsResult");

		// [Print_BER_EncoderSeqDefCode]
		const _asnBinaryTransferSettingsList = AsnBinaryTransferSettingsList_Converter.toBER(s.asnBinaryTransferSettingsList, errors, newContext, "asnBinaryTransferSettingsList");
		if (!errors.hasNewErrors()) {
			if (_asnBinaryTransferSettingsList)
				t.push(_asnBinaryTransferSettingsList);
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferSettingsResult");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferSettingsResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnbinarytransfersettingslist = AsnBinaryTransferSettingsList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnBinaryTransferSettingsList"), errors, newContext, "asnBinaryTransferSettingsList");
			if (_asnbinarytransfersettingslist)
				t.asnBinaryTransferSettingsList = _asnbinarytransfersettingslist;
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferSettingsResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnInitBinaryTransferUploadArgument_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferUploadArgument");

		const t = {} as ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnInitBinaryTransferUploadArgument";
		const _asnMetaData = AsnBinaryTransferMetaData_Converter.toJSON(s.asnMetaData, errors, newContext, "asnMetaData");
		if (_asnMetaData)
			t.asnMetaData = _asnMetaData;
		TSConverter.fillJSONParam(s, t, "eServiceType", "number", errors, newContext);

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferUploadArgument");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnmetadata = AsnBinaryTransferMetaData_Converter.fromJSON(s.asnMetaData, errors, newContext, "asnMetaData", false);
			if (_asnmetadata)
				t.asnMetaData = _asnmetadata;
			TSConverter.fillJSONParam(s, t, "eServiceType", "number", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnInitBinaryTransferUploadArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferUploadArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _asnMetaData = AsnBinaryTransferMetaData_Converter.toBER(s.asnMetaData, errors, newContext, "asnMetaData");
		TSConverter.validateParam(s, "eServiceType", "number", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_asnMetaData)
				t.push(_asnMetaData);
			t.push(new asn1ts.Integer({ value: s.eServiceType, name: "eServiceType" }));
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferUploadArgument");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferUploadArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnmetadata = AsnBinaryTransferMetaData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnMetaData"), errors, newContext, "asnMetaData");
			if (_asnmetadata)
				t.asnMetaData = _asnmetadata;
			TSConverter.fillASN1Param(s, t, "eServiceType", "Integer", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferUploadArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnInitBinaryTransferDownloadResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferDownloadResult");

		const t = {} as ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnInitBinaryTransferDownloadResult";
		TSConverter.fillJSONParam(s, t, "eSourceType", "number", errors, newContext);
		if (s.asnMetaData) {
			const _asnMetaData = AsnBinaryTransferMetaData_Converter.toJSON(s.asnMetaData, errors, newContext, "asnMetaData");
			if (_asnMetaData)
				t.asnMetaData = _asnMetaData;
		}
		if (s.u8sTargetServiceDetails) {
			const _u8sTargetServiceDetails = ENetUC_Common_Converter.AsnStringPairList_Converter.toJSON(s.u8sTargetServiceDetails, errors, newContext, "u8sTargetServiceDetails");
			if (_u8sTargetServiceDetails)
				t.u8sTargetServiceDetails = _u8sTargetServiceDetails;
		}
		TSConverter.fillJSONParam(s, t, "u8s3rdPartyFileReference", "string", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferDownloadResult");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "eSourceType", "number", errors, newContext, false);
			const _asnmetadata = AsnBinaryTransferMetaData_Converter.fromJSON(s.asnMetaData, errors, newContext, "asnMetaData", true);
			if (_asnmetadata)
				t.asnMetaData = _asnmetadata;
			const _u8stargetservicedetails = ENetUC_Common_Converter.AsnStringPairList_Converter.fromJSON(s.u8sTargetServiceDetails, errors, newContext, "u8sTargetServiceDetails", true);
			if (_u8stargetservicedetails)
				t.u8sTargetServiceDetails = _u8stargetservicedetails;
			TSConverter.fillJSONParam(s, t, "u8s3rdPartyFileReference", "string", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnInitBinaryTransferDownloadResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnInitBinaryTransferDownloadResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "eSourceType", "number", errors, newContext);
		const _asnMetaData = AsnBinaryTransferMetaData_Converter.toBER(s.asnMetaData, errors, newContext, "asnMetaData", 0);
		const _u8sTargetServiceDetails = ENetUC_Common_Converter.AsnStringPairList_Converter.toBER(s.u8sTargetServiceDetails, errors, newContext, "u8sTargetServiceDetails", 1);
		TSConverter.validateParam(s, "u8s3rdPartyFileReference", "string", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Integer({ value: s.eSourceType, name: "eSourceType" }));
			if (_asnMetaData)
				t.push(_asnMetaData);
			if (_u8sTargetServiceDetails)
				t.push(_u8sTargetServiceDetails);
			if (s.u8s3rdPartyFileReference !== undefined)
				t.push(new asn1ts.Utf8String({ value: s.u8s3rdPartyFileReference, name: "u8s3rdPartyFileReference", idBlock: { optionalID: 2 } }));
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnInitBinaryTransferDownloadResult");

		let t: ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnInitBinaryTransferDownloadResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "eSourceType", "Integer", errors, newContext);
			t.asnMetaData = AsnBinaryTransferMetaData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnMetaData"), errors, newContext, "asnMetaData", true);
			t.u8sTargetServiceDetails = ENetUC_Common_Converter.AsnStringPairList_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "u8sTargetServiceDetails"), errors, newContext, "u8sTargetServiceDetails", true);
			TSConverter.fillASN1Param(s, t, "u8s3rdPartyFileReference", "Utf8String", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnInitBinaryTransferDownloadResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnGetBinaryTransferMetaDataResult_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferMetaDataResult");

		const t = {} as ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnGetBinaryTransferMetaDataResult";
		const _asnMetaData = AsnBinaryTransferMetaData_Converter.toJSON(s.asnMetaData, errors, newContext, "asnMetaData");
		if (_asnMetaData)
			t.asnMetaData = _asnMetaData;

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferMetaDataResult");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _asnmetadata = AsnBinaryTransferMetaData_Converter.fromJSON(s.asnMetaData, errors, newContext, "asnMetaData", false);
			if (_asnmetadata)
				t.asnMetaData = _asnmetadata;
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnGetBinaryTransferMetaDataResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnGetBinaryTransferMetaDataResult");

		// [Print_BER_EncoderSeqDefCode]
		const _asnMetaData = AsnBinaryTransferMetaData_Converter.toBER(s.asnMetaData, errors, newContext, "asnMetaData");
		if (!errors.hasNewErrors()) {
			if (_asnMetaData)
				t.push(_asnMetaData);
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnGetBinaryTransferMetaDataResult");

		let t: ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_BinaryTransfer.AsnGetBinaryTransferMetaDataResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _asnmetadata = AsnBinaryTransferMetaData_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnMetaData"), errors, newContext, "asnMetaData");
			if (_asnmetadata)
				t.asnMetaData = _asnmetadata;
		}

		if (errors.validateResult(newContext, "AsnGetBinaryTransferMetaDataResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferStorageSettingsList_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferStorageSettingsList");

		const t = [] as ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnBinaryTransferStorageSettings_Converter.toJSON(se, errors, newContext, "AsnBinaryTransferStorageSettings");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettingsList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferStorageSettingsList");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnBinaryTransferStorageSettings_Converter.fromJSON(se, errors, newContext, "AsnBinaryTransferStorageSettings", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettingsList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferStorageSettingsList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferStorageSettingsList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnBinaryTransferStorageSettings_Converter.toBER(s[id], errors, newContext, "AsnBinaryTransferStorageSettings");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettingsList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferStorageSettingsList");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_BinaryTransfer.AsnBinaryTransferStorageSettingsList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnBinaryTransferStorageSettings_Converter.fromBER(se, errors, newContext, "AsnBinaryTransferStorageSettings", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferStorageSettingsList"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnBinaryTransferMetaDataList_Converter {
	public static toJSON(s: ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferMetaDataList");

		const t = [] as ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList;

		// [Print_JSON_EncoderSetOfDefCode]
		for (const id in s) {
			const se = s[id];
			if (se === undefined)
				continue;
			const val = AsnBinaryTransferMetaData_Converter.toJSON(se, errors, newContext, "AsnBinaryTransferMetaData");
			if (val)
				t.push(val);
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaDataList"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferMetaDataList");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList>(data, errors, newContext, optional);
		if (s) {
			t = new ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList();
			// [Print_JSON_DecoderSetOfDefCode]
			for (const id in s) {
				const se = s[id];
				if (se === undefined)
					continue;
				const val = AsnBinaryTransferMetaData_Converter.fromJSON(se, errors, newContext, "AsnBinaryTransferMetaData", false);
				if (val)
					t.push(val);
			}
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaDataList"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnBinaryTransferMetaDataList";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnBinaryTransferMetaDataList");

		// [Print_BER_EncoderSetOfDefCode]
		for (const id in s) {
			const val = AsnBinaryTransferMetaData_Converter.toBER(s[id], errors, newContext, "AsnBinaryTransferMetaData");
			if (val)
				t.push(val);
		}


		if (errors.validateResult(newContext, "AsnBinaryTransferMetaDataList"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnBinaryTransferMetaDataList");

		let t: ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = new ENetUC_BinaryTransfer.AsnBinaryTransferMetaDataList();
			// [Print_BER_DecoderSetOfDefCode]
			for (const se of s.valueBlock.value) {
				if (asn1ts.Sequence.typeGuard(se)) {
					const val = AsnBinaryTransferMetaData_Converter.fromBER(se, errors, newContext, "AsnBinaryTransferMetaData", optional);
					if (val)
						t.push(val);
				} else
					errors.push(new ConverterError(ConverterErrorType.PROPERTY_TYPEMISMATCH, newContext.context, "wrong type"));
			}
		}

		if (errors.validateResult(newContext, "AsnBinaryTransferMetaDataList"))
			return t;

		return undefined;
	}
}
