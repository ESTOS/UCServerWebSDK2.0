// [PrintTSROSEHeader]
/**
 * ENetUC_ClientContentROSE
 * "UC-Server-Access-Protocol-ClientContent" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
// [PrintTSROSEImports]
// Global imports
import { IENetUC_ClientContentROSE, IENetUC_ClientContentROSE_Handler } from "./ENetUC_ClientContentROSE_Interface";
import { ROSEError, ROSEInvoke, ROSEReject, ROSEResult } from "./SNACCROSE";
import { AsnInvokeProblem, AsnInvokeProblemEnum, createInvokeReject, IASN1Transport, IASN1LogData, IReceiveInvokeContext, IInvokeHandler, ELogSeverity, ROSEBase } from "./TSROSEBase";
import { ISendInvokeContextParams } from "./TSInvokeContext";
// Local imports
import * as ENetUC_ClientContent from "./ENetUC_ClientContent";
import * as Converter from "./ENetUC_ClientContent_Converter";
// [PrintTSImports]
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_ClientContentROSE";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSROSEOperationDefines]
export enum OperationIDs {
	OPID_asnGetClientContent = 1126,
	OPID_asnSubscribeClientContent = 4600,
	OPID_asnUnsubscribeClientContent = 4601,
	OPID_asnChangeClientContent = 4606,
	OPID_asnClientContentChanged = 4607,
	OPID_asnClientContentSubscribeToTags = 4608,
	OPID_asnClientContentTaggedIDsChanged = 4609,
	OPID_asnClientContentSaveTags = 4610,
	OPID_asnGetAndSubscribeAdministrativeMonitorContent = 4620,
	OPID_asnUnsubscribeAdministrativeMonitorContent = 4621,
	OPID_asnAdministrativeMonitorContentGroupAdded = 4622,
	OPID_asnAdministrativeMonitorContentGroupChanged = 4623,
	OPID_asnAdministrativeMonitorContentGroupRemoved = 4624
}

// [PrintTSROSEModuleComment]
/**
 * Client content interface (Favorite\/Monitor contacts) aka \"ClientContent\"
 * ## Module description
 * This module describes the interface for the client content, which are the contacts in the \"Favorites\" tab in the main window and the contacts in the contact monitor.
 *
 *
 * ## Client content data model
 * The client content consists of contact data (the data shown to the user, mainly AsnNetDatabaseContact objects) and the arragment of the contacts in the favorites\/monitor, the data structure.
 *
 * The data is devided in a list of contacts and a tree structure of groupclusters, groups and items.&lt;br \/&gt;
 * The root is the \"contentstruture\" which contains a list of groupclusters (AsnClientContentGroupCluster).&lt;br \/&gt;
 * Each groupcluster contains groups (AsnClientContentGroup) and each group contains items (AsnClientContentItem).&lt;br \/&gt;
 * Finally the item contains the reference to the contact data in the contactlist.
 *
 * &lt;pre&gt;
 * contactlist
 * contentstructure
 * |+- listGroupClusters
 * |   +- listGroups
 * |   |   +- listItems
 * |   |   |   +- item (== only a reference to the contact in the contactlist; normally its ENetDatabaseContactID.
 * |   |   |   +- item
 * |   |   |   +- item
 * |   |   .
 * |   .
 * .
 * &lt;\/pre&gt;
 *
 * ## How to use the API
 * This API is highly flexible - it can be used to get client content with contact data and\/or content structure and with\/without eventing for updates.
 * &lt;br \/&gt;
 * ### Synchronoously without any events:
 * Example for a new client, getting all the content (incl. photos) for the first time without any eventing. It is using asnGetClientContent, which is always sending
 * back all the contacts und structure. Onyl the pictures can be left out to save bandwidth.&lt;br \/&gt;
 *
 * UML section is not exported to this file!
 *
 * ### Asynchronously and with eventing:
 * Example for a client, getting all the content and subscribe for events using asnSubscribeClientContent.&lt;br \/&gt;
 * This Call subscribes to all Events and is asynchronous. The client content will be sent from the server by the change event asnClientContentChanged.
 * The event will then always occure if there are changes to the client content data or structure. What has changed is described in asnClientContentChanged.
 *
 * UML section is not exported to this file!
 *
 * ### Subscibe for events with differential update:
 * If a client has already a cached version of the client content, it can request a differential update from the server by sending his last known revision.
 * The resulting event contains only the changed entries (see AsnClientContentChangedArgument for Details) and the client has to update its state\/cache accordingly.&lt;br \/&gt;
 *
 * UML section is not exported to this file!
 *
 * &lt;br \/&gt;
 * The synchronous and asynchronous can be used together, e.g. if it makes sense to fetch the complete content at first and then subscribe to the events later on.&lt;br \/&gt;
 *
 * #### Remarks:
 * \"Changecounter\" or \"Revision\" of the client content, a 64 Bit Integer.
 *
 * ** For historical reasons the same data ist stored sometimes in strings \"u8sContentRevision\" or \"u8sRevision\" and mostly as a 64 bit integer in \"iRevision\".
 * It is the same value, just transported with a different representation.
 * ** The revision is a timestamp and will be defined by the server; the client cannot alter this value on the server directly, only by changing parts of the client content.
 * ** A new revision from the server is alwyays higher than an old one.
 *
 * Setting the iEventFlagsToSubscribe parameter to
 *
 * ** eCONTACTS will only result in contact data events
 * ** eSTRUCTURE will only result in structure events
 * ** eJPEGPHOTO will include the jpeg photos directly in the events; if not set, the contact data will only contain hash values kor the pictures and the client gan request the pictures via asnRequestContactImage if needed.
 *
 * ## Details on GroupCluster- and Group-IDs
 *
 * - GroupCluster IDs
 * - The GroupCluster ID is a normal number, starting with '100' and counting up.
 * - Reserved numbers are between 0-199:
 * - \"0\" to \"99\" -&gt; Reserved
 * - \"100\" -&gt; The favorites tab in the Windows client main window.
 * - \"101\" -&gt; First group cluster of the Windoes client which will be shown in the monitor window.
 * - \"150\" to \"199\" -&gt; Reserved for possible adminstrative purposes.
 * - \"200\" -&gt; First group the user can define by himself, so make sure new groupclusters has an id greater or euqals than that.
 * - Group IDs
 * - A Group ID is formatted like this \"g:G[number]\", but with the exception of the following reserved IDs they can be any unique string inside a group cluster.
 * It is recommended to follow the naming convention and make the IDs unique over the whole structure.
 * - Following the standard formatting of the Group ids, new ones should start at \"g:G800\" and upwards.
 * - GroupID \"g:G770\" - \"g:G778\": reserved for special groups.
 * - \"g:G770\" - Group with additional phone line items of the user; only visisble in the windows client if enabled in the client settings.
 * - \"g:G771\" - Group for the administrative \"Jeder sieht jeden im Monitor\" setting in the windows client monitor window.
 * - \"g:G772\" - Reserved.
 * - GroupID \"g:G779\" is the first freely usable group ID inside a group cluster.
 * For historical reasons the Windows client is always starting with \"g:G779\" in every group cluster, which is possible, but makes it a bit harder to distinct between the groups over the whole structure.
 *
 * ## Client Content Tagging
 * A client can \"tag\" contacts if changes on these contacts (presence, data etc.) are of special interest for the user.
 * Technically the \"tags\" are just the contact IDs in a list. The API provided here makes it possible to change the list on the UCServer and get events, if another client of the same user makes changes to the list.
 * In the Windows client it is used to inform the user of specific presence state changes of the contacts the user tagged in the UI (e.g. available again, has a call to pickup etc.).
 */

// [PrintTSROSEClass]
export class ENetUC_ClientContentROSE extends ROSEBase implements IInvokeHandler, IENetUC_ClientContentROSE {
	/**
	 * Contains the attributes that have to be filtered from logging
	 * Use logfilter property;property inside the asn1 root comments to specify this list
	 */
	public readonly logFilter: string[];

	/**
	 * The Loggers getLogData callback (used in all the log methods called in this class, add the classname to every log entry)
	 *
	 * @returns - an ILogData log data object provided additional data for all the logger calls in this class
	 */
	public getLogData(): IASN1LogData {
		return {
			className: MODULE_NAME
		};
	}

	/**
	 * Returns the operationName for an operationID
	 *
	 * @param id - the id we want to have the name for
	 * @returns - the name or undefined if not found
	 */
	public getNameForOperationID(id: OperationIDs): string | undefined {
		switch (id) {
			case OperationIDs.OPID_asnGetClientContent:
				return "asnGetClientContent";
			case OperationIDs.OPID_asnSubscribeClientContent:
				return "asnSubscribeClientContent";
			case OperationIDs.OPID_asnUnsubscribeClientContent:
				return "asnUnsubscribeClientContent";
			case OperationIDs.OPID_asnChangeClientContent:
				return "asnChangeClientContent";
			case OperationIDs.OPID_asnClientContentChanged:
				return "asnClientContentChanged";
			case OperationIDs.OPID_asnClientContentSubscribeToTags:
				return "asnClientContentSubscribeToTags";
			case OperationIDs.OPID_asnClientContentTaggedIDsChanged:
				return "asnClientContentTaggedIDsChanged";
			case OperationIDs.OPID_asnClientContentSaveTags:
				return "asnClientContentSaveTags";
			case OperationIDs.OPID_asnGetAndSubscribeAdministrativeMonitorContent:
				return "asnGetAndSubscribeAdministrativeMonitorContent";
			case OperationIDs.OPID_asnUnsubscribeAdministrativeMonitorContent:
				return "asnUnsubscribeAdministrativeMonitorContent";
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded:
				return "asnAdministrativeMonitorContentGroupAdded";
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged:
				return "asnAdministrativeMonitorContentGroupChanged";
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved:
				return "asnAdministrativeMonitorContentGroupRemoved";
			default:
				return undefined;
		}
	}

	/**
	 * Returns the operationID for an operationName
	 *
	 * @param name - the name we want to have the id for
	 * @returns - the id or undefined if not found
	 */
	public getIDForOperationName(name: string): OperationIDs | undefined {
		switch (name) {
			case "asnGetClientContent":
				return OperationIDs.OPID_asnGetClientContent;
			case "asnSubscribeClientContent":
				return OperationIDs.OPID_asnSubscribeClientContent;
			case "asnUnsubscribeClientContent":
				return OperationIDs.OPID_asnUnsubscribeClientContent;
			case "asnChangeClientContent":
				return OperationIDs.OPID_asnChangeClientContent;
			case "asnClientContentChanged":
				return OperationIDs.OPID_asnClientContentChanged;
			case "asnClientContentSubscribeToTags":
				return OperationIDs.OPID_asnClientContentSubscribeToTags;
			case "asnClientContentTaggedIDsChanged":
				return OperationIDs.OPID_asnClientContentTaggedIDsChanged;
			case "asnClientContentSaveTags":
				return OperationIDs.OPID_asnClientContentSaveTags;
			case "asnGetAndSubscribeAdministrativeMonitorContent":
				return OperationIDs.OPID_asnGetAndSubscribeAdministrativeMonitorContent;
			case "asnUnsubscribeAdministrativeMonitorContent":
				return OperationIDs.OPID_asnUnsubscribeAdministrativeMonitorContent;
			case "asnAdministrativeMonitorContentGroupAdded":
				return OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded;
			case "asnAdministrativeMonitorContentGroupChanged":
				return OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged;
			case "asnAdministrativeMonitorContentGroupRemoved":
				return OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved;
			default:
				return undefined;
		}
	}

	// [PrintTSROSEConstructor]
	/**
	 * Constructs the invoke and oninvoke object targeting all the ROSE related parts.
	 *
	 * @param transport - The transport is the connection to the other side. It takes care of delivering the invoke
	 * to us as well as to send invokes and events to the other side. It also holds the logger.
	 * @param handleEvents - Set this to true if you want to receive events or false if the stub should cached them
	 * until you call dispatchEvents();
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public constructor(transport: IASN1Transport, handleEvents: boolean, handler?: Partial<IENetUC_ClientContentROSE_Handler>) {
		super(transport, handleEvents);

		this.logFilter = [];

		if (handler)
			this.setHandler(handler);
	}

	// [PrintTSROSESetHandler]
	/**
	 * Sets the handler and registers the operations with it
	 *
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public setHandler(handler: Partial<IENetUC_ClientContentROSE_Handler>): void {
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnGetClientContent, "asnGetClientContent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnSubscribeClientContent, "asnSubscribeClientContent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnUnsubscribeClientContent, "asnUnsubscribeClientContent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnChangeClientContent, "asnChangeClientContent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientContentChanged, "asnClientContentChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientContentSubscribeToTags, "asnClientContentSubscribeToTags");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientContentTaggedIDsChanged, "asnClientContentTaggedIDsChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnClientContentSaveTags, "asnClientContentSaveTags");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnGetAndSubscribeAdministrativeMonitorContent, "asnGetAndSubscribeAdministrativeMonitorContent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnUnsubscribeAdministrativeMonitorContent, "asnUnsubscribeAdministrativeMonitorContent");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded, "asnAdministrativeMonitorContentGroupAdded");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged, "asnAdministrativeMonitorContentGroupChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved, "asnAdministrativeMonitorContentGroupRemoved");
		this.transport.registerModuleVersion("ENetUC_ClientContent", 8, 0);
	}

	// [PrintTSROSEInvokeMethods]

	// [PrintTSROSEInvokeMethod]
	/**
	 * Get the client content data and structure with a single request without any event subscriptions.
	 * For some use cases only the transfer of the client content and structure is needed. In this case one can use this request and get the content synchronously.
	 *
	 * @param argument - An AsnGetClientContentArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnGetClientContentResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnGetClientContent(argument: ENetUC_ClientContent.AsnGetClientContentArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnGetClientContentResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnGetClientContentResult, OperationIDs.OPID_asnGetClientContent, "asnGetClientContent", Converter.AsnGetClientContentArgument_Converter, Converter.AsnGetClientContentResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Subscribe to the client content of the current user.
	 * Client can get the client content asynchronously with this request and the client will be registered for change events (asnClientContentChanged) of the content.
	 *
	 * @param argument - An AsnSubscribeClientContentArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnSubscribeClientContentResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnSubscribeClientContent(argument: ENetUC_ClientContent.AsnSubscribeClientContentArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnSubscribeClientContentResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnSubscribeClientContentResult, OperationIDs.OPID_asnSubscribeClientContent, "asnSubscribeClientContent", Converter.AsnSubscribeClientContentArgument_Converter, Converter.AsnSubscribeClientContentResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Unsubscribe from the change events for the client content.
	 * Unsubscribing from the events cannot be parameterized so the call will always unregister all events.
	 *
	 * @param argument - An AsnUnsubscribeClientContentArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnUnsubscribeClientContentResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnUnsubscribeClientContent(argument: ENetUC_ClientContent.AsnUnsubscribeClientContentArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnUnsubscribeClientContentResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnUnsubscribeClientContentResult, OperationIDs.OPID_asnUnsubscribeClientContent, "asnUnsubscribeClientContent", Converter.AsnUnsubscribeClientContentArgument_Converter, Converter.AsnUnsubscribeClientContentResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Change the client content of the user.
	 * A client can use this request to change the client content. It can change the contact informations and the structure of the content.
	 *
	 * @param argument - An AsnChangeClientContentArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnChangeClientContentResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnChangeClientContent(argument: ENetUC_ClientContent.AsnChangeClientContentArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnChangeClientContentResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnChangeClientContentResult, OperationIDs.OPID_asnChangeClientContent, "asnChangeClientContent", Converter.AsnChangeClientContentArgument_Converter, Converter.AsnChangeClientContentResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Subscribe to changes of the tagging status of a contact
	 * A user can set \"tags\" on a contact, for getting notifies if the presence state of that contact is changing.
	 * This is called here \"tagging\". These tags are saved as a list on the UCServer and with this subscribtion the client will be
	 * evented if the list changes on the server.
	 *
	 * There is no dedicated unsibscribe mechanism implemented yet; the client will be automatically unsibscribed by logging of or at loosing the connection.
	 *
	 * @param argument - An AsnClientContentSubscribeToTagsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientContentSubscribeToTagsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientContentSubscribeToTags(argument: ENetUC_ClientContent.AsnClientContentSubscribeToTagsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnClientContentSubscribeToTagsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnClientContentSubscribeToTagsResult, OperationIDs.OPID_asnClientContentSubscribeToTags, "asnClientContentSubscribeToTags", Converter.AsnClientContentSubscribeToTagsArgument_Converter, Converter.AsnClientContentSubscribeToTagsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Change tags on contacts.
	 * To change the list of tagged contacts, this request will be send to the server with the new list of contact IDs.
	 * To clear the tags just send an empty list.
	 *
	 * @param argument - An AsnClientContentSaveTagsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnClientContentSaveTagsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnClientContentSaveTags(argument: ENetUC_ClientContent.AsnClientContentSaveTagsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnClientContentSaveTagsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnClientContentSaveTagsResult, OperationIDs.OPID_asnClientContentSaveTags, "asnClientContentSaveTags", Converter.AsnClientContentSaveTagsArgument_Converter, Converter.AsnClientContentSaveTagsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Client gets the contacts especial for a attendant console and can subscribe to events if the groups are changing.
	 * For fast call transfer or agent consulting it must be possible to get contact for this purpose, because that
	 * enables additional, specialized features for them in the UI for this use case.
	 *
	 * The UCServer will gather the groups and the user IDs according the configuration set by the admin.
	 *
	 * @param argument - An AsnGetAndSubscribeAdministrativeMonitorContentArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnGetAndSubscribeAdministrativeMonitorContentResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnGetAndSubscribeAdministrativeMonitorContent(argument: ENetUC_ClientContent.AsnGetAndSubscribeAdministrativeMonitorContentArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnGetAndSubscribeAdministrativeMonitorContentResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnGetAndSubscribeAdministrativeMonitorContentResult, OperationIDs.OPID_asnGetAndSubscribeAdministrativeMonitorContent, "asnGetAndSubscribeAdministrativeMonitorContent", Converter.AsnGetAndSubscribeAdministrativeMonitorContentArgument_Converter, Converter.AsnGetAndSubscribeAdministrativeMonitorContentResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Unsubscribe from events about the Administrative Monitor Content.
	 * To stop eventing of changes about the AdministrativeMonitorContent call this function.
	 *
	 * @param argument - An AsnUnsubscribeAdministrativeMonitorContentArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnUnsubscribeAdministrativeMonitorContentResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnUnsubscribeAdministrativeMonitorContent(argument: ENetUC_ClientContent.AsnUnsubscribeAdministrativeMonitorContentArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_ClientContent.AsnUnsubscribeAdministrativeMonitorContentResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_ClientContent.AsnUnsubscribeAdministrativeMonitorContentResult, OperationIDs.OPID_asnUnsubscribeAdministrativeMonitorContent, "asnUnsubscribeAdministrativeMonitorContent", Converter.AsnUnsubscribeAdministrativeMonitorContentArgument_Converter, Converter.AsnUnsubscribeAdministrativeMonitorContentResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server to the client if the client content was changed.
	 * The server send an event to all connected client for this user to update the client content if one of the clients has changed it.
	 *
	 * @param argument - An AsnClientContentChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnClientContentChanged(argument: ENetUC_ClientContent.AsnClientContentChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnClientContentChanged, "asnClientContentChanged", Converter.AsnClientContentChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from server to client if tags on contacts have changed.
	 * If another client changes the tag list, this event will be fired to all clients with the new list.
	 *
	 * @param argument - An AsnClientContentTaggedIDsChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnClientContentTaggedIDsChanged(argument: ENetUC_ClientContent.AsnClientContentTaggedIDsChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnClientContentTaggedIDsChanged, "asnClientContentTaggedIDsChanged", Converter.AsnClientContentTaggedIDsChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from server to client if a Administrative Monitor Content Groups has been added.
	 * If the administrator changed something in the configuration of the groups which are part of the administrative Groups, these changes
	 * will be provided to the clients with this event.
	 *
	 * The argument contains the AsnAdministrativeMonitorGroups if it was added.
	 *
	 * @param argument - An AsnAdministrativeMonitorContentGroupAddedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnAdministrativeMonitorContentGroupAdded(argument: ENetUC_ClientContent.AsnAdministrativeMonitorContentGroupAddedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded, "asnAdministrativeMonitorContentGroupAdded", Converter.AsnAdministrativeMonitorContentGroupAddedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from server to client if changes to the Administrative Monitor Content Groups were made.
	 * If the administrator changed something in the configuration of the groups which are part of the Administrative Groups, these changes
	 * will be provided to the clients with this event.
	 *
	 * The argument contains a AsnAdministrativeMonitorGroup if it was changed.
	 * The changed group will contain the updated list of users, so the client must probably detect if there were users added or removed.
	 *
	 * @param argument - An AsnAdministrativeMonitorContentGroupChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnAdministrativeMonitorContentGroupChanged(argument: ENetUC_ClientContent.AsnAdministrativeMonitorContentGroupChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged, "asnAdministrativeMonitorContentGroupChanged", Converter.AsnAdministrativeMonitorContentGroupChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from server to client if the Administrative Monitor Content Groups were removed.
	 * If the administrator changed something in the configuration of the groups which are part of the administrative Groups, these changes
	 * will be provided to the clients with this event.
	 *
	 * The argument contains the AsnAdministrativeMonitorGroup if it was removed.
	 *
	 * @param argument - An AsnAdministrativeMonitorContentGroupRemovedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnAdministrativeMonitorContentGroupRemoved(argument: ENetUC_ClientContent.AsnAdministrativeMonitorContentGroupRemovedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved, "asnAdministrativeMonitorContentGroupRemoved", Converter.AsnAdministrativeMonitorContentGroupRemovedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEOnInvokeswitchCase]
	/**
	 * This is the central onInvoke method that is called whenever a method of this module is called.
	 * Based on the operationID we step into the decoding of the method argument and call the method in the handler.
	 * The result is then again encoded and send to the other side.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the metho in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled, ROSEResult for the invoke result, ROSEError for an error or undefined if an event was called
	 */
	public async onInvoke(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_ClientContentROSE_Handler): Promise<ROSEReject | ROSEResult | ROSEError | undefined> {
		switch (invoke.operationID) {
			case OperationIDs.OPID_asnGetClientContent:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnGetClientContent, ENetUC_ClientContent.AsnGetClientContentArgument, Converter.AsnGetClientContentArgument_Converter, Converter.AsnGetClientContentResult_Converter, handler, handler.onInvoke_asnGetClientContent, invokeContext);
			case OperationIDs.OPID_asnSubscribeClientContent:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnSubscribeClientContent, ENetUC_ClientContent.AsnSubscribeClientContentArgument, Converter.AsnSubscribeClientContentArgument_Converter, Converter.AsnSubscribeClientContentResult_Converter, handler, handler.onInvoke_asnSubscribeClientContent, invokeContext);
			case OperationIDs.OPID_asnUnsubscribeClientContent:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnUnsubscribeClientContent, ENetUC_ClientContent.AsnUnsubscribeClientContentArgument, Converter.AsnUnsubscribeClientContentArgument_Converter, Converter.AsnUnsubscribeClientContentResult_Converter, handler, handler.onInvoke_asnUnsubscribeClientContent, invokeContext);
			case OperationIDs.OPID_asnChangeClientContent:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnChangeClientContent, ENetUC_ClientContent.AsnChangeClientContentArgument, Converter.AsnChangeClientContentArgument_Converter, Converter.AsnChangeClientContentResult_Converter, handler, handler.onInvoke_asnChangeClientContent, invokeContext);
			case OperationIDs.OPID_asnClientContentSubscribeToTags:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientContentSubscribeToTags, ENetUC_ClientContent.AsnClientContentSubscribeToTagsArgument, Converter.AsnClientContentSubscribeToTagsArgument_Converter, Converter.AsnClientContentSubscribeToTagsResult_Converter, handler, handler.onInvoke_asnClientContentSubscribeToTags, invokeContext);
			case OperationIDs.OPID_asnClientContentSaveTags:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnClientContentSaveTags, ENetUC_ClientContent.AsnClientContentSaveTagsArgument, Converter.AsnClientContentSaveTagsArgument_Converter, Converter.AsnClientContentSaveTagsResult_Converter, handler, handler.onInvoke_asnClientContentSaveTags, invokeContext);
			case OperationIDs.OPID_asnGetAndSubscribeAdministrativeMonitorContent:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnGetAndSubscribeAdministrativeMonitorContent, ENetUC_ClientContent.AsnGetAndSubscribeAdministrativeMonitorContentArgument, Converter.AsnGetAndSubscribeAdministrativeMonitorContentArgument_Converter, Converter.AsnGetAndSubscribeAdministrativeMonitorContentResult_Converter, handler, handler.onInvoke_asnGetAndSubscribeAdministrativeMonitorContent, invokeContext);
			case OperationIDs.OPID_asnUnsubscribeAdministrativeMonitorContent:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnUnsubscribeAdministrativeMonitorContent, ENetUC_ClientContent.AsnUnsubscribeAdministrativeMonitorContentArgument, Converter.AsnUnsubscribeAdministrativeMonitorContentArgument_Converter, Converter.AsnUnsubscribeAdministrativeMonitorContentResult_Converter, handler, handler.onInvoke_asnUnsubscribeAdministrativeMonitorContent, invokeContext);
			case OperationIDs.OPID_asnClientContentChanged:
			case OperationIDs.OPID_asnClientContentTaggedIDsChanged:
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded:
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged:
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved:
				return this.onEvent(invoke, invokeContext, handler);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_ClientContentROSE`);
		}
	}

	// [PrintTSROSEOnEventSwitchCase]
	/**
	 * This is the onEvent method that is called whenever an event is called in this module.
	 * It is called from the onInvoke in case of an event is being called.
	 * Depending on the handleEvents flag the event is either handled or cached.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the method in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled or undefined
	 */
	private async onEvent(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_ClientContentROSE_Handler): Promise<ROSEReject | undefined> {
		// If the class says do not handle events and the override flag in the invokeContext has not been set, add the event to the que, otherwise we dispatch it
		if (!this.handleEvents && !invokeContext?.handleEvent) {
			this.transport.log(ELogSeverity.debug, "Adding event to queue", "onEvent", this, { operationName: invoke.operationName, operationID: invoke.operationID });
			this.cachedEvents.push({ invoke, invokeContext, handler });
			return;
		}

		switch (invoke.operationID) {
			case OperationIDs.OPID_asnClientContentChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnClientContentChanged, ENetUC_ClientContent.AsnClientContentChangedArgument, Converter.AsnClientContentChangedArgument_Converter, handler, handler.onEvent_asnClientContentChanged, invokeContext);
			case OperationIDs.OPID_asnClientContentTaggedIDsChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnClientContentTaggedIDsChanged, ENetUC_ClientContent.AsnClientContentTaggedIDsChangedArgument, Converter.AsnClientContentTaggedIDsChangedArgument_Converter, handler, handler.onEvent_asnClientContentTaggedIDsChanged, invokeContext);
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnAdministrativeMonitorContentGroupAdded, ENetUC_ClientContent.AsnAdministrativeMonitorContentGroupAddedArgument, Converter.AsnAdministrativeMonitorContentGroupAddedArgument_Converter, handler, handler.onEvent_asnAdministrativeMonitorContentGroupAdded, invokeContext);
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnAdministrativeMonitorContentGroupChanged, ENetUC_ClientContent.AsnAdministrativeMonitorContentGroupChangedArgument, Converter.AsnAdministrativeMonitorContentGroupChangedArgument_Converter, handler, handler.onEvent_asnAdministrativeMonitorContentGroupChanged, invokeContext);
			case OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnAdministrativeMonitorContentGroupRemoved, ENetUC_ClientContent.AsnAdministrativeMonitorContentGroupRemovedArgument, Converter.AsnAdministrativeMonitorContentGroupRemovedArgument_Converter, handler, handler.onEvent_asnAdministrativeMonitorContentGroupRemoved, invokeContext);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_ClientContentROSE`);
		}
	}
}
