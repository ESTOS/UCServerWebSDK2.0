// [PrintTSConverterCode]
// [PrintTSConverterComments]
/*
 * ENetUC_Transport_Converter.ts
 * "UC-Server-Access-Protocol-Transport" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */

// [PrintTSConverterImports]
import { ConverterError, ConverterErrorType, ConverterErrors, TSConverter, IDecodeContext, IEncodeContext, INamedType } from "./TSConverterBase";
import * as ENetUC_Transport from "./ENetUC_Transport";
// [PrintTSImports]
import * as asn1ts from "@estos/asn1ts";
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Auth from "./ENetUC_Auth";
import * as ENetUC_Common_Auth from "./ENetUC_Common_Auth";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Auth_Converter from "./ENetUC_Auth_Converter";
import * as ENetUC_Common_Auth_Converter from "./ENetUC_Common_Auth_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_Transport_Converter";
export const MODULE_LASTCHANGE = "1970-01-01T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 0;
export const MODULE_VERSION = "8.0.0";

// [PrintTSEncoderDecoderCode]
export class AsnStartTLSArgument_Converter {
	public static toJSON(s: ENetUC_Transport.AsnStartTLSArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnStartTLSArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnStartTLSArgument");

		const t = {} as ENetUC_Transport.AsnStartTLSArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnStartTLSArgument";

		if (errors.validateResult(newContext, "AsnStartTLSArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnStartTLSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnStartTLSArgument");

		let t: ENetUC_Transport.AsnStartTLSArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnStartTLSArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnStartTLSArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnStartTLSArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnStartTLSArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnStartTLSArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnStartTLSArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnStartTLSArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnStartTLSArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnStartTLSArgument");

		let t: ENetUC_Transport.AsnStartTLSArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnStartTLSArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnStartTLSArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnStartTLSArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnStartTLSResult_Converter {
	public static toJSON(s: ENetUC_Transport.AsnStartTLSResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnStartTLSResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnStartTLSResult");

		const t = {} as ENetUC_Transport.AsnStartTLSResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnStartTLSResult";

		if (errors.validateResult(newContext, "AsnStartTLSResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnStartTLSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnStartTLSResult");

		let t: ENetUC_Transport.AsnStartTLSResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnStartTLSResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnStartTLSResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnStartTLSResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnStartTLSResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnStartTLSResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnStartTLSResult");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnStartTLSResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnStartTLSResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnStartTLSResult");

		let t: ENetUC_Transport.AsnStartTLSResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnStartTLSResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnStartTLSResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnStartTLSResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTransportKeepAliveArgument_Converter {
	public static toJSON(s: ENetUC_Transport.AsnTransportKeepAliveArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnTransportKeepAliveArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTransportKeepAliveArgument");

		const t = {} as ENetUC_Transport.AsnTransportKeepAliveArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTransportKeepAliveArgument";
		TSConverter.fillJSONParam(s, t, "dummy", "null", errors, newContext);

		if (errors.validateResult(newContext, "AsnTransportKeepAliveArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnTransportKeepAliveArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTransportKeepAliveArgument");

		let t: ENetUC_Transport.AsnTransportKeepAliveArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnTransportKeepAliveArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnTransportKeepAliveArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnTransportKeepAliveArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnTransportKeepAliveArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTransportKeepAliveArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTransportKeepAliveArgument");

		// [Print_BER_EncoderSeqDefCode]
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Null({ name: "dummy" }));
		}

		if (errors.validateResult(newContext, "AsnTransportKeepAliveArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnTransportKeepAliveArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTransportKeepAliveArgument");

		let t: ENetUC_Transport.AsnTransportKeepAliveArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnTransportKeepAliveArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnTransportKeepAliveArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "dummy", "Null", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTransportKeepAliveArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTokenVerifyResult_Converter {
	public static toJSON(s: ENetUC_Transport.AsnTokenVerifyResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnTokenVerifyResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTokenVerifyResult");

		const t = {} as ENetUC_Transport.AsnTokenVerifyResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTokenVerifyResult";
		TSConverter.fillJSONParam(s, t, "stValidTo", "Date", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sDNPath", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sSIPURI", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sobjectGUID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPhoneNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sPhoneSecondary", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCallRecordingNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMailboxNumber", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sHomeServer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iUserStaticRights", "number", errors, newContext);
		const _asnUserContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toJSON(s.asnUserContact, errors, newContext, "asnUserContact");
		if (_asnUserContact)
			t.asnUserContact = _asnUserContact;
		const _asnUserPropertyBag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.toJSON(s.asnUserPropertyBag, errors, newContext, "asnUserPropertyBag");
		if (_asnUserPropertyBag)
			t.asnUserPropertyBag = _asnUserPropertyBag;

		if (errors.validateResult(newContext, "AsnTokenVerifyResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnTokenVerifyResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTokenVerifyResult");

		let t: ENetUC_Transport.AsnTokenVerifyResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnTokenVerifyResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnTokenVerifyResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			if (TSConverter.validateParam(s, "stValidTo", "string", errors, newContext, false))
				t.stValidTo = new Date(s.stValidTo);
			TSConverter.fillJSONParam(s, t, "iType", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sDNPath", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sUserName", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sSIPURI", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sobjectGUID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPhoneNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sPhoneSecondary", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCallRecordingNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMailboxNumber", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sHomeServer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iUserStaticRights", "number", errors, newContext, false);
			const _asnusercontact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromJSON(s.asnUserContact, errors, newContext, "asnUserContact", false);
			if (_asnusercontact)
				t.asnUserContact = _asnusercontact;
			const _asnuserpropertybag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.fromJSON(s.asnUserPropertyBag, errors, newContext, "asnUserPropertyBag", false);
			if (_asnuserpropertybag)
				t.asnUserPropertyBag = _asnuserpropertybag;
		}

		if (errors.validateResult(newContext, "AsnTokenVerifyResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnTokenVerifyResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTokenVerifyResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTokenVerifyResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "stValidTo", "Date", errors, newContext);
		TSConverter.validateParam(s, "iType", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sDNPath", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sUserName", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sSIPURI", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sobjectGUID", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPhoneNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sPhoneSecondary", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sCallRecordingNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMailboxNumber", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sHomeServer", "string", errors, newContext);
		TSConverter.validateParam(s, "iUserStaticRights", "number", errors, newContext);
		const _asnUserContact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.toBER(s.asnUserContact, errors, newContext, "asnUserContact");
		const _asnUserPropertyBag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.toBER(s.asnUserPropertyBag, errors, newContext, "asnUserPropertyBag");
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Real({ value: TSConverter.getVariantTimeFromDateTime(s.stValidTo), name: "stValidTo" }));
			t.push(new asn1ts.Integer({ value: s.iType, name: "iType" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sDNPath, name: "u8sDNPath" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sUserName, name: "u8sUserName" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sSIPURI, name: "u8sSIPURI" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sobjectGUID, name: "u8sobjectGUID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPhoneNumber, name: "u8sPhoneNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sPhoneSecondary, name: "u8sPhoneSecondary" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCallRecordingNumber, name: "u8sCallRecordingNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMailboxNumber, name: "u8sMailboxNumber" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sHomeServer, name: "u8sHomeServer" }));
			t.push(new asn1ts.Integer({ value: s.iUserStaticRights, name: "iUserStaticRights" }));
			if (_asnUserContact)
				t.push(_asnUserContact);
			if (_asnUserPropertyBag)
				t.push(_asnUserPropertyBag);
		}

		if (errors.validateResult(newContext, "AsnTokenVerifyResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnTokenVerifyResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTokenVerifyResult");

		let t: ENetUC_Transport.AsnTokenVerifyResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnTokenVerifyResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnTokenVerifyResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "stValidTo", "AsnSystemTime", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iType", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sDNPath", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sUserName", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sSIPURI", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sobjectGUID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPhoneNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sPhoneSecondary", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCallRecordingNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMailboxNumber", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sHomeServer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iUserStaticRights", "Integer", errors, newContext);
			const _asnusercontact = ENetUC_Common_Converter.AsnNetDatabaseContact_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnUserContact"), errors, newContext, "asnUserContact");
			if (_asnusercontact)
				t.asnUserContact = _asnusercontact;
			const _asnuserpropertybag = ENetUC_Common_Converter.AsnUserPropertyBag_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "asnUserPropertyBag"), errors, newContext, "asnUserPropertyBag");
			if (_asnuserpropertybag)
				t.asnUserPropertyBag = _asnuserpropertybag;
		}

		if (errors.validateResult(newContext, "AsnTokenVerifyResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnTokenVerifyV2Argument_Converter {
	public static toJSON(s: ENetUC_Transport.AsnTokenVerifyV2Argument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnTokenVerifyV2Argument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTokenVerifyV2Argument");

		const t = {} as ENetUC_Transport.AsnTokenVerifyV2Argument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnTokenVerifyV2Argument";
		TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnTokenVerifyV2Argument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnTokenVerifyV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTokenVerifyV2Argument");

		let t: ENetUC_Transport.AsnTokenVerifyV2Argument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnTokenVerifyV2Argument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnTokenVerifyV2Argument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sToken", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnTokenVerifyV2Argument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnTokenVerifyV2Argument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnTokenVerifyV2Argument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnTokenVerifyV2Argument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sToken", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sToken, name: "u8sToken" }));
		}

		if (errors.validateResult(newContext, "AsnTokenVerifyV2Argument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnTokenVerifyV2Argument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnTokenVerifyV2Argument");

		let t: ENetUC_Transport.AsnTokenVerifyV2Argument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnTokenVerifyV2Argument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnTokenVerifyV2Argument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sToken", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnTokenVerifyV2Argument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCheckConnectionArgument_Converter {
	public static toJSON(s: ENetUC_Transport.AsnCheckConnectionArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnCheckConnectionArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCheckConnectionArgument");

		const t = {} as ENetUC_Transport.AsnCheckConnectionArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCheckConnectionArgument";

		if (errors.validateResult(newContext, "AsnCheckConnectionArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCheckConnectionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCheckConnectionArgument");

		let t: ENetUC_Transport.AsnCheckConnectionArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnCheckConnectionArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnCheckConnectionArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnCheckConnectionArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnCheckConnectionArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCheckConnectionArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCheckConnectionArgument");

		// [Print_BER_EncoderSeqDefCode]

		if (errors.validateResult(newContext, "AsnCheckConnectionArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCheckConnectionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCheckConnectionArgument");

		let t: ENetUC_Transport.AsnCheckConnectionArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnCheckConnectionArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnCheckConnectionArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
		}

		if (errors.validateResult(newContext, "AsnCheckConnectionArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCheckConnectionResult_Converter {
	public static toJSON(s: ENetUC_Transport.AsnCheckConnectionResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnCheckConnectionResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCheckConnectionResult");

		const t = {} as ENetUC_Transport.AsnCheckConnectionResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCheckConnectionResult";
		TSConverter.fillJSONParam(s, t, "u8sServerVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sProductVersion", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iProtocolVersion", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "iOEMID", "number", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sCookie", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnCheckConnectionResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCheckConnectionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCheckConnectionResult");

		let t: ENetUC_Transport.AsnCheckConnectionResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnCheckConnectionResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnCheckConnectionResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sServerVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sProductVersion", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iProtocolVersion", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "iOEMID", "number", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sCookie", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnCheckConnectionResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnCheckConnectionResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCheckConnectionResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCheckConnectionResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sServerVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sProductVersion", "string", errors, newContext);
		TSConverter.validateParam(s, "iProtocolVersion", "number", errors, newContext);
		TSConverter.validateParam(s, "iOEMID", "number", errors, newContext);
		TSConverter.validateParam(s, "u8sCookie", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sServerVersion, name: "u8sServerVersion" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sProductVersion, name: "u8sProductVersion" }));
			t.push(new asn1ts.Integer({ value: s.iProtocolVersion, name: "iProtocolVersion" }));
			t.push(new asn1ts.Integer({ value: s.iOEMID, name: "iOEMID" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sCookie, name: "u8sCookie" }));
		}

		if (errors.validateResult(newContext, "AsnCheckConnectionResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCheckConnectionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCheckConnectionResult");

		let t: ENetUC_Transport.AsnCheckConnectionResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnCheckConnectionResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnCheckConnectionResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sServerVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sProductVersion", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iProtocolVersion", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "iOEMID", "Integer", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sCookie", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnCheckConnectionResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCreateAuthTokenResult_Converter {
	public static toJSON(s: ENetUC_Transport.AsnCreateAuthTokenResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnCreateAuthTokenResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCreateAuthTokenResult");

		const t = {} as ENetUC_Transport.AsnCreateAuthTokenResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCreateAuthTokenResult";
		const _loginResult = ENetUC_Common_Auth_Converter.AsnLoginV2Result_Converter.toJSON(s.loginResult, errors, newContext, "loginResult");
		if (_loginResult)
			t.loginResult = _loginResult;
		TSConverter.fillJSONParam(s, t, "u8sAuthSessionID", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnCreateAuthTokenResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCreateAuthTokenResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCreateAuthTokenResult");

		let t: ENetUC_Transport.AsnCreateAuthTokenResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnCreateAuthTokenResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnCreateAuthTokenResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _loginresult = ENetUC_Common_Auth_Converter.AsnLoginV2Result_Converter.fromJSON(s.loginResult, errors, newContext, "loginResult", false);
			if (_loginresult)
				t.loginResult = _loginresult;
			TSConverter.fillJSONParam(s, t, "u8sAuthSessionID", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnCreateAuthTokenResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnCreateAuthTokenResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCreateAuthTokenResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCreateAuthTokenResult");

		// [Print_BER_EncoderSeqDefCode]
		const _loginResult = ENetUC_Common_Auth_Converter.AsnLoginV2Result_Converter.toBER(s.loginResult, errors, newContext, "loginResult");
		TSConverter.validateParam(s, "u8sAuthSessionID", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			if (_loginResult)
				t.push(_loginResult);
			t.push(new asn1ts.Utf8String({ value: s.u8sAuthSessionID, name: "u8sAuthSessionID" }));
		}

		if (errors.validateResult(newContext, "AsnCreateAuthTokenResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCreateAuthTokenResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCreateAuthTokenResult");

		let t: ENetUC_Transport.AsnCreateAuthTokenResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnCreateAuthTokenResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnCreateAuthTokenResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _loginresult = ENetUC_Common_Auth_Converter.AsnLoginV2Result_Converter.fromBER(s.getValueByName("loginResult"), errors, newContext, "loginResult");
			if (_loginresult)
				t.loginResult = _loginresult;
			TSConverter.fillASN1Param(s, t, "u8sAuthSessionID", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnCreateAuthTokenResult"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnCreateAuthTokenArgument_Converter {
	public static toJSON(s: ENetUC_Transport.AsnCreateAuthTokenArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnCreateAuthTokenArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCreateAuthTokenArgument");

		const t = {} as ENetUC_Transport.AsnCreateAuthTokenArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnCreateAuthTokenArgument";
		const _login = ENetUC_Common_Auth_Converter.AsnLoginV2Argument_Converter.toJSON(s.login, errors, newContext, "login");
		if (_login)
			t.login = _login;
		TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "role", "number", errors, newContext, true);

		if (errors.validateResult(newContext, "AsnCreateAuthTokenArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCreateAuthTokenArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCreateAuthTokenArgument");

		let t: ENetUC_Transport.AsnCreateAuthTokenArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnCreateAuthTokenArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnCreateAuthTokenArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			const _login = ENetUC_Common_Auth_Converter.AsnLoginV2Argument_Converter.fromJSON(s.login, errors, newContext, "login", false);
			if (_login)
				t.login = _login;
			TSConverter.fillJSONParam(s, t, "u8sUCSID", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "role", "number", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnCreateAuthTokenArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnCreateAuthTokenArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnCreateAuthTokenArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnCreateAuthTokenArgument");

		// [Print_BER_EncoderSeqDefCode]
		const _login = ENetUC_Common_Auth_Converter.AsnLoginV2Argument_Converter.toBER(s.login, errors, newContext, "login");
		TSConverter.validateParam(s, "u8sUCSID", "string", errors, newContext);
		TSConverter.validateParam(s, "role", "number", errors, newContext, true);
		if (!errors.hasNewErrors()) {
			if (_login)
				t.push(_login);
			t.push(new asn1ts.Utf8String({ value: s.u8sUCSID, name: "u8sUCSID" }));
			if (s.role !== undefined)
				t.push(new asn1ts.Enumerated({ value: s.role, name: "role", idBlock: { optionalID: 0 } }));
		}

		if (errors.validateResult(newContext, "AsnCreateAuthTokenArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnCreateAuthTokenArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnCreateAuthTokenArgument");

		let t: ENetUC_Transport.AsnCreateAuthTokenArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnCreateAuthTokenArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnCreateAuthTokenArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			const _login = ENetUC_Common_Auth_Converter.AsnLoginV2Argument_Converter.fromBER(s.getTypedValueByName(asn1ts.Sequence, "login"), errors, newContext, "login");
			if (_login)
				t.login = _login;
			TSConverter.fillASN1Param(s, t, "u8sUCSID", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "role", "Enumerated", errors, newContext, true);
		}

		if (errors.validateResult(newContext, "AsnCreateAuthTokenArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateInterfaceVersionArgument_Converter {
	public static toJSON(s: ENetUC_Transport.AsnNegotiateInterfaceVersionArgument, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnNegotiateInterfaceVersionArgument & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateInterfaceVersionArgument");

		const t = {} as ENetUC_Transport.AsnNegotiateInterfaceVersionArgument & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateInterfaceVersionArgument";
		TSConverter.fillJSONParam(s, t, "u8sMinInterfaceVer", "string", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sMaxInterfaceVer", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionArgument"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnNegotiateInterfaceVersionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateInterfaceVersionArgument");

		let t: ENetUC_Transport.AsnNegotiateInterfaceVersionArgument | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnNegotiateInterfaceVersionArgument>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnNegotiateInterfaceVersionArgument["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "u8sMinInterfaceVer", "string", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sMaxInterfaceVer", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionArgument"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnNegotiateInterfaceVersionArgument | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateInterfaceVersionArgument";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateInterfaceVersionArgument");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "u8sMinInterfaceVer", "string", errors, newContext);
		TSConverter.validateParam(s, "u8sMaxInterfaceVer", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Utf8String({ value: s.u8sMinInterfaceVer, name: "u8sMinInterfaceVer" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sMaxInterfaceVer, name: "u8sMaxInterfaceVer" }));
		}

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionArgument"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnNegotiateInterfaceVersionArgument | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateInterfaceVersionArgument");

		let t: ENetUC_Transport.AsnNegotiateInterfaceVersionArgument | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnNegotiateInterfaceVersionArgument.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnNegotiateInterfaceVersionArgument["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "u8sMinInterfaceVer", "Utf8String", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sMaxInterfaceVer", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionArgument"))
			return t;

		return undefined;
	}
}

// [PrintTSEncoderDecoderCode]
export class AsnNegotiateInterfaceVersionResult_Converter {
	public static toJSON(s: ENetUC_Transport.AsnNegotiateInterfaceVersionResult, errors?: ConverterErrors, context?: IEncodeContext, name?: string): ENetUC_Transport.AsnNegotiateInterfaceVersionResult & INamedType | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateInterfaceVersionResult");

		const t = {} as ENetUC_Transport.AsnNegotiateInterfaceVersionResult & INamedType;

		// [Print_JSON_EncoderSeqDefCode]
		if (newContext.bAddTypes)
			t._type = "AsnNegotiateInterfaceVersionResult";
		TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext);
		TSConverter.fillJSONParam(s, t, "u8sServerInterfaceVer", "string", errors, newContext);

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionResult"))
			return t;

		return undefined;
	}

	public static fromJSON(data: string | object | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnNegotiateInterfaceVersionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateInterfaceVersionResult");

		let t: ENetUC_Transport.AsnNegotiateInterfaceVersionResult | undefined;
		const s = TSConverter.prepareJSONData<ENetUC_Transport.AsnNegotiateInterfaceVersionResult>(data, errors, newContext, optional);
		if (s) {
			t = ENetUC_Transport.AsnNegotiateInterfaceVersionResult["initEmpty"].call(0);
			// [Print_JSON_DecoderSeqDefCode]
			TSConverter.fillJSONParam(s, t, "bSuccess", "boolean", errors, newContext, false);
			TSConverter.fillJSONParam(s, t, "u8sServerInterfaceVer", "string", errors, newContext, false);
		}

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionResult"))
			return t;

		return undefined;
	}

	public static toBER(s: ENetUC_Transport.AsnNegotiateInterfaceVersionResult | undefined, errors?: ConverterErrors, context?: IEncodeContext, name?: string, optional?: boolean | number): asn1ts.Sequence | undefined {
		name ||= "AsnNegotiateInterfaceVersionResult";
		if (!s) {
			TSConverter.addMissingError(errors, context, name, optional);
			return undefined;
		}

		const result = new asn1ts.Sequence(TSConverter.getASN1TSConstructorParams(name, optional));
		const t = result.valueBlock.value;
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addEncodeContext(context, name, "AsnNegotiateInterfaceVersionResult");

		// [Print_BER_EncoderSeqDefCode]
		TSConverter.validateParam(s, "bSuccess", "boolean", errors, newContext);
		TSConverter.validateParam(s, "u8sServerInterfaceVer", "string", errors, newContext);
		if (!errors.hasNewErrors()) {
			t.push(new asn1ts.Boolean({ value: s.bSuccess, name: "bSuccess" }));
			t.push(new asn1ts.Utf8String({ value: s.u8sServerInterfaceVer, name: "u8sServerInterfaceVer" }));
		}

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionResult"))
			return result;

		return undefined;
	}

	public static fromBER(data: Uint8Array | asn1ts.BaseBlock | undefined, errors?: ConverterErrors, context?: IDecodeContext, name?: string, optional?: boolean): ENetUC_Transport.AsnNegotiateInterfaceVersionResult | undefined {
		errors ||= new ConverterErrors();
		errors.storeState();
		const newContext = TSConverter.addDecodeContext(context, name, "AsnNegotiateInterfaceVersionResult");

		let t: ENetUC_Transport.AsnNegotiateInterfaceVersionResult | undefined;
		const s = TSConverter.prepareASN1BERData(ENetUC_Transport.AsnNegotiateInterfaceVersionResult.getASN1Schema, data, errors, newContext, optional);
		if (asn1ts.Sequence.typeGuard(s)) {
			t = ENetUC_Transport.AsnNegotiateInterfaceVersionResult["initEmpty"].call(0);
			// [Print_BER_DecoderSeqDefCode]
			TSConverter.fillASN1Param(s, t, "bSuccess", "Boolean", errors, newContext);
			TSConverter.fillASN1Param(s, t, "u8sServerInterfaceVer", "Utf8String", errors, newContext);
		}

		if (errors.validateResult(newContext, "AsnNegotiateInterfaceVersionResult"))
			return t;

		return undefined;
	}
}
