// [PrintTSROSEHeader]
/**
 * ENetUC_CTIROSE
 * "UC-Server-Access-Protocol-CTI" ASN.1 stubs.
 * This file was generated by estos esnacc (V6.0.19, 20.09.2024)
 * based on Coral WinSnacc written by Deepak Gupta
 * NOTE: This is a machine generated file - editing not recommended
 */

// prettier-ignore
/* eslint-disable */
// [PrintTSROSEImports]
// Global imports
import { IENetUC_CTIROSE, IENetUC_CTIROSE_Handler } from "./ENetUC_CTIROSE_Interface";
import { ROSEError, ROSEInvoke, ROSEReject, ROSEResult } from "./SNACCROSE";
import { AsnInvokeProblem, AsnInvokeProblemEnum, createInvokeReject, IASN1Transport, IASN1LogData, IReceiveInvokeContext, IInvokeHandler, ELogSeverity, ROSEBase } from "./TSROSEBase";
import { ISendInvokeContextParams } from "./TSInvokeContext";
// Local imports
import * as ENetUC_CTI from "./ENetUC_CTI";
import * as Converter from "./ENetUC_CTI_Converter";
// [PrintTSImports]
import * as ENetUC_Common from "./ENetUC_Common";
import * as ENetUC_Common_SIPCTI from "./ENetUC_Common_SIPCTI";
import * as ENetUC_Common_Converter from "./ENetUC_Common_Converter";
import * as ENetUC_Common_SIPCTI_Converter from "./ENetUC_Common_SIPCTI_Converter";
// [PrintTSRootTypes]
export const MODULE_NAME = "ENetUC_CTIROSE";
export const MODULE_LASTCHANGE = "2024-06-19T00:00:00Z";
export const MODULE_MAJOR_VERSION = 8;
export const MODULE_MINOR_VERSION = 20240619;
export const MODULE_VERSION = "8.0.20240619";

// [PrintTSROSEOperationDefines]
export enum OperationIDs {
	OPID_asnCtiEnumPhoneLines = 1260,
	OPID_asnCtiSnapshotPhoneLine = 1261,
	OPID_asnCtiLineMonitorStart = 1262,
	OPID_asnCtiLineMonitorStop = 1263,
	OPID_asnCtiLineSetDoNotDisturb = 1264,
	OPID_asnCtiLineSetRemoteOffice = 1273,
	OPID_asnCtiNotifyLineInfoChanged = 1280,
	OPID_asnCtiNotifyLineDoNotDisturbChanged = 1281,
	OPID_asnCtiNotifyLineRemoteOfficeChanged = 1292,
	OPID_asnCtiNotifyMonitorStopped = 1294,
	OPID_asnCtiNotifyLineSortOrderChanged = 1295,
	OPID_asnCtiNotifyLineForwardingChanged = 1282,
	OPID_asnCtiNotifyLineCallInformationChanged = 1283,
	OPID_asnCtiNotifyLineAddRemove = 1284,
	OPID_asnCtiNotifyMakeCallResult = 1285,
	OPID_asnCtiNotifyConferenceCreated = 1286,
	OPID_asnCtiNotifyConferenceDestroyed = 1287,
	OPID_asnCtiNotifyConferencePartyAdded = 1288,
	OPID_asnCtiNotifyConferencePartyRemoved = 1289,
	OPID_asnCtiNotifyLineCallFeaturesChanged = 1290,
	OPID_asnCtiNotifyLineProjectSettingsChanged = 1291,
	OPID_asnCtiMakeCall = 1202,
	OPID_asnCtiDropCall = 1203,
	OPID_asnCtiLineDropCall = 1224,
	OPID_asnCtiAnswerCall = 1207,
	OPID_asnCtiRedirectCall = 1208,
	OPID_asnCtiPickupCall = 1222,
	OPID_asnCtiStartCallRecording = 1230,
	OPID_asnCtiStopCallRecording = 1231,
	OPID_asnCtiSetCallData = 1225,
	OPID_asnCtiMergeCalls = 1209,
	OPID_asnCtiSwapHold = 1210,
	OPID_asnCtiHold = 1211,
	OPID_asnCtiSetForward = 1218,
	OPID_asnCtiRemoveForward = 1219,
	OPID_asnCtiDialDigits = 1221,
	OPID_asnCtiCompleteCall = 1223,
	OPID_asnCtiConference = 1250
}

// [PrintTSROSEModuleComment]
/**
 * CTI interface
 * ## CTI Modul
 *
 *
 * ## Module description
 * This module contains structures and operations for CTI (remote call control) on TAPI or Bluetooth phone lines in the server.
 *
 * A client program has access to all lines owned by the logged in user and to additional lines it has dedicated access.&lt;br \/&gt;
 * It is possible to monitor all actions on these lines and to call operations to initiate new calls, set forwards, change states and so on.
 *
 * ## Prerequisites
 * In order to use the operations described in this document you have to make sure:
 * - The server has lines configured and activated. (Install an appropriate TAPI-driver for your PBX system.)
 * - There is at least one user activated on the server, who has lines configured to use.
 * - The client program is connected to the server via UCServer Web Services using a websocket or directly to the server on the client port (default port 7222).
 * - The client program encodes the data structures as estos JSON or ASN.1 BER.
 * - The client program is logged in to the server with a user who has access to lines.
 *
 * Additional prerequisites for a operation on the PBX and or the TAPI driver may be necessary.
 *
 * ### Description of the Line-Call-Model ###
 * The remote call control and monitoring of the server is based on a line-call-model. This means, that users, lines and calls are organized in a tree like hierarchy.
 * Each node in this tree contains configuration data and dynamic data, which can be accessed and observed.
 *
 * The Nodes are:
 * - The user. This a more a kind of \"meta\" node, it just holds the list of lines, a client has access to if it is logged in as this user.
 * - The line(s). Defined with the logged in user, a client can retrieve a list of lines, the user has access to. With these lines, the client can (one time) pull information or can attach itself on to get initial data and events if these data changes over time (get-and-subscribe mechanism).
 * The line information contains configuration information and dynamic data about the lines status, including current calls.
 * **Note:** A line is identified by its URI tel:number\@pbxsystem. The parameter is often named as \"u8sLinePhoneNumber\".&lt;br \/&gt;The \"u8sPhoneNumber\" is the phone number of a line, but for technical reasons that is not a distinct property of a line. It is possible to have multiple lines with the same phone number!
 * - The call(s). A line has a list of current calls, which are currently \"on\" the line. If the client is attached to a line for events, new calls will be announced via events. Changes to these calls are also announced via events.
 * There is no need to attach to calls explicitly, this is already done by attaching to the line. Call changing events are then sent to the client too.
 * **Note:** A call is identified by its connection identifier often named as \"ConnectionID\".
 *
 * ### Remarks ###
 * Some operations return an empty result object if they are executed successfully. So in this cases, the business logic should wait for result\/error before do additional actions.
 * Phone numbers are normally used and provided in a so called supercanonic notation containing a full qualified number including country, city, main and extension number: +49815136856177
 * For operations affecting multiple calls be sure to check that all calls affected have the corresponding feature set. To merge two calls both calls have to have the feature eCFEATUREMERGECALLS set.
 *
 * ### Example: Monitoring lines ###
 * 1. Get the lines the client has access to with asnCtiEnumPhoneLines. If you wish to get events if the line list changes afterwards, set the parameter \"attachChangeNotify\" to 1.
 * 2. Use the lines URI to start monitoring for initial data and events on it. asnCtiLineMonitorStart will result in a monitor cross reference id to distinguish between events for different line monitors easier.
 * This is useful, if the client has the requirement to monitor the same line multiple times for different use cases.
 * 3. With the line URI you can call functions e.g. asnCtiMakeCall, asnCtiAnswerCall a.s.o. With the line monitoring on, you will get the according changes on the line and its calls as events back.
 * 4. To stop monitoring a line, call asnCtiLineMonitorStop with the corresponding monitor cross reference id.
 *
 * ### Example: Call data transfer ###
 *
 * ### Phone number formats ###
 * The whole system tries to use supercanonic numbers (+country city main and extension number \/ +49815136856177) whereever possible.
 * As long as the number is used in supercanonic notation all components can format the number as required (for dialing, for display, etc.)
 * You likely wonÂ´t need to format numbers as the system always provides supercanonic numbers.
 */

// [PrintTSROSEClass]
export class ENetUC_CTIROSE extends ROSEBase implements IInvokeHandler, IENetUC_CTIROSE {
	/**
	 * Contains the attributes that have to be filtered from logging
	 * Use logfilter property;property inside the asn1 root comments to specify this list
	 */
	public readonly logFilter: string[];

	/**
	 * The Loggers getLogData callback (used in all the log methods called in this class, add the classname to every log entry)
	 *
	 * @returns - an ILogData log data object provided additional data for all the logger calls in this class
	 */
	public getLogData(): IASN1LogData {
		return {
			className: MODULE_NAME
		};
	}

	/**
	 * Returns the operationName for an operationID
	 *
	 * @param id - the id we want to have the name for
	 * @returns - the name or undefined if not found
	 */
	public getNameForOperationID(id: OperationIDs): string | undefined {
		switch (id) {
			case OperationIDs.OPID_asnCtiEnumPhoneLines:
				return "asnCtiEnumPhoneLines";
			case OperationIDs.OPID_asnCtiSnapshotPhoneLine:
				return "asnCtiSnapshotPhoneLine";
			case OperationIDs.OPID_asnCtiLineMonitorStart:
				return "asnCtiLineMonitorStart";
			case OperationIDs.OPID_asnCtiLineMonitorStop:
				return "asnCtiLineMonitorStop";
			case OperationIDs.OPID_asnCtiLineSetDoNotDisturb:
				return "asnCtiLineSetDoNotDisturb";
			case OperationIDs.OPID_asnCtiLineSetRemoteOffice:
				return "asnCtiLineSetRemoteOffice";
			case OperationIDs.OPID_asnCtiNotifyLineInfoChanged:
				return "asnCtiNotifyLineInfoChanged";
			case OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged:
				return "asnCtiNotifyLineDoNotDisturbChanged";
			case OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged:
				return "asnCtiNotifyLineRemoteOfficeChanged";
			case OperationIDs.OPID_asnCtiNotifyMonitorStopped:
				return "asnCtiNotifyMonitorStopped";
			case OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged:
				return "asnCtiNotifyLineSortOrderChanged";
			case OperationIDs.OPID_asnCtiNotifyLineForwardingChanged:
				return "asnCtiNotifyLineForwardingChanged";
			case OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged:
				return "asnCtiNotifyLineCallInformationChanged";
			case OperationIDs.OPID_asnCtiNotifyLineAddRemove:
				return "asnCtiNotifyLineAddRemove";
			case OperationIDs.OPID_asnCtiNotifyMakeCallResult:
				return "asnCtiNotifyMakeCallResult";
			case OperationIDs.OPID_asnCtiNotifyConferenceCreated:
				return "asnCtiNotifyConferenceCreated";
			case OperationIDs.OPID_asnCtiNotifyConferenceDestroyed:
				return "asnCtiNotifyConferenceDestroyed";
			case OperationIDs.OPID_asnCtiNotifyConferencePartyAdded:
				return "asnCtiNotifyConferencePartyAdded";
			case OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved:
				return "asnCtiNotifyConferencePartyRemoved";
			case OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged:
				return "asnCtiNotifyLineCallFeaturesChanged";
			case OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged:
				return "asnCtiNotifyLineProjectSettingsChanged";
			case OperationIDs.OPID_asnCtiMakeCall:
				return "asnCtiMakeCall";
			case OperationIDs.OPID_asnCtiDropCall:
				return "asnCtiDropCall";
			case OperationIDs.OPID_asnCtiLineDropCall:
				return "asnCtiLineDropCall";
			case OperationIDs.OPID_asnCtiAnswerCall:
				return "asnCtiAnswerCall";
			case OperationIDs.OPID_asnCtiRedirectCall:
				return "asnCtiRedirectCall";
			case OperationIDs.OPID_asnCtiPickupCall:
				return "asnCtiPickupCall";
			case OperationIDs.OPID_asnCtiStartCallRecording:
				return "asnCtiStartCallRecording";
			case OperationIDs.OPID_asnCtiStopCallRecording:
				return "asnCtiStopCallRecording";
			case OperationIDs.OPID_asnCtiSetCallData:
				return "asnCtiSetCallData";
			case OperationIDs.OPID_asnCtiMergeCalls:
				return "asnCtiMergeCalls";
			case OperationIDs.OPID_asnCtiSwapHold:
				return "asnCtiSwapHold";
			case OperationIDs.OPID_asnCtiHold:
				return "asnCtiHold";
			case OperationIDs.OPID_asnCtiSetForward:
				return "asnCtiSetForward";
			case OperationIDs.OPID_asnCtiRemoveForward:
				return "asnCtiRemoveForward";
			case OperationIDs.OPID_asnCtiDialDigits:
				return "asnCtiDialDigits";
			case OperationIDs.OPID_asnCtiCompleteCall:
				return "asnCtiCompleteCall";
			case OperationIDs.OPID_asnCtiConference:
				return "asnCtiConference";
			default:
				return undefined;
		}
	}

	/**
	 * Returns the operationID for an operationName
	 *
	 * @param name - the name we want to have the id for
	 * @returns - the id or undefined if not found
	 */
	public getIDForOperationName(name: string): OperationIDs | undefined {
		switch (name) {
			case "asnCtiEnumPhoneLines":
				return OperationIDs.OPID_asnCtiEnumPhoneLines;
			case "asnCtiSnapshotPhoneLine":
				return OperationIDs.OPID_asnCtiSnapshotPhoneLine;
			case "asnCtiLineMonitorStart":
				return OperationIDs.OPID_asnCtiLineMonitorStart;
			case "asnCtiLineMonitorStop":
				return OperationIDs.OPID_asnCtiLineMonitorStop;
			case "asnCtiLineSetDoNotDisturb":
				return OperationIDs.OPID_asnCtiLineSetDoNotDisturb;
			case "asnCtiLineSetRemoteOffice":
				return OperationIDs.OPID_asnCtiLineSetRemoteOffice;
			case "asnCtiNotifyLineInfoChanged":
				return OperationIDs.OPID_asnCtiNotifyLineInfoChanged;
			case "asnCtiNotifyLineDoNotDisturbChanged":
				return OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged;
			case "asnCtiNotifyLineRemoteOfficeChanged":
				return OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged;
			case "asnCtiNotifyMonitorStopped":
				return OperationIDs.OPID_asnCtiNotifyMonitorStopped;
			case "asnCtiNotifyLineSortOrderChanged":
				return OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged;
			case "asnCtiNotifyLineForwardingChanged":
				return OperationIDs.OPID_asnCtiNotifyLineForwardingChanged;
			case "asnCtiNotifyLineCallInformationChanged":
				return OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged;
			case "asnCtiNotifyLineAddRemove":
				return OperationIDs.OPID_asnCtiNotifyLineAddRemove;
			case "asnCtiNotifyMakeCallResult":
				return OperationIDs.OPID_asnCtiNotifyMakeCallResult;
			case "asnCtiNotifyConferenceCreated":
				return OperationIDs.OPID_asnCtiNotifyConferenceCreated;
			case "asnCtiNotifyConferenceDestroyed":
				return OperationIDs.OPID_asnCtiNotifyConferenceDestroyed;
			case "asnCtiNotifyConferencePartyAdded":
				return OperationIDs.OPID_asnCtiNotifyConferencePartyAdded;
			case "asnCtiNotifyConferencePartyRemoved":
				return OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved;
			case "asnCtiNotifyLineCallFeaturesChanged":
				return OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged;
			case "asnCtiNotifyLineProjectSettingsChanged":
				return OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged;
			case "asnCtiMakeCall":
				return OperationIDs.OPID_asnCtiMakeCall;
			case "asnCtiDropCall":
				return OperationIDs.OPID_asnCtiDropCall;
			case "asnCtiLineDropCall":
				return OperationIDs.OPID_asnCtiLineDropCall;
			case "asnCtiAnswerCall":
				return OperationIDs.OPID_asnCtiAnswerCall;
			case "asnCtiRedirectCall":
				return OperationIDs.OPID_asnCtiRedirectCall;
			case "asnCtiPickupCall":
				return OperationIDs.OPID_asnCtiPickupCall;
			case "asnCtiStartCallRecording":
				return OperationIDs.OPID_asnCtiStartCallRecording;
			case "asnCtiStopCallRecording":
				return OperationIDs.OPID_asnCtiStopCallRecording;
			case "asnCtiSetCallData":
				return OperationIDs.OPID_asnCtiSetCallData;
			case "asnCtiMergeCalls":
				return OperationIDs.OPID_asnCtiMergeCalls;
			case "asnCtiSwapHold":
				return OperationIDs.OPID_asnCtiSwapHold;
			case "asnCtiHold":
				return OperationIDs.OPID_asnCtiHold;
			case "asnCtiSetForward":
				return OperationIDs.OPID_asnCtiSetForward;
			case "asnCtiRemoveForward":
				return OperationIDs.OPID_asnCtiRemoveForward;
			case "asnCtiDialDigits":
				return OperationIDs.OPID_asnCtiDialDigits;
			case "asnCtiCompleteCall":
				return OperationIDs.OPID_asnCtiCompleteCall;
			case "asnCtiConference":
				return OperationIDs.OPID_asnCtiConference;
			default:
				return undefined;
		}
	}

	// [PrintTSROSEConstructor]
	/**
	 * Constructs the invoke and oninvoke object targeting all the ROSE related parts.
	 *
	 * @param transport - The transport is the connection to the other side. It takes care of delivering the invoke
	 * to us as well as to send invokes and events to the other side. It also holds the logger.
	 * @param handleEvents - Set this to true if you want to receive events or false if the stub should cached them
	 * until you call dispatchEvents();
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public constructor(transport: IASN1Transport, handleEvents: boolean, handler?: Partial<IENetUC_CTIROSE_Handler>) {
		super(transport, handleEvents);

		this.logFilter = [];

		if (handler)
			this.setHandler(handler);
	}

	// [PrintTSROSESetHandler]
	/**
	 * Sets the handler and registers the operations with it
	 *
	 * @param handler - The handler takes care of handling methods that are exposed through the ASN1 file
	 * The outer ROSE envelop specifies the function that is called. The server looks for an appropriate handler
	 * and calls the handler for the operation. Inside the operation the argument is decoded. Once the handling of the
	 * operation is done the result (error) is encoded and handed back to the callee, embedded in the ROSE envelop and send
	 * back to the other side. If a certain function is not register the function call will fail with not function not implemented
	 */
	public setHandler(handler: Partial<IENetUC_CTIROSE_Handler>): void {
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiEnumPhoneLines, "asnCtiEnumPhoneLines");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiSnapshotPhoneLine, "asnCtiSnapshotPhoneLine");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiLineMonitorStart, "asnCtiLineMonitorStart");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiLineMonitorStop, "asnCtiLineMonitorStop");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiLineSetDoNotDisturb, "asnCtiLineSetDoNotDisturb");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiLineSetRemoteOffice, "asnCtiLineSetRemoteOffice");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineInfoChanged, "asnCtiNotifyLineInfoChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged, "asnCtiNotifyLineDoNotDisturbChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged, "asnCtiNotifyLineRemoteOfficeChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyMonitorStopped, "asnCtiNotifyMonitorStopped");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged, "asnCtiNotifyLineSortOrderChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineForwardingChanged, "asnCtiNotifyLineForwardingChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged, "asnCtiNotifyLineCallInformationChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineAddRemove, "asnCtiNotifyLineAddRemove");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyMakeCallResult, "asnCtiNotifyMakeCallResult");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyConferenceCreated, "asnCtiNotifyConferenceCreated");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyConferenceDestroyed, "asnCtiNotifyConferenceDestroyed");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyConferencePartyAdded, "asnCtiNotifyConferencePartyAdded");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved, "asnCtiNotifyConferencePartyRemoved");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged, "asnCtiNotifyLineCallFeaturesChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged, "asnCtiNotifyLineProjectSettingsChanged");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiMakeCall, "asnCtiMakeCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiDropCall, "asnCtiDropCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiLineDropCall, "asnCtiLineDropCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiAnswerCall, "asnCtiAnswerCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiRedirectCall, "asnCtiRedirectCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiPickupCall, "asnCtiPickupCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiStartCallRecording, "asnCtiStartCallRecording");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiStopCallRecording, "asnCtiStopCallRecording");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiSetCallData, "asnCtiSetCallData");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiMergeCalls, "asnCtiMergeCalls");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiSwapHold, "asnCtiSwapHold");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiHold, "asnCtiHold");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiSetForward, "asnCtiSetForward");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiRemoveForward, "asnCtiRemoveForward");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiDialDigits, "asnCtiDialDigits");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiCompleteCall, "asnCtiCompleteCall");
		this.transport.registerOperation(this, handler, OperationIDs.OPID_asnCtiConference, "asnCtiConference");
		this.transport.registerModuleVersion("ENetUC_CTI", 8, 1718755200);
	}

	// [PrintTSROSEInvokeMethods]

	// [PrintTSROSEInvokeMethod]
	/**
	 * Retrieve line information from the server.
	 * To get information about the lines a user has access to on the server.&lt;br \/&gt;
	 * There are four possible line types, which can be requested:
	 * - userOwnLines: Own lines which the logged in user is owner of.
	 * - userMonitorLines: Own lines plus the lines, the user has special access rights for.
	 * - systemLocalLines: All lines that are local on the system.
	 * - systemGlobalLines: All local lines plus all global known lines; for future use, current its the same as systemLocalLines.
	 *
	 * If attachChangeNotify is set to 1, the server will send asnCtiNotifyLineAddRemove events, if lines were added or removed for the given scope (or line type).
	 *
	 * The monitoring of the line lists can only be stopped by disconnecting from the server.
	 *
	 * @param argument - An AsnCtiEnumPhoneLinesArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiEnumPhoneLinesResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiEnumPhoneLines(argument: ENetUC_CTI.AsnCtiEnumPhoneLinesArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiEnumPhoneLinesResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiEnumPhoneLinesResult, OperationIDs.OPID_asnCtiEnumPhoneLines, "asnCtiEnumPhoneLines", Converter.AsnCtiEnumPhoneLinesArgument_Converter, Converter.AsnCtiEnumPhoneLinesResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Call this function to get the current status of a line.
	 * With asnCtiSnapshotPhoneLine a client can retrieve the current status of a line inclusive calls, forwardings, DnD and remote office states.&lt;br \/&gt;
	 *
	 * Attention: Do not poll with this function get changes of the line state. Use asnCtiLineMonitorStart instead, to be notified if something on the is changing.
	 * asnCtiEnumPhoneLines is not necessary be called before asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiSnapshotPhoneLineArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiSnapshotPhoneLineResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiSnapshotPhoneLine(argument: ENetUC_CTI.AsnCtiSnapshotPhoneLineArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiSnapshotPhoneLineResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiSnapshotPhoneLineResult, OperationIDs.OPID_asnCtiSnapshotPhoneLine, "asnCtiSnapshotPhoneLine", Converter.AsnCtiSnapshotPhoneLineArgument_Converter, Converter.AsnCtiSnapshotPhoneLineResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Gets the current state of a line and attach for call and change notifies on this line.
	 * In order receive events about calls and line state changes a client can call asnCtiLineMonitorStart. The result will contain a current snapshot of the line, the calls and additional information.
	 * To stop these events call asnCtiLineMonitorStop.
	 *
	 * Attention: To get this information just once without further events, call asnCtiSnapshotPhoneLine instead.
	 *
	 * @param argument - An AsnCtiLineMonitorStartArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiLineMonitorStartResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiLineMonitorStart(argument: ENetUC_CTI.AsnCtiLineMonitorStartArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiLineMonitorStartResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiLineMonitorStartResult, OperationIDs.OPID_asnCtiLineMonitorStart, "asnCtiLineMonitorStart", Converter.AsnCtiLineMonitorStartArgument_Converter, Converter.AsnCtiLineMonitorStartResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Stops the call and state change events on a line.
	 * A client can stop events for state changes and calls on a line with a call to asnCtiLineMonitorStop with the corresponding monitor cross reference ID.
	 *
	 * @param argument - An AsnCtiLineMonitorStopArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiLineMonitorStopResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiLineMonitorStop(argument: ENetUC_CTI.AsnCtiLineMonitorStopArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiLineMonitorStopResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiLineMonitorStopResult, OperationIDs.OPID_asnCtiLineMonitorStop, "asnCtiLineMonitorStop", Converter.AsnCtiLineMonitorStopArgument_Converter, Converter.AsnCtiLineMonitorStopResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Set or remove \"Do not Disturb\" feature on the a line.
	 * Most PBX support \"Do not Disturb\" (DnD) on phone lines, so the user can prevent being disturbed by phone calls by setting this feature on his phone line.&lt;br \/&gt;
	 * A Client can call this function to set or remove this feature from the line. See AsnCtiLineSetDoNotDisturbArgument for the arguments needed.
	 *
	 * @param argument - An AsnCtiLineSetDoNotDisturbArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiLineSetDoNotDisturbResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiLineSetDoNotDisturb(argument: ENetUC_CTI.AsnCtiLineSetDoNotDisturbArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiLineSetDoNotDisturbResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiLineSetDoNotDisturbResult, OperationIDs.OPID_asnCtiLineSetDoNotDisturb, "asnCtiLineSetDoNotDisturb", Converter.AsnCtiLineSetDoNotDisturbArgument_Converter, Converter.AsnCtiLineSetDoNotDisturbResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Changes the state of the \"Remote Office\" feature on a line.
	 * \"Remote office\" is a feature, where a user can virtually attach his mobile phone to his line on the PBX. So every incoming call to the line on the PBX will be automatically forwarded to the mobile phone.
	 * Additionally the outgoing calls will be forwarded to the mobile too, if either the PBX itself supports this feature or the UCServer can emulate it.
	 *
	 * @param argument - An AsnCtiLineSetRemoteOfficeArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiLineSetRemoteOfficeResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiLineSetRemoteOffice(argument: ENetUC_CTI.AsnCtiLineSetRemoteOfficeArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiLineSetRemoteOfficeResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiLineSetRemoteOfficeResult, OperationIDs.OPID_asnCtiLineSetRemoteOffice, "asnCtiLineSetRemoteOffice", Converter.AsnCtiLineSetRemoteOfficeArgument_Converter, Converter.AsnCtiLineSetRemoteOfficeResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Initiates a new call on a line.
	 * In most cases the operation is simple. Just provide the line number (e.g. '+49815136856177') to dial from and the number to dial to, let the server format the dialing number.
	 * This is it.&lt;br \/&gt;
	 * It will get a bit more complex, if you want to use additional features like project\/pin rules, hide caller id, provide the contact data and so on.
	 * In this cases you have to add AsnCtiNewCallParams to your arguments. See AsnCtiNewCallParams for more details.
	 *
	 * Remark: The result of this operation does not necessarily reflect, that a call has been dialed successfully. It just confirms the successful execution of the operation.
	 * The corresponding result of the dial command itself (to the PBX for example) will be sent as an asnCtiNotifyMakeCallResult event.
	 *
	 * @param argument - An AsnCtiMakeCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiMakeCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiMakeCall(argument: ENetUC_CTI.AsnCtiMakeCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiMakeCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiMakeCallResult, OperationIDs.OPID_asnCtiMakeCall, "asnCtiMakeCall", Converter.AsnCtiMakeCallArgument_Converter, Converter.AsnCtiMakeCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Drop a call identified by its connection identifier.
	 * A call can be dropped by its connection identifier if it is necessary to identify the exact call, e.g. in a conference or one of the held calls on a line.
	 * If you just want to drop the active call on a line you can call asnCtiLineDropCall instead.
	 *
	 * @param argument - An AsnCtiDropCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiDropCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiDropCall(argument: ENetUC_CTI.AsnCtiDropCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiDropCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiDropCallResult, OperationIDs.OPID_asnCtiDropCall, "asnCtiDropCall", Converter.AsnCtiDropCallArgument_Converter, Converter.AsnCtiDropCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Drop the cative call on a line.
	 * To simply drop the active call on a line, call this operation.&lt;br \/&gt;
	 * If there are more than one call on the line, it is recommended to call asnCtiDropCall and specify the exact call to drop by it connection identifier.
	 *
	 * @param argument - An AsnCtiLineDropCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiLineDropCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiLineDropCall(argument: ENetUC_CTI.AsnCtiLineDropCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiLineDropCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiLineDropCallResult, OperationIDs.OPID_asnCtiLineDropCall, "asnCtiLineDropCall", Converter.AsnCtiLineDropCallArgument_Converter, Converter.AsnCtiLineDropCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Accept a call on a line.
	 * If a call is in state OFFERING (see EnumCallState, incoming call ringing) the call can be accepted with this operation.
	 *
	 * @param argument - An AsnCtiAnswerCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiAnswerCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiAnswerCall(argument: ENetUC_CTI.AsnCtiAnswerCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiAnswerCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiAnswerCallResult, OperationIDs.OPID_asnCtiAnswerCall, "asnCtiAnswerCall", Converter.AsnCtiAnswerCallArgument_Converter, Converter.AsnCtiAnswerCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Redirect an incoming call to another line.
	 * To redirect an incoming, ringing call (call state OFFERING) to another line, execute this operation.
	 * This operation works also for lines, where the user has corresponding access rights to.&lt;br \/&gt;
	 * Additionally this operation can be executed on a contact of the favorite list where the caller has the access rights to control the lines of the contact.
	 *
	 * Remark: If you want to pickup a call (picking an offering call to an own line), use asnCtiPickupCall.
	 *
	 * @param argument - An AsnCtiRedirectCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiRedirectCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiRedirectCall(argument: ENetUC_CTI.AsnCtiRedirectCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiRedirectCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiRedirectCallResult, OperationIDs.OPID_asnCtiRedirectCall, "asnCtiRedirectCall", Converter.AsnCtiRedirectCallArgument_Converter, Converter.AsnCtiRedirectCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Pickup a ringing call from another line on an own line.
	 * Getting an ringing call from another line to an own line execute this operation.&lt;br \/&gt;
	 * Picking up calls requires an appropriate configuration (rights) on the PBX.
	 * Thus it is recommended to use asnCtiRedirectCall if you are not aware if the configuration has been set properly.
	 * Picking a call leads to a connected call on the extension picking the call while redirecting leads to an offering call on the new extension.
	 *
	 * @param argument - An AsnCtiPickupCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiPickupCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiPickupCall(argument: ENetUC_CTI.AsnCtiPickupCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiPickupCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiPickupCallResult, OperationIDs.OPID_asnCtiPickupCall, "asnCtiPickupCall", Converter.AsnCtiPickupCallArgument_Converter, Converter.AsnCtiPickupCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Start recording of a call.
	 * If the call recorder is configured on the server, calls can be recorded if the feature eCFEATURESTARTCALLRECORD is set on the call.&lt;br \/&gt;
	 * If executed successfully, the server will created a conference with the connected party and the call recorder.
	 * If the caller or called party disconnects, the conference will be terminated and the server will dispatch the recording (wav or mp3 file) to the initiator of the recording.
	 *
	 * @param argument - An AsnCtiStartCallRecordingArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiStartCallRecordingResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiStartCallRecording(argument: ENetUC_CTI.AsnCtiStartCallRecordingArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiStartCallRecordingResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiStartCallRecordingResult, OperationIDs.OPID_asnCtiStartCallRecording, "asnCtiStartCallRecording", Converter.AsnCtiStartCallRecordingArgument_Converter, Converter.AsnCtiStartCallRecordingResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Stop recording of a call.
	 * To stop recording a call without destroying the connection this operation is executed.
	 * This will terminate the conference with the call recorder line without disconnecting the other calls.
	 * To execute this operation successfully, the feature eCFEATURESTOPCALLRECORD must be set on the call.&lt;br \/&gt;
	 * The record will be sent to the initiator of the recording.
	 *
	 * @param argument - An AsnCtiStopCallRecordingArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiStopCallRecordingResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiStopCallRecording(argument: ENetUC_CTI.AsnCtiStopCallRecordingArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiStopCallRecordingResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiStopCallRecordingResult, OperationIDs.OPID_asnCtiStopCallRecording, "asnCtiStopCallRecording", Converter.AsnCtiStopCallRecordingArgument_Converter, Converter.AsnCtiStopCallRecordingResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Add some data to the call which will be transferred to other clients.
	 * For some use cases it will be necessary to transfer business data attached to a call to other clients with the call, e.g. while transferring it.&lt;br \/&gt;
	 * With this operation this data can be added to the call information of a call without setting the whole information structure again.&lt;br \/&gt;
	 * This operation only executes successfully if the user is the line owner.&lt;br \/&gt;
	 * [TODO: MORE DETAILS NEEDED! Especial for CallDataAnnouncement (ConnectionID unknown)]
	 *
	 * @param argument - An AsnCtiSetCallDataArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiSetCallDataResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiSetCallData(argument: ENetUC_CTI.AsnCtiSetCallDataArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiSetCallDataResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiSetCallDataResult, OperationIDs.OPID_asnCtiSetCallData, "asnCtiSetCallData", Converter.AsnCtiSetCallDataArgument_Converter, Converter.AsnCtiSetCallDataResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Merge two calls on a line together.
	 * It is possible to connect two parties with each other. It does not result in a conference, the line is not member of that call any longer after executing the function.
	 * To execute this successfully, the connection identifier of the calls must be known and the calls must be in the call list of the same line (e.g. one active, one on hold).
	 * Both calls must have the call feature eCFEATUREMERGECALLS set.
	 *
	 * @param argument - An AsnCtiMergeCallsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiMergeCallsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiMergeCalls(argument: ENetUC_CTI.AsnCtiMergeCallsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiMergeCallsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiMergeCallsResult, OperationIDs.OPID_asnCtiMergeCalls, "asnCtiMergeCalls", Converter.AsnCtiMergeCallsArgument_Converter, Converter.AsnCtiMergeCallsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Swap puts the active call on hold and retrieves the hold call
	 * You can swap between a held call and an active call with this function.&lt;br \/&gt;
	 * This operation needs two calls on the same line (one active, one held) to execute successfully.
	 * Both calls must have the call feature eCFEATURESWAPHOLD set.
	 *
	 * @param argument - An AsnCtiSwapHoldArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiSwapHoldResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiSwapHold(argument: ENetUC_CTI.AsnCtiSwapHoldArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiSwapHoldResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiSwapHoldResult, OperationIDs.OPID_asnCtiSwapHold, "asnCtiSwapHold", Converter.AsnCtiSwapHoldArgument_Converter, Converter.AsnCtiSwapHoldResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Set the call on hold, so another another call in the same line will be possible to make.
	 * For some reasons it is possible to set a call on hold. This can be used to a call back to another line, setup a conference, set a transfer etc.&lt;br \/&gt;
	 * A call on hold isn't disconnect, but the call partner cannot hear what is spoken while on hold and is waiting for further actions.
	 *
	 * @param argument - An AsnCtiHoldArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiHoldResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiHold(argument: ENetUC_CTI.AsnCtiHoldArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiHoldResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiHoldResult, OperationIDs.OPID_asnCtiHold, "asnCtiHold", Converter.AsnCtiHoldArgument_Converter, Converter.AsnCtiHoldResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Set simple call forwards.
	 * Set a call forward on a line (optionally with conditions). Default is a unconditional forward from one line to another.&lt;br \/&gt;
	 * To set multiple forwards on a line (if it is supported by the PBX system), call this function again on the same line.
	 *
	 * @param argument - An AsnCtiSetForwardArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiSetForwardResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiSetForward(argument: ENetUC_CTI.AsnCtiSetForwardArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiSetForwardResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiSetForwardResult, OperationIDs.OPID_asnCtiSetForward, "asnCtiSetForward", Converter.AsnCtiSetForwardArgument_Converter, Converter.AsnCtiSetForwardResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Remove a forward from a line.
	 * This operation removes all forwards from a line&lt;br \/&gt;
	 * To remove one forward form the list of forwards on the line, the optional parameters \"ForwardMode\" and \"ForwardDestination\" must be set to match exactly in the list.&lt;br \/&gt;
	 * This information can be read from the current line information sent to the client by the event \"asnCtiNotifyLineInfoChanged\" or by calling asnCtiSnapshotPhoneLine.
	 *
	 * @param argument - An AsnCtiRemoveForwardArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiRemoveForwardResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiRemoveForward(argument: ENetUC_CTI.AsnCtiRemoveForwardArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiRemoveForwardResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiRemoveForwardResult, OperationIDs.OPID_asnCtiRemoveForward, "asnCtiRemoveForward", Converter.AsnCtiRemoveForwardArgument_Converter, Converter.AsnCtiRemoveForwardResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Dial DTMF tones on an active call.
	 * For call menus or other use cases it is possible to generate dial tones on an active call.&lt;br \/&gt;
	 * There are different digit modes possible: LINEDIGITMODE_DTMF, LINEDIGITMODE_DTMFEND and LINEDIGITMODE_PULSE
	 *
	 * @param argument - An AsnCtiDialDigitsArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiDialDigitsResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiDialDigits(argument: ENetUC_CTI.AsnCtiDialDigitsArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiDialDigitsResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiDialDigitsResult, OperationIDs.OPID_asnCtiDialDigits, "asnCtiDialDigits", Converter.AsnCtiDialDigitsArgument_Converter, Converter.AsnCtiDialDigitsResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Set a automatic call back if the call was not accepted or busy.
	 * If a call was unsuccessful because the remote party was busy or the call was not answered, this operation sets the the complete call function of the PBX system to call back the caller automatically if the called party \/ line is free \/ back again.
	 *
	 * @param argument - An AsnCtiCompleteCallArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiCompleteCallResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiCompleteCall(argument: ENetUC_CTI.AsnCtiCompleteCallArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiCompleteCallResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiCompleteCallResult, OperationIDs.OPID_asnCtiCompleteCall, "asnCtiCompleteCall", Converter.AsnCtiCompleteCallArgument_Converter, Converter.AsnCtiCompleteCallResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Initiate a conference call with two already existing calls of a line.
	 * To initiate a conference, setup two calls via a call back (asnCtiMakeCall =&gt; get this call establish =&gt; asnCtiMakeCall),
	 * so you have one call on hold and one active. Now execute this operation with the two connection identifiers.
	 * As result, you should now have a conference with 3 attendants (you and the other two call parties).
	 *
	 * @param argument - An AsnCtiConferenceArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns a Promise resolving into AsnCtiConferenceResult, an AsnRequestError or AsnInvokeProblem object
	 */
	public async invoke_asnCtiConference(argument: ENetUC_CTI.AsnCtiConferenceArgument, invokeContext?: ISendInvokeContextParams): Promise<ENetUC_CTI.AsnCtiConferenceResult | ENetUC_Common.AsnRequestError | AsnInvokeProblem> {
		return this.handleInvoke(argument, ENetUC_CTI.AsnCtiConferenceResult, OperationIDs.OPID_asnCtiConference, "asnCtiConference", Converter.AsnCtiConferenceArgument_Converter, Converter.AsnCtiConferenceResult_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if a line changed its status or has been added or removed.
	 * In order to get these events the line must be monitored with asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyLineInfoChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineInfoChanged(argument: ENetUC_CTI.AsnCtiNotifyLineInfoChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineInfoChanged, "asnCtiNotifyLineInfoChanged", Converter.AsnCtiNotifyLineInfoChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if a line changed its DnD status.
	 * In order to get these events the line must be monitored with asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyLineDoNotDisturbChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineDoNotDisturbChanged(argument: ENetUC_CTI.AsnCtiNotifyLineDoNotDisturbChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged, "asnCtiNotifyLineDoNotDisturbChanged", Converter.AsnCtiNotifyLineDoNotDisturbChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if a line changed its remote office state.
	 * In order to get these events the line must be monitored with asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyLineRemoteOfficeChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineRemoteOfficeChanged(argument: ENetUC_CTI.AsnCtiNotifyLineRemoteOfficeChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged, "asnCtiNotifyLineRemoteOfficeChanged", Converter.AsnCtiNotifyLineRemoteOfficeChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server that a monitoring point was closed due to a configuration change
	 * In order to get these events the line must be monitored with asnCtiLineMonitorStart.
	 * This event is send to the client if a monitor was closed due to a configuation change on the server
	 * The client shall remove the monitor point with u8sMonitorCrossRefID on the client side.
	 *
	 * @param argument - An AsnCtiNotifyMonitorStoppedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyMonitorStopped(argument: ENetUC_CTI.AsnCtiNotifyMonitorStoppedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyMonitorStopped, "asnCtiNotifyMonitorStopped", Converter.AsnCtiNotifyMonitorStoppedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server that a monitoring point has changed position from the configurative view
	 * In order to get these events the line must be monitored with asnCtiLineMonitorStart.
	 * This event is send to the client if the sort order of the lines has changed (line added, config lines have swapped positions, (no event is dispatched if a line was removed))
	 * This event is only dispatched for the userOwnLines (see AsnCtiEnumPhoneLinesArgument)
	 *
	 * @param argument - An AsnCtiNotifyLineSortOrderChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineSortOrderChanged(argument: ENetUC_CTI.AsnCtiNotifyLineSortOrderChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged, "asnCtiNotifyLineSortOrderChanged", Converter.AsnCtiNotifyLineSortOrderChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if a line changed its forwardings.
	 * In order to get these events the line must be monitored with asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyLineForwardingChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineForwardingChanged(argument: ENetUC_CTI.AsnCtiNotifyLineForwardingChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineForwardingChanged, "asnCtiNotifyLineForwardingChanged", Converter.AsnCtiNotifyLineForwardingChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if a call changed its state.
	 * In order to get this event the line must be monitored with asnCtiLineMonitorStart.
	 * Calls are changing their state and additional information during their live time. This event reflects the new status&lt;br \/&gt;
	 *
	 * @param argument - An AsnCtiNotifyLineCallInformationChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineCallInformationChanged(argument: ENetUC_CTI.AsnCtiNotifyLineCallInformationChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged, "asnCtiNotifyLineCallInformationChanged", Converter.AsnCtiNotifyLineCallInformationChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if asnCtiEnumPhoneLines was called to monitor the lines of the user.
	 * In order to get this event the line must be monitored via asnCtiEnumPhoneLines.
	 * With asnCtiEnumPhoneLines the client defined, which sort of lines it wants to monitor.
	 * If there are changes to the corresponding line list, this event will reflect the changes to the client.&lt;br \/&gt;
	 *
	 * @param argument - An AsnCtiNotifyLineAddRemoveArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineAddRemove(argument: ENetUC_CTI.AsnCtiNotifyLineAddRemoveArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineAddRemove, "asnCtiNotifyLineAddRemove", Converter.AsnCtiNotifyLineAddRemoveArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server with the result of an asynchronous make call operation on the server.
	 * In order to get this event the client must have called asnCtiMakeCall first.
	 * Make call is a asynchronous process in the UCServer. So the final result will be send as an event from the server.
	 * This event contains the result the PBX provided.&lt;br \/&gt;
	 *
	 * @param argument - An AsnCtiNotifyMakeCallResultArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyMakeCallResult(argument: ENetUC_CTI.AsnCtiNotifyMakeCallResultArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyMakeCallResult, "asnCtiNotifyMakeCallResult", Converter.AsnCtiNotifyMakeCallResultArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if there is a conference established on a line.
	 * In order to get these events the line must be monitored via asnCtiLineMonitorStart.
	 * This event will inform the client, if a conference was established and with whom.&lt;br \/&gt;
	 * In this way, the client gets detailed information about the participants and the conference controller.&lt;br \/&gt;
	 *
	 * @param argument - An AsnCtiNotifyConferenceCreatedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyConferenceCreated(argument: ENetUC_CTI.AsnCtiNotifyConferenceCreatedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyConferenceCreated, "asnCtiNotifyConferenceCreated", Converter.AsnCtiNotifyConferenceCreatedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server if a conference is closed\/destroyed.
	 * In order to get these events the line must be monitored via asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyConferenceDestroyedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyConferenceDestroyed(argument: ENetUC_CTI.AsnCtiNotifyConferenceDestroyedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyConferenceDestroyed, "asnCtiNotifyConferenceDestroyed", Converter.AsnCtiNotifyConferenceDestroyedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server when a new participant was added to a conference.
	 * In order to get these events the line must be monitored via asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyConferencePartyAddedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyConferencePartyAdded(argument: ENetUC_CTI.AsnCtiNotifyConferencePartyAddedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyConferencePartyAdded, "asnCtiNotifyConferencePartyAdded", Converter.AsnCtiNotifyConferencePartyAddedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server when a conference participant was removed.
	 * In order to get these events the line must be monitored via asnCtiLineMonitorStart.
	 *
	 * @param argument - An AsnCtiNotifyConferencePartyRemovedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyConferencePartyRemoved(argument: ENetUC_CTI.AsnCtiNotifyConferencePartyRemovedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved, "asnCtiNotifyConferencePartyRemoved", Converter.AsnCtiNotifyConferencePartyRemovedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server when call features have changed.
	 * In order to get these events the line must be monitored via asnCtiLineMonitorStart.
	 * If the state of a call changes or other events on a call happened its features are most likely change too.
	 * Some changes does not change the call state itself, so there will be no call information change event for that call.
	 * In this case asnCtiNotifyLineCallFeaturesChanged will be sent if only the call features have changed.
	 *
	 * @param argument - An AsnCtiNotifyLineCallFeaturesChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineCallFeaturesChanged(argument: ENetUC_CTI.AsnCtiNotifyLineCallFeaturesChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged, "asnCtiNotifyLineCallFeaturesChanged", Converter.AsnCtiNotifyLineCallFeaturesChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEInvokeMethod]
	/**
	 * Event from the server when the project settings or the location of a line has changed.
	 * In order to get these events the line must be monitored via asnCtiLineMonitorStart.
	 * The project settings are part of the location settings of a line. If the location settings were changed, this event will be sent.
	 *
	 * @param argument - An AsnCtiNotifyLineProjectSettingsChangedArgument object containing all the relevant parameters for the call
	 * @param invokeContext - Invoke related contextual data (e.g. a clientConnectionID)
	 * @returns undefined or, if bSendEventSynchronous has been set true when the event was sent
	 */
	public event_asnCtiNotifyLineProjectSettingsChanged(argument: ENetUC_CTI.AsnCtiNotifyLineProjectSettingsChangedArgument, invokeContext?: ISendInvokeContextParams): undefined | boolean {
		return this.handleEvent(argument, OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged, "asnCtiNotifyLineProjectSettingsChanged", Converter.AsnCtiNotifyLineProjectSettingsChangedArgument_Converter, invokeContext);
	}

	// [PrintTSROSEOnInvokeswitchCase]
	/**
	 * This is the central onInvoke method that is called whenever a method of this module is called.
	 * Based on the operationID we step into the decoding of the method argument and call the method in the handler.
	 * The result is then again encoded and send to the other side.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the metho in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled, ROSEResult for the invoke result, ROSEError for an error or undefined if an event was called
	 */
	public async onInvoke(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_CTIROSE_Handler): Promise<ROSEReject | ROSEResult | ROSEError | undefined> {
		switch (invoke.operationID) {
			case OperationIDs.OPID_asnCtiEnumPhoneLines:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiEnumPhoneLines, ENetUC_CTI.AsnCtiEnumPhoneLinesArgument, Converter.AsnCtiEnumPhoneLinesArgument_Converter, Converter.AsnCtiEnumPhoneLinesResult_Converter, handler, handler.onInvoke_asnCtiEnumPhoneLines, invokeContext);
			case OperationIDs.OPID_asnCtiSnapshotPhoneLine:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiSnapshotPhoneLine, ENetUC_CTI.AsnCtiSnapshotPhoneLineArgument, Converter.AsnCtiSnapshotPhoneLineArgument_Converter, Converter.AsnCtiSnapshotPhoneLineResult_Converter, handler, handler.onInvoke_asnCtiSnapshotPhoneLine, invokeContext);
			case OperationIDs.OPID_asnCtiLineMonitorStart:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiLineMonitorStart, ENetUC_CTI.AsnCtiLineMonitorStartArgument, Converter.AsnCtiLineMonitorStartArgument_Converter, Converter.AsnCtiLineMonitorStartResult_Converter, handler, handler.onInvoke_asnCtiLineMonitorStart, invokeContext);
			case OperationIDs.OPID_asnCtiLineMonitorStop:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiLineMonitorStop, ENetUC_CTI.AsnCtiLineMonitorStopArgument, Converter.AsnCtiLineMonitorStopArgument_Converter, Converter.AsnCtiLineMonitorStopResult_Converter, handler, handler.onInvoke_asnCtiLineMonitorStop, invokeContext);
			case OperationIDs.OPID_asnCtiLineSetDoNotDisturb:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiLineSetDoNotDisturb, ENetUC_CTI.AsnCtiLineSetDoNotDisturbArgument, Converter.AsnCtiLineSetDoNotDisturbArgument_Converter, Converter.AsnCtiLineSetDoNotDisturbResult_Converter, handler, handler.onInvoke_asnCtiLineSetDoNotDisturb, invokeContext);
			case OperationIDs.OPID_asnCtiLineSetRemoteOffice:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiLineSetRemoteOffice, ENetUC_CTI.AsnCtiLineSetRemoteOfficeArgument, Converter.AsnCtiLineSetRemoteOfficeArgument_Converter, Converter.AsnCtiLineSetRemoteOfficeResult_Converter, handler, handler.onInvoke_asnCtiLineSetRemoteOffice, invokeContext);
			case OperationIDs.OPID_asnCtiMakeCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiMakeCall, ENetUC_CTI.AsnCtiMakeCallArgument, Converter.AsnCtiMakeCallArgument_Converter, Converter.AsnCtiMakeCallResult_Converter, handler, handler.onInvoke_asnCtiMakeCall, invokeContext);
			case OperationIDs.OPID_asnCtiDropCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiDropCall, ENetUC_CTI.AsnCtiDropCallArgument, Converter.AsnCtiDropCallArgument_Converter, Converter.AsnCtiDropCallResult_Converter, handler, handler.onInvoke_asnCtiDropCall, invokeContext);
			case OperationIDs.OPID_asnCtiLineDropCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiLineDropCall, ENetUC_CTI.AsnCtiLineDropCallArgument, Converter.AsnCtiLineDropCallArgument_Converter, Converter.AsnCtiLineDropCallResult_Converter, handler, handler.onInvoke_asnCtiLineDropCall, invokeContext);
			case OperationIDs.OPID_asnCtiAnswerCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiAnswerCall, ENetUC_CTI.AsnCtiAnswerCallArgument, Converter.AsnCtiAnswerCallArgument_Converter, Converter.AsnCtiAnswerCallResult_Converter, handler, handler.onInvoke_asnCtiAnswerCall, invokeContext);
			case OperationIDs.OPID_asnCtiRedirectCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiRedirectCall, ENetUC_CTI.AsnCtiRedirectCallArgument, Converter.AsnCtiRedirectCallArgument_Converter, Converter.AsnCtiRedirectCallResult_Converter, handler, handler.onInvoke_asnCtiRedirectCall, invokeContext);
			case OperationIDs.OPID_asnCtiPickupCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiPickupCall, ENetUC_CTI.AsnCtiPickupCallArgument, Converter.AsnCtiPickupCallArgument_Converter, Converter.AsnCtiPickupCallResult_Converter, handler, handler.onInvoke_asnCtiPickupCall, invokeContext);
			case OperationIDs.OPID_asnCtiStartCallRecording:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiStartCallRecording, ENetUC_CTI.AsnCtiStartCallRecordingArgument, Converter.AsnCtiStartCallRecordingArgument_Converter, Converter.AsnCtiStartCallRecordingResult_Converter, handler, handler.onInvoke_asnCtiStartCallRecording, invokeContext);
			case OperationIDs.OPID_asnCtiStopCallRecording:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiStopCallRecording, ENetUC_CTI.AsnCtiStopCallRecordingArgument, Converter.AsnCtiStopCallRecordingArgument_Converter, Converter.AsnCtiStopCallRecordingResult_Converter, handler, handler.onInvoke_asnCtiStopCallRecording, invokeContext);
			case OperationIDs.OPID_asnCtiSetCallData:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiSetCallData, ENetUC_CTI.AsnCtiSetCallDataArgument, Converter.AsnCtiSetCallDataArgument_Converter, Converter.AsnCtiSetCallDataResult_Converter, handler, handler.onInvoke_asnCtiSetCallData, invokeContext);
			case OperationIDs.OPID_asnCtiMergeCalls:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiMergeCalls, ENetUC_CTI.AsnCtiMergeCallsArgument, Converter.AsnCtiMergeCallsArgument_Converter, Converter.AsnCtiMergeCallsResult_Converter, handler, handler.onInvoke_asnCtiMergeCalls, invokeContext);
			case OperationIDs.OPID_asnCtiSwapHold:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiSwapHold, ENetUC_CTI.AsnCtiSwapHoldArgument, Converter.AsnCtiSwapHoldArgument_Converter, Converter.AsnCtiSwapHoldResult_Converter, handler, handler.onInvoke_asnCtiSwapHold, invokeContext);
			case OperationIDs.OPID_asnCtiHold:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiHold, ENetUC_CTI.AsnCtiHoldArgument, Converter.AsnCtiHoldArgument_Converter, Converter.AsnCtiHoldResult_Converter, handler, handler.onInvoke_asnCtiHold, invokeContext);
			case OperationIDs.OPID_asnCtiSetForward:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiSetForward, ENetUC_CTI.AsnCtiSetForwardArgument, Converter.AsnCtiSetForwardArgument_Converter, Converter.AsnCtiSetForwardResult_Converter, handler, handler.onInvoke_asnCtiSetForward, invokeContext);
			case OperationIDs.OPID_asnCtiRemoveForward:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiRemoveForward, ENetUC_CTI.AsnCtiRemoveForwardArgument, Converter.AsnCtiRemoveForwardArgument_Converter, Converter.AsnCtiRemoveForwardResult_Converter, handler, handler.onInvoke_asnCtiRemoveForward, invokeContext);
			case OperationIDs.OPID_asnCtiDialDigits:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiDialDigits, ENetUC_CTI.AsnCtiDialDigitsArgument, Converter.AsnCtiDialDigitsArgument_Converter, Converter.AsnCtiDialDigitsResult_Converter, handler, handler.onInvoke_asnCtiDialDigits, invokeContext);
			case OperationIDs.OPID_asnCtiCompleteCall:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiCompleteCall, ENetUC_CTI.AsnCtiCompleteCallArgument, Converter.AsnCtiCompleteCallArgument_Converter, Converter.AsnCtiCompleteCallResult_Converter, handler, handler.onInvoke_asnCtiCompleteCall, invokeContext);
			case OperationIDs.OPID_asnCtiConference:
				return await this.handleOnInvoke(invoke, OperationIDs.OPID_asnCtiConference, ENetUC_CTI.AsnCtiConferenceArgument, Converter.AsnCtiConferenceArgument_Converter, Converter.AsnCtiConferenceResult_Converter, handler, handler.onInvoke_asnCtiConference, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineInfoChanged:
			case OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged:
			case OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged:
			case OperationIDs.OPID_asnCtiNotifyMonitorStopped:
			case OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged:
			case OperationIDs.OPID_asnCtiNotifyLineForwardingChanged:
			case OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged:
			case OperationIDs.OPID_asnCtiNotifyLineAddRemove:
			case OperationIDs.OPID_asnCtiNotifyMakeCallResult:
			case OperationIDs.OPID_asnCtiNotifyConferenceCreated:
			case OperationIDs.OPID_asnCtiNotifyConferenceDestroyed:
			case OperationIDs.OPID_asnCtiNotifyConferencePartyAdded:
			case OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved:
			case OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged:
			case OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged:
				return this.onEvent(invoke, invokeContext, handler);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_CTIROSE`);
		}
	}

	// [PrintTSROSEOnEventSwitchCase]
	/**
	 * This is the onEvent method that is called whenever an event is called in this module.
	 * It is called from the onInvoke in case of an event is being called.
	 * Depending on the handleEvents flag the event is either handled or cached.
	 *
	 * @param invoke - The (ROSE) decoded invoke which also contains the function argument (not yet decoded). The
	 * operationID is the one that defines which function we call. In the switch case we decode the methods argument
	 * and call the method in the handler.
	 * @param invokeContext - The invoke related contextual data (see IReceiveInvokeContext)
	 * @param handler - This object is handling the invoke after having successfully decoded the argument.
	 * it contains the methods as defined in the asn.1 files.
	 * @returns ROSEReject if the request was not handled or undefined
	 */
	private async onEvent(invoke: ROSEInvoke, invokeContext: IReceiveInvokeContext, handler: IENetUC_CTIROSE_Handler): Promise<ROSEReject | undefined> {
		// If the class says do not handle events and the override flag in the invokeContext has not been set, add the event to the que, otherwise we dispatch it
		if (!this.handleEvents && !invokeContext?.handleEvent) {
			this.transport.log(ELogSeverity.debug, "Adding event to queue", "onEvent", this, { operationName: invoke.operationName, operationID: invoke.operationID });
			this.cachedEvents.push({ invoke, invokeContext, handler });
			return;
		}

		switch (invoke.operationID) {
			case OperationIDs.OPID_asnCtiNotifyLineInfoChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineInfoChanged, ENetUC_CTI.AsnCtiNotifyLineInfoChangedArgument, Converter.AsnCtiNotifyLineInfoChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineInfoChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineDoNotDisturbChanged, ENetUC_CTI.AsnCtiNotifyLineDoNotDisturbChangedArgument, Converter.AsnCtiNotifyLineDoNotDisturbChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineDoNotDisturbChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineRemoteOfficeChanged, ENetUC_CTI.AsnCtiNotifyLineRemoteOfficeChangedArgument, Converter.AsnCtiNotifyLineRemoteOfficeChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineRemoteOfficeChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyMonitorStopped:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyMonitorStopped, ENetUC_CTI.AsnCtiNotifyMonitorStoppedArgument, Converter.AsnCtiNotifyMonitorStoppedArgument_Converter, handler, handler.onEvent_asnCtiNotifyMonitorStopped, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineSortOrderChanged, ENetUC_CTI.AsnCtiNotifyLineSortOrderChangedArgument, Converter.AsnCtiNotifyLineSortOrderChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineSortOrderChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineForwardingChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineForwardingChanged, ENetUC_CTI.AsnCtiNotifyLineForwardingChangedArgument, Converter.AsnCtiNotifyLineForwardingChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineForwardingChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineCallInformationChanged, ENetUC_CTI.AsnCtiNotifyLineCallInformationChangedArgument, Converter.AsnCtiNotifyLineCallInformationChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineCallInformationChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineAddRemove:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineAddRemove, ENetUC_CTI.AsnCtiNotifyLineAddRemoveArgument, Converter.AsnCtiNotifyLineAddRemoveArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineAddRemove, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyMakeCallResult:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyMakeCallResult, ENetUC_CTI.AsnCtiNotifyMakeCallResultArgument, Converter.AsnCtiNotifyMakeCallResultArgument_Converter, handler, handler.onEvent_asnCtiNotifyMakeCallResult, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyConferenceCreated:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyConferenceCreated, ENetUC_CTI.AsnCtiNotifyConferenceCreatedArgument, Converter.AsnCtiNotifyConferenceCreatedArgument_Converter, handler, handler.onEvent_asnCtiNotifyConferenceCreated, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyConferenceDestroyed:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyConferenceDestroyed, ENetUC_CTI.AsnCtiNotifyConferenceDestroyedArgument, Converter.AsnCtiNotifyConferenceDestroyedArgument_Converter, handler, handler.onEvent_asnCtiNotifyConferenceDestroyed, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyConferencePartyAdded:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyConferencePartyAdded, ENetUC_CTI.AsnCtiNotifyConferencePartyAddedArgument, Converter.AsnCtiNotifyConferencePartyAddedArgument_Converter, handler, handler.onEvent_asnCtiNotifyConferencePartyAdded, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyConferencePartyRemoved, ENetUC_CTI.AsnCtiNotifyConferencePartyRemovedArgument, Converter.AsnCtiNotifyConferencePartyRemovedArgument_Converter, handler, handler.onEvent_asnCtiNotifyConferencePartyRemoved, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineCallFeaturesChanged, ENetUC_CTI.AsnCtiNotifyLineCallFeaturesChangedArgument, Converter.AsnCtiNotifyLineCallFeaturesChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineCallFeaturesChanged, invokeContext);
			case OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged:
				return await this.handleOnEvent(invoke, OperationIDs.OPID_asnCtiNotifyLineProjectSettingsChanged, ENetUC_CTI.AsnCtiNotifyLineProjectSettingsChangedArgument, Converter.AsnCtiNotifyLineProjectSettingsChangedArgument_Converter, handler, handler.onEvent_asnCtiNotifyLineProjectSettingsChanged, invokeContext);
			default:
				// If you land here stub of client and server are incompatible...
				debugger;
				return createInvokeReject(invoke, AsnInvokeProblemEnum.unrecognisedOperation, `${invoke.operationID} ("${invoke.operationName}") is not a function of ENetUC_CTIROSE`);
		}
	}
}
